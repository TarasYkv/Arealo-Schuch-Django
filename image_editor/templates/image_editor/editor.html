{% extends 'base.html' %}
{% load loomads_tags %}

{% block content %}
<div class="row">
    <div class="col-12">
        <div class="d-flex justify-content-between align-items-center mb-4">
            <h1 class="h2">
                <i class="fas fa-edit text-primary"></i> Bildeditor: {{ project.name }}
            </h1>
            <div class="btn-group">
                <a href="{% url 'image_editor:project_detail' project.pk %}" class="btn btn-outline-secondary">
                    <i class="fas fa-info-circle"></i> Details
                </a>
                <a href="{% url 'image_editor:dashboard' %}" class="btn btn-outline-secondary">
                    <i class="fas fa-arrow-left"></i> Dashboard
                </a>
            </div>
        </div>
    </div>
</div>

<div class="row">
    <!-- Werkzeuge Panel -->
    <div class="col-md-3">
        <div class="card mb-3">
            <div class="card-header">
                <h6 class="mb-0">
                    <i class="fas fa-tools"></i> Basis-Bearbeitung
                </h6>
            </div>
            <div class="card-body">
                <div class="d-grid gap-2">
                    <button class="btn btn-outline-primary btn-sm" onclick="applyBasicOperation('invert')">
                        <i class="fas fa-adjust"></i> Invertieren
                    </button>
                    <button class="btn btn-outline-primary btn-sm" onclick="applyBasicOperation('grayscale')">
                        <i class="fas fa-palette"></i> Schwarzweiß
                    </button>
                    
                    <!-- Slider für Helligkeit -->
                    <div class="mt-2">
                        <label class="form-label small">Helligkeit</label>
                        <input type="range" class="form-range" min="0.1" max="2.0" step="0.1" value="1.0" 
                               id="brightness-slider" onchange="applySliderOperation('brightness', this.value)">
                        <small class="text-muted d-block">Aktuell: <span id="brightness-value">1.0</span></small>
                    </div>
                    
                    <!-- Slider für Kontrast -->
                    <div class="mt-2">
                        <label class="form-label small">Kontrast</label>
                        <input type="range" class="form-range" min="0.1" max="2.0" step="0.1" value="1.0" 
                               id="contrast-slider" onchange="applySliderOperation('contrast', this.value)">
                        <small class="text-muted d-block">Aktuell: <span id="contrast-value">1.0</span></small>
                    </div>
                    
                    <!-- Slider für Sättigung -->
                    <div class="mt-2">
                        <label class="form-label small">Sättigung</label>
                        <input type="range" class="form-range" min="0.0" max="2.0" step="0.1" value="1.0" 
                               id="saturation-slider" onchange="applySliderOperation('saturation', this.value)">
                        <small class="text-muted d-block">Aktuell: <span id="saturation-value">1.0</span></small>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="card mb-3">
            <div class="card-header">
                <h6 class="mb-0">
                    <i class="fas fa-magic"></i> Erweiterte Filter
                </h6>
            </div>
            <div class="card-body">
                <div class="d-grid gap-2">
                    <button class="btn btn-outline-success btn-sm" onclick="showFilterSettings('emboss')">
                        <i class="fas fa-mountain"></i> Prägen
                    </button>
                    <button class="btn btn-outline-success btn-sm" onclick="showFilterSettings('edge_detect')">
                        <i class="fas fa-vector-square"></i> Kantenerkennung
                    </button>
                    <button class="btn btn-outline-success btn-sm" onclick="showFilterSettings('oil_painting')">
                        <i class="fas fa-paint-brush"></i> Ölgemälde
                    </button>
                    <button class="btn btn-outline-success btn-sm" onclick="showFilterSettings('pencil_sketch')">
                        <i class="fas fa-pencil-alt"></i> Bleistiftskizze
                    </button>
                    <button class="btn btn-outline-success btn-sm" onclick="showFilterSettings('vintage')">
                        <i class="fas fa-camera-retro"></i> Vintage
                    </button>
                </div>
            </div>
        </div>
        
        <div class="card mb-3">
            <div class="card-header">
                <h6 class="mb-0">
                    <i class="fas fa-industry"></i> Gravur-Tools
                </h6>
            </div>
            <div class="card-body">
                <div class="d-grid gap-2 mb-3">
                    <button class="btn btn-outline-warning btn-sm" onclick="showGravurSettings('remove_background')">
                        <i class="fas fa-eraser"></i> Hintergrund entfernen
                    </button>
                    <button class="btn btn-outline-warning btn-sm" onclick="showGravurSettings('prepare_engraving')">
                        <i class="fas fa-cog"></i> Gravur vorbereiten
                    </button>
                    <button class="btn btn-outline-warning btn-sm" onclick="showGravurSettings('vectorize')">
                        <i class="fas fa-bezier-curve"></i> Vektorisieren
                    </button>
                </div>
                
            </div>
        </div>
        
        <div class="card">
            <div class="card-header">
                <h6 class="mb-0">
                    <i class="fas fa-download"></i> Export
                </h6>
            </div>
            <div class="card-body">
                <div class="mb-2">
                    <label class="form-label small">Format</label>
                    <select class="form-select form-select-sm" id="export-format">
                        <option value="PNG">PNG (verlustfrei)</option>
                        <option value="JPEG">JPEG (komprimiert)</option>
                        <option value="WEBP">WebP (modern)</option>
                        <option value="TIFF">TIFF (professionell)</option>
                        <option value="PDF">PDF (dokument)</option>
                        <option value="SVG">SVG (vektor)</option>
                    </select>
                </div>
                
                <div class="mb-2">
                    <label class="form-label small">Qualität</label>
                    <select class="form-select form-select-sm" id="export-quality">
                        <option value="max">Maximum</option>
                        <option value="high" selected>Hoch</option>
                        <option value="medium">Mittel</option>
                        <option value="low">Niedrig</option>
                    </select>
                </div>
                
                <div class="d-grid gap-2">
                    <button class="btn btn-success btn-sm" onclick="exportImage()">
                        <i class="fas fa-download"></i> Exportieren
                    </button>
                    <button class="btn btn-outline-warning btn-sm" onclick="showShopifyExport()">
                        <i class="fab fa-shopify"></i> Zu Shopify
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Haupt-Arbeitsbereich -->
    <div class="col-md-6">
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h6 class="mb-0">
                    <i class="fas fa-image"></i> Live-Vorschau
                </h6>
                <div class="btn-group btn-group-sm">
                    <button class="btn btn-outline-secondary" onclick="resetToOriginal()">
                        <i class="fas fa-undo"></i> Zurücksetzen
                    </button>
                    <button class="btn btn-outline-secondary" onclick="refreshPreview()">
                        <i class="fas fa-sync"></i> Aktualisieren
                    </button>
                </div>
            </div>
            <div class="card-body text-center">
                <div id="image-container" class="position-relative">
                    <img id="preview-image" src="{{ project.original_image.url|default:'' }}" 
                         class="img-fluid border rounded" style="max-height: 500px;" alt="{{ project.name|default:'' }}">
                    
                    <!-- Loading Overlay -->
                    <div id="loading-overlay" class="position-absolute top-0 start-0 w-100 h-100 
                                bg-dark bg-opacity-25 d-flex align-items-center justify-content-center">
                        <div class="spinner-border text-light" role="status">
                            <span class="visually-hidden">Wird bearbeitet...</span>
                        </div>
                    </div>
                </div>
                
                <!-- Bildinfo -->
                <div class="mt-3">
                    <small class="text-muted" id="image-info">
                        {% if project.original_width and project.original_height %}
                            {{ project.original_width }} × {{ project.original_height }} Pixel
                        {% endif %}
                    </small>
                </div>
            </div>
        </div>
        
        <!-- Erweiterte Einstellungen Panel -->
        <div id="settings-panel" class="mt-3" style="display: none;">
            <!-- Filter Einstellungen -->
            <div id="filter-settings" style="display: none;">
                <div class="card border-success">
                    <div class="card-header bg-light">
                        <div class="d-flex justify-content-between align-items-center">
                            <h6 class="mb-0">
                                <i class="fas fa-sliders-h text-success"></i> 
                                <span id="filter-title">Filter-Einstellungen</span>
                            </h6>
                            <button type="button" class="btn-close btn-sm" onclick="hideSettings()"></button>
                        </div>
                    </div>
                    <div class="card-body">
                        <div id="filter-controls"></div>
                        <div class="d-flex gap-2 mt-3">
                            <button class="btn btn-success btn-sm" onclick="confirmFilterSettings()">
                                <i class="fas fa-check"></i> Übernehmen
                            </button>
                            <button class="btn btn-outline-warning btn-sm" onclick="resetFilterPreview()">
                                <i class="fas fa-undo"></i> Zurücksetzen
                            </button>
                            <button class="btn btn-outline-secondary btn-sm" onclick="hideSettings()">
                                <i class="fas fa-times"></i> Abbrechen
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Gravur-Tool Einstellungen -->
            <div id="gravur-settings" style="display: none;">
                <div class="card border-warning">
                    <div class="card-header bg-light">
                        <div class="d-flex justify-content-between align-items-center">
                            <h6 class="mb-0">
                                <i class="fas fa-cogs text-warning"></i> 
                                <span id="gravur-title">Gravur-Einstellungen</span>
                            </h6>
                            <button type="button" class="btn-close btn-sm" onclick="hideSettings()"></button>
                        </div>
                    </div>
                    <div class="card-body">
                        <div id="gravur-controls"></div>
                        <div class="d-flex gap-2 mt-3">
                            <button class="btn btn-warning btn-sm" onclick="confirmGravurSettings()">
                                <i class="fas fa-check"></i> Übernehmen
                            </button>
                            <button class="btn btn-outline-warning btn-sm" onclick="resetGravurPreview()">
                                <i class="fas fa-undo"></i> Zurücksetzen
                            </button>
                            <button class="btn btn-outline-secondary btn-sm" onclick="hideSettings()">
                                <i class="fas fa-times"></i> Abbrechen
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Status/Feedback -->
        <div id="status-messages" class="mt-3"></div>
    </div>
    
    <!-- Verarbeitungshistorie -->
    <div class="col-md-3">
        <div class="card">
            <div class="card-header">
                <h6 class="mb-0">
                    <i class="fas fa-history"></i> Verarbeitungsschritte
                </h6>
            </div>
            <div class="card-body">
                <div id="processing-history">
                    {% for step in processing_steps %}
                    <div class="border-bottom pb-2 mb-2">
                        <small class="fw-bold">{{ step.get_operation_display }}</small>
                        <div class="text-muted small">
                            {{ step.applied_at|date:"H:i:s" }}
                            {% if step.processing_time %}
                                ({{ step.processing_time|floatformat:2 }}s)
                            {% endif %}
                        </div>
                        {% if step.parameters %}
                        <div class="text-muted small">
                            {% for key, value in step.parameters.items %}
                                {{ key }}: {{ value }}{% if not forloop.last %}, {% endif %}
                            {% endfor %}
                        </div>
                        {% endif %}
                    </div>
                    {% empty %}
                    <small class="text-muted">Noch keine Bearbeitungsschritte</small>
                    {% endfor %}
                </div>
            </div>
        </div>
        
        <!-- Projekt-Info -->
        <div class="card mt-3">
            <div class="card-header">
                <h6 class="mb-0">
                    <i class="fas fa-info-circle"></i> Projekt-Info
                </h6>
            </div>
            <div class="card-body">
                <small class="text-muted">
                    <strong>Name:</strong> {{ project.name }}<br>
                    <strong>Quelle:</strong> {{ project.get_source_type_display }}<br>
                    <strong>Status:</strong> {{ project.get_status_display }}<br>
                    <strong>Erstellt:</strong> {{ project.created_at|date:"d.m.Y H:i" }}<br>
                    <strong>Bearbeitet:</strong> {{ project.updated_at|date:"d.m.Y H:i" }}<br>
                    {% if project.get_file_size %}
                    <strong>Dateigröße:</strong> {{ project.get_file_size|filesizeformat }}<br>
                    {% endif %}
                    <strong>Schritte:</strong> {{ project.get_processing_steps_count }}
                </small>
            </div>
        </div>
    </div>
</div>

<!-- Hidden data elements for safe JavaScript access -->
<script type="application/json" id="shopify-stores-data">{{ shopify_stores_json|default:"[]"|safe }}</script>

<script>
// Project ID handling
const projectId = {{ project.id|default:"null" }};
if (!projectId || projectId === null || isNaN(projectId)) {
    console.error('Project ID is not available or invalid');
    alert('Projekt-ID nicht verfügbar. Bitte laden Sie die Seite neu.');
}
let processingQueue = [];
let isProcessing = false;
let currentFilterType = null;
let currentGravurType = null;
let originalImageSrc = null;
let previewTimeout = null;
let isLivePreviewActive = false;

// Live-Vorschau aktualisieren
function refreshPreview() {
    if (!projectId) {
        console.error('Cannot refresh preview: Project ID is not available');
        return;
    }
    
    fetch(`/images/api/live-preview/${projectId}/`)
    .then(response => {
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json();
    })
    .then(data => {
        if (data.success) {
            const previewImage = document.getElementById('preview-image');
            if (previewImage && data.preview_base64) {
                previewImage.src = data.preview_base64;
            }
            
            // Bildinfo aktualisieren
            const imageInfo = document.getElementById('image-info');
            if (imageInfo && data.image_info) {
                const info = data.image_info;
                imageInfo.textContent = `${info.width} × ${info.height} Pixel • ${info.mode}`;
            }
        } else {
            console.error('Preview refresh failed:', data.error);
        }
    })
    .catch(error => {
        console.error('Fehler beim Laden der Vorschau:', error);
        showMessage('warning', 'Vorschau konnte nicht geladen werden. Bitte versuchen Sie es erneut.');
    });
}

// Basis-Operationen
function applyBasicOperation(operation) {
    if (!projectId) {
        showMessage('danger', 'Projekt-ID nicht verfügbar. Bitte laden Sie die Seite neu.');
        return;
    }
    
    const parameters = {};
    
    if (operation === 'brightness') {
        const sliderElement = document.getElementById('brightness-slider');
        parameters.factor = sliderElement ? parseFloat(sliderElement.value) : 1.0;
    } else if (operation === 'contrast') {
        const sliderElement = document.getElementById('contrast-slider');
        parameters.factor = sliderElement ? parseFloat(sliderElement.value) : 1.0;
    } else if (operation === 'saturation') {
        const sliderElement = document.getElementById('saturation-slider');
        parameters.factor = sliderElement ? parseFloat(sliderElement.value) : 1.0;
    }
    
    processImage(operation, parameters);
}

// Slider-Operationen
function applySliderOperation(operation, value) {
    const valueElement = document.getElementById(`${operation}-value`);
    if (valueElement) {
        valueElement.textContent = value;
    }
    applyBasicOperation(operation);
}

// Filter-Einstellungen anzeigen
function showFilterSettings(filterType) {
    hideSettings(); // Verstecke andere Settings zuerst
    
    // NACH hideSettings() die Variablen setzen
    currentFilterType = filterType;
    currentGravurType = null; // Reset Gravur-Typ
    
    // Original-Bild-Referenz speichern
    originalImageSrc = document.getElementById('preview-image').src;
    
    const panel = document.getElementById('settings-panel');
    const filterSettings = document.getElementById('filter-settings');
    const filterTitle = document.getElementById('filter-title');
    const filterControls = document.getElementById('filter-controls');
    
    // Titel setzen
    const filterNames = {
        'emboss': 'Prägen-Filter',
        'edge_detect': 'Kantenerkennung',
        'oil_painting': 'Ölgemälde-Filter',
        'pencil_sketch': 'Bleistiftskizze',
        'vintage': 'Vintage-Filter'
    };
    filterTitle.textContent = filterNames[filterType] || 'Filter-Einstellungen';
    
    // Controls erstellen
    filterControls.innerHTML = createFilterControls(filterType);
    
    // Panel anzeigen
    panel.style.display = 'block';
    filterSettings.style.display = 'block';
    
    // Live-Vorschau aktivieren
    isLivePreviewActive = true;
    
    // Event Listener für Slider hinzufügen (nach DOM-Update)
    setTimeout(() => {
        addFilterEventListeners(filterType);
        // Erste Vorschau mit Standard-Werten anwenden
        triggerLivePreview();
    }, 100);
    
    // Smooth scroll zum Panel
    panel.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
}

// Event Listener für Filter-Controls hinzufügen
function addFilterEventListeners(filterType) {
    switch(filterType) {
        case 'emboss':
            const embossStrength = document.getElementById('emboss-strength');
            const embossValue = document.getElementById('emboss-strength-value');
            if (embossStrength && embossValue) {
                embossStrength.addEventListener('input', function() {
                    embossValue.textContent = this.value;
                    triggerLivePreview();
                });
            }
            break;
            
        case 'edge_detect':
            const edgeMethod = document.getElementById('edge-method');
            const edgeLow = document.getElementById('edge-low');
            const edgeHigh = document.getElementById('edge-high');
            const edgeLowValue = document.getElementById('edge-low-value');
            const edgeHighValue = document.getElementById('edge-high-value');
            
            if (edgeMethod) {
                edgeMethod.addEventListener('change', triggerLivePreview);
            }
            if (edgeLow && edgeLowValue) {
                edgeLow.addEventListener('input', function() {
                    edgeLowValue.textContent = this.value;
                    triggerLivePreview();
                });
            }
            if (edgeHigh && edgeHighValue) {
                edgeHigh.addEventListener('input', function() {
                    edgeHighValue.textContent = this.value;
                    triggerLivePreview();
                });
            }
            break;
            
        case 'oil_painting':
            const oilSize = document.getElementById('oil-size');
            const oilLevels = document.getElementById('oil-levels');
            const oilSizeValue = document.getElementById('oil-size-value');
            const oilLevelsValue = document.getElementById('oil-levels-value');
            
            if (oilSize && oilSizeValue) {
                oilSize.addEventListener('input', function() {
                    oilSizeValue.textContent = this.value;
                    triggerLivePreview();
                });
            }
            if (oilLevels && oilLevelsValue) {
                oilLevels.addEventListener('input', function() {
                    oilLevelsValue.textContent = this.value;
                    triggerLivePreview();
                });
            }
            break;
            
        case 'pencil_sketch':
            const pencilLine = document.getElementById('pencil-line');
            const pencilBlur = document.getElementById('pencil-blur');
            const pencilLineValue = document.getElementById('pencil-line-value');
            const pencilBlurValue = document.getElementById('pencil-blur-value');
            
            if (pencilLine && pencilLineValue) {
                pencilLine.addEventListener('input', function() {
                    pencilLineValue.textContent = this.value;
                    triggerLivePreview();
                });
            }
            if (pencilBlur && pencilBlurValue) {
                pencilBlur.addEventListener('input', function() {
                    pencilBlurValue.textContent = this.value;
                    triggerLivePreview();
                });
            }
            break;
            
        case 'vintage':
            const vintageSepia = document.getElementById('vintage-sepia');
            const vintageVignette = document.getElementById('vintage-vignette');
            const vintageSepiaValue = document.getElementById('vintage-sepia-value');
            const vintageVignetteValue = document.getElementById('vintage-vignette-value');
            
            if (vintageSepia && vintageSepiaValue) {
                vintageSepia.addEventListener('input', function() {
                    vintageSepiaValue.textContent = this.value;
                    triggerLivePreview();
                });
            }
            if (vintageVignette && vintageVignetteValue) {
                vintageVignette.addEventListener('input', function() {
                    vintageVignetteValue.textContent = this.value;
                    triggerLivePreview();
                });
            }
            break;
    }
}

// Event Listener für Gravur-Controls hinzufügen
function addGravurEventListeners(toolType) {
    switch(toolType) {
        case 'remove_background':
            const bgModel = document.getElementById('bg-model');
            if (bgModel) {
                bgModel.addEventListener('change', triggerLivePreview);
            }
            break;
            
        case 'prepare_engraving':
            const engraveBeam = document.getElementById('engrave-beam');
            const engraveLine = document.getElementById('engrave-line');
            const engraveDepth = document.getElementById('engrave-depth');
            const engraveDepthValue = document.getElementById('engrave-depth-value');
            const engraveContrast = document.getElementById('engrave-contrast');
            const engraveContrastValue = document.getElementById('engrave-contrast-value');
            const ditherStrength = document.getElementById('dither-strength');
            const ditherStrengthValue = document.getElementById('dither-strength-value');
            const ditherAlgorithm = document.getElementById('dither-algorithm');
            const engraveModeInputs = document.querySelectorAll('input[name="engraveMode"]');
            
            if (engraveBeam) {
                engraveBeam.addEventListener('input', triggerLivePreview);
            }
            if (engraveLine) {
                engraveLine.addEventListener('input', triggerLivePreview);
            }
            if (engraveDepth && engraveDepthValue) {
                engraveDepth.addEventListener('input', function() {
                    engraveDepthValue.textContent = this.value;
                    triggerLivePreview();
                });
            }
            if (engraveContrast && engraveContrastValue) {
                engraveContrast.addEventListener('input', function() {
                    engraveContrastValue.textContent = this.value;
                    triggerLivePreview();
                });
            }
            if (ditherStrength && ditherStrengthValue) {
                ditherStrength.addEventListener('input', function() {
                    ditherStrengthValue.textContent = this.value;
                    triggerLivePreview();
                });
            }
            if (ditherAlgorithm) {
                ditherAlgorithm.addEventListener('change', triggerLivePreview);
            }
            // Add event listeners for radio buttons
            engraveModeInputs.forEach(input => {
                input.addEventListener('change', function() {
                    const ditheringSettings = document.getElementById('dithering-settings');
                    const grayscaleSettings = document.getElementById('grayscale-settings');
                    
                    if (this.value === 'dithering') {
                        if (ditheringSettings) ditheringSettings.style.display = 'block';
                        if (grayscaleSettings) grayscaleSettings.style.display = 'block';
                    } else if (this.value === 'grayscale') {
                        if (ditheringSettings) ditheringSettings.style.display = 'none';
                        if (grayscaleSettings) grayscaleSettings.style.display = 'block';
                    } else {
                        if (ditheringSettings) ditheringSettings.style.display = 'none';
                        if (grayscaleSettings) grayscaleSettings.style.display = 'none';
                    }
                    
                    triggerLivePreview();
                });
            });
            break;
            
        case 'vectorize':
            const vectorThreshold = document.getElementById('vector-threshold');
            const vectorSimplify = document.getElementById('vector-simplify');
            const vectorEnhance = document.getElementById('vector-enhance');
            const vectorLineWidth = document.getElementById('vector-line-width');
            const vectorThresholdValue = document.getElementById('vector-threshold-value');
            const vectorSimplifyValue = document.getElementById('vector-simplify-value');
            const vectorLineWidthValue = document.getElementById('vector-line-width-value');
            
            if (vectorThreshold && vectorThresholdValue) {
                vectorThreshold.addEventListener('input', function() {
                    vectorThresholdValue.textContent = this.value;
                    triggerLivePreview();
                });
            }
            if (vectorSimplify && vectorSimplifyValue) {
                vectorSimplify.addEventListener('input', function() {
                    vectorSimplifyValue.textContent = this.value;
                    triggerLivePreview();
                });
            }
            if (vectorEnhance) {
                vectorEnhance.addEventListener('change', triggerLivePreview);
            }
            if (vectorLineWidth && vectorLineWidthValue) {
                vectorLineWidth.addEventListener('input', function() {
                    vectorLineWidthValue.textContent = this.value;
                    triggerLivePreview();
                });
            }
            break;
    }
}

// Gravur-Einstellungen anzeigen  
function showGravurSettings(toolType) {
    console.log('showGravurSettings called with toolType:', toolType);
    
    hideSettings(); // Verstecke andere Settings zuerst
    
    // NACH hideSettings() die Variablen setzen
    currentGravurType = toolType;
    currentFilterType = null; // Reset Filter-Typ
    
    console.log('currentGravurType set to:', currentGravurType);
    console.log('currentFilterType reset to:', currentFilterType);
    
    // Original-Bild-Referenz speichern
    originalImageSrc = document.getElementById('preview-image').src;
    console.log('originalImageSrc saved:', originalImageSrc);
    
    const panel = document.getElementById('settings-panel');
    const gravurSettings = document.getElementById('gravur-settings');
    const gravurTitle = document.getElementById('gravur-title');
    const gravurControls = document.getElementById('gravur-controls');
    
    console.log('DOM elements found:', {
        panel: !!panel,
        gravurSettings: !!gravurSettings,
        gravurTitle: !!gravurTitle,
        gravurControls: !!gravurControls
    });
    
    // Titel setzen
    const toolNames = {
        'remove_background': 'Hintergrund entfernen',
        'prepare_engraving': 'Gravur vorbereiten',
        'vectorize': 'Vektorisierung'
    };
    gravurTitle.textContent = toolNames[toolType] || 'Gravur-Einstellungen';
    console.log('Title set to:', gravurTitle.textContent);
    
    // Controls erstellen
    const controlsHtml = createGravurControls(toolType);
    console.log('Controls HTML created:', controlsHtml);
    gravurControls.innerHTML = controlsHtml;
    
    // Panel anzeigen
    panel.style.display = 'block';
    gravurSettings.style.display = 'block';
    console.log('Panel and gravur settings shown');
    
    // Live-Vorschau aktivieren
    isLivePreviewActive = true;
    console.log('Live preview activated:', isLivePreviewActive);
    
    // Event Listener für Gravur-Controls hinzufügen (nach DOM-Update)
    setTimeout(() => {
        console.log('Adding gravur event listeners for:', toolType);
        addGravurEventListeners(toolType);
        console.log('About to trigger live preview with currentGravurType:', currentGravurType);
        // Erste Vorschau mit Standard-Werten anwenden
        triggerLivePreview();
    }, 100);
    
    // Smooth scroll zum Panel
    panel.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
}

// Settings verstecken
function hideSettings() {
    const panel = document.getElementById('settings-panel');
    const filterSettings = document.getElementById('filter-settings');
    const gravurSettings = document.getElementById('gravur-settings');
    
    // Live-Vorschau deaktivieren
    isLivePreviewActive = false;
    
    // Timeout löschen
    clearTimeout(previewTimeout);
    
    // Reset auf Original-Bild falls nicht bestätigt
    if (originalImageSrc) {
        document.getElementById('preview-image').src = originalImageSrc;
    }
    
    panel.style.display = 'none';
    filterSettings.style.display = 'none';
    gravurSettings.style.display = 'none';
    
    // Reset Variablen
    currentFilterType = null;
    currentGravurType = null;
}

// Filter-Controls erstellen
function createFilterControls(filterType) {
    switch(filterType) {
        case 'emboss':
            return `
                <div class="mb-3">
                    <label class="form-label">Stärke</label>
                    <input type="range" class="form-range" id="emboss-strength" 
                           min="0.1" max="3.0" step="0.1" value="1.0">
                    <div class="d-flex justify-content-between">
                        <small class="text-muted">Schwach</small>
                        <small class="text-muted">Stark</small>
                    </div>
                    <div class="text-center mt-1">
                        <small class="fw-bold">Wert: <span id="emboss-strength-value">1.0</span></small>
                    </div>
                </div>
            `;
        
        case 'edge_detect':
            return `
                <div class="mb-3">
                    <label class="form-label">Methode</label>
                    <select class="form-select" id="edge-method">
                        <option value="canny">Canny (Empfohlen)</option>
                        <option value="sobel">Sobel</option>
                    </select>
                </div>
                <div class="mb-3">
                    <label class="form-label">Untere Schwelle</label>
                    <input type="range" class="form-range" id="edge-low" 
                           min="10" max="200" step="5" value="50">
                    <div class="text-center mt-1">
                        <small class="fw-bold">Wert: <span id="edge-low-value">50</span></small>
                    </div>
                </div>
                <div class="mb-3">
                    <label class="form-label">Obere Schwelle</label>
                    <input type="range" class="form-range" id="edge-high" 
                           min="50" max="300" step="5" value="150">
                    <div class="text-center mt-1">
                        <small class="fw-bold">Wert: <span id="edge-high-value">150</span></small>
                    </div>
                </div>
            `;
        
        case 'oil_painting':
            return `
                <div class="mb-3">
                    <label class="form-label">Pinselgröße</label>
                    <input type="range" class="form-range" id="oil-size" 
                           min="3" max="15" step="2" value="7">
                    <div class="d-flex justify-content-between">
                        <small class="text-muted">Klein</small>
                        <small class="text-muted">Groß</small>
                    </div>
                    <div class="text-center mt-1">
                        <small class="fw-bold">Wert: <span id="oil-size-value">7</span></small>
                    </div>
                </div>
                <div class="mb-3">
                    <label class="form-label">Farbstufen</label>
                    <input type="range" class="form-range" id="oil-levels" 
                           min="4" max="16" step="1" value="8">
                    <div class="d-flex justify-content-between">
                        <small class="text-muted">Wenig</small>
                        <small class="text-muted">Viel</small>
                    </div>
                    <div class="text-center mt-1">
                        <small class="fw-bold">Wert: <span id="oil-levels-value">8</span></small>
                    </div>
                </div>
            `;
        
        case 'pencil_sketch':
            return `
                <div class="mb-3">
                    <label class="form-label">Linienstärke</label>
                    <input type="range" class="form-range" id="pencil-line" 
                           min="3" max="15" step="2" value="7">
                    <div class="d-flex justify-content-between">
                        <small class="text-muted">Fein</small>
                        <small class="text-muted">Dick</small>
                    </div>
                    <div class="text-center mt-1">
                        <small class="fw-bold">Wert: <span id="pencil-line-value">7</span></small>
                    </div>
                </div>
                <div class="mb-3">
                    <label class="form-label">Weichzeichnung</label>
                    <input type="range" class="form-range" id="pencil-blur" 
                           min="3" max="21" step="2" value="7">
                    <div class="d-flex justify-content-between">
                        <small class="text-muted">Scharf</small>
                        <small class="text-muted">Weich</small>
                    </div>
                    <div class="text-center mt-1">
                        <small class="fw-bold">Wert: <span id="pencil-blur-value">7</span></small>
                    </div>
                </div>
            `;
        
        case 'vintage':
            return `
                <div class="mb-3">
                    <label class="form-label">Sepia-Stärke</label>
                    <input type="range" class="form-range" id="vintage-sepia" 
                           min="0" max="1" step="0.1" value="0.8">
                    <div class="d-flex justify-content-between">
                        <small class="text-muted">Kein Sepia</small>
                        <small class="text-muted">Vollständig</small>
                    </div>
                    <div class="text-center mt-1">
                        <small class="fw-bold">Wert: <span id="vintage-sepia-value">0.8</span></small>
                    </div>
                </div>
                <div class="mb-3">
                    <label class="form-label">Vignette-Stärke</label>
                    <input type="range" class="form-range" id="vintage-vignette" 
                           min="0" max="0.8" step="0.1" value="0.3">
                    <div class="d-flex justify-content-between">
                        <small class="text-muted">Keine</small>
                        <small class="text-muted">Stark</small>
                    </div>
                    <div class="text-center mt-1">
                        <small class="fw-bold">Wert: <span id="vintage-vignette-value">0.3</span></small>
                    </div>
                </div>
            `;
        
        default:
            return '<p class="text-muted">Keine erweiterten Einstellungen verfügbar.</p>';
    }
}

// Gravur-Controls erstellen
function createGravurControls(toolType) {
    switch(toolType) {
        case 'remove_background':
            return `
                <div class="mb-3">
                    <label class="form-label">AI-Modell</label>
                    <select class="form-select" id="bg-model">
                        <option value="u2net">U2-Net (Universell)</option>
                        <option value="silueta">Silueta (Personen)</option>
                        <option value="isnet-general-use">ISNet (Hochqualität)</option>
                    </select>
                    <div class="form-text">
                        U2-Net für allgemeine Objekte, Silueta für Personen, ISNet für höchste Qualität
                    </div>
                </div>
            `;
        
        case 'prepare_engraving':
            return `
                <!-- Gravur-Modus -->
                <div class="mb-3">
                    <label class="form-label">Gravur-Modus</label>
                    <div class="btn-group w-100" role="group">
                        <input type="radio" class="btn-check" name="engraveMode" id="engrave-mode-grayscale" value="grayscale" checked>
                        <label class="btn btn-outline-primary btn-sm" for="engrave-mode-grayscale">
                            <i class="fas fa-palette"></i> Graustufen
                        </label>
                        
                        <input type="radio" class="btn-check" name="engraveMode" id="engrave-mode-bw" value="black_white">
                        <label class="btn btn-outline-primary btn-sm" for="engrave-mode-bw">
                            <i class="fas fa-adjust"></i> Schwarz/Weiß
                        </label>
                        
                        <input type="radio" class="btn-check" name="engraveMode" id="engrave-mode-dither" value="dithering">
                        <label class="btn btn-outline-primary btn-sm" for="engrave-mode-dither">
                            <i class="fas fa-th"></i> Dithering
                        </label>
                    </div>
                </div>
                
                <!-- Dithering-Einstellungen (nur bei Dithering-Modus sichtbar) -->
                <div id="dithering-settings" style="display: none;">
                    <div class="mb-3">
                        <label class="form-label">Dithering-Algorithmus</label>
                        <select class="form-select form-select-sm" id="dither-algorithm">
                            <option value="floyd_steinberg">Floyd-Steinberg (Empfohlen)</option>
                            <option value="ordered">Ordered Dithering</option>
                            <option value="random">Random Dithering</option>
                            <option value="sierra">Sierra</option>
                        </select>
                    </div>
                    <div class="mb-3">
                        <label class="form-label">Dithering-Stärke</label>
                        <input type="range" class="form-range" id="dither-strength" 
                               min="0.1" max="2.0" step="0.1" value="1.0">
                        <div class="d-flex justify-content-between">
                            <small class="text-muted">Schwach</small>
                            <small class="text-muted">Stark</small>
                        </div>
                        <div class="text-center mt-1">
                            <small class="fw-bold">Stärke: <span id="dither-strength-value">1.0</span></small>
                        </div>
                    </div>
                </div>
                
                <!-- Graustufen-Einstellungen -->
                <div id="grayscale-settings">
                    <div class="mb-3">
                        <label class="form-label">Graustufen-Tiefe</label>
                        <input type="range" class="form-range" id="engrave-depth" 
                               min="4" max="32" step="1" value="8">
                        <div class="d-flex justify-content-between">
                            <small class="text-muted">4 Stufen</small>
                            <small class="text-muted">32 Stufen</small>
                        </div>
                        <div class="text-center mt-1">
                            <small class="fw-bold">Stufen: <span id="engrave-depth-value">8</span></small>
                        </div>
                    </div>
                    <div class="mb-3">
                        <label class="form-label">Kontrast-Anpassung</label>
                        <input type="range" class="form-range" id="engrave-contrast" 
                               min="0.5" max="2.0" step="0.1" value="1.2">
                        <div class="d-flex justify-content-between">
                            <small class="text-muted">Weich</small>
                            <small class="text-muted">Hart</small>
                        </div>
                        <div class="text-center mt-1">
                            <small class="fw-bold">Kontrast: <span id="engrave-contrast-value">1.2</span></small>
                        </div>
                    </div>
                </div>
                
                <!-- Laser-Parameter -->
                <div class="mb-3">
                    <label class="form-label">Laserstrahl-Breite (mm)</label>
                    <input type="number" class="form-control form-control-sm" id="engrave-beam" 
                           min="0.05" max="0.5" step="0.01" value="0.1">
                    <div class="form-text">Typisch: 0.1mm für Präzision, 0.2mm für Geschwindigkeit</div>
                </div>
                <div class="mb-3">
                    <label class="form-label">Mindest-Linienstärke (mm)</label>
                    <input type="number" class="form-control form-control-sm" id="engrave-line" 
                           min="0.05" max="1.0" step="0.01" value="0.1">
                    <div class="form-text">Dünne Linien werden auf diese Mindestbreite verstärkt</div>
                </div>
            `;
        
        case 'vectorize':
            return `
                <div class="mb-3">
                    <label class="form-label">Schwarz/Weiß-Schwelle</label>
                    <input type="range" class="form-range" id="vector-threshold" 
                           min="50" max="200" step="5" value="128">
                    <div class="d-flex justify-content-between">
                        <small class="text-muted">Mehr Schwarz</small>
                        <small class="text-muted">Mehr Weiß</small>
                    </div>
                    <div class="text-center mt-1">
                        <small class="fw-bold">Wert: <span id="vector-threshold-value">128</span></small>
                    </div>
                </div>
                <div class="mb-3">
                    <label class="form-label">Vereinfachung</label>
                    <input type="range" class="form-range" id="vector-simplify" 
                           min="0.5" max="5.0" step="0.1" value="1.0">
                    <div class="d-flex justify-content-between">
                        <small class="text-muted">Detailliert</small>
                        <small class="text-muted">Vereinfacht</small>
                    </div>
                    <div class="text-center mt-1">
                        <small class="fw-bold">Wert: <span id="vector-simplify-value">1.0</span></small>
                    </div>
                </div>
                <div class="form-check mb-3">
                    <input class="form-check-input" type="checkbox" id="vector-enhance" checked>
                    <label class="form-check-label" for="vector-enhance">
                        Linien vor Vektorisierung verstärken
                    </label>
                    <div class="form-text">Empfohlen für bessere Vektorkurven</div>
                </div>
                <div class="mb-3" id="enhance-options">
                    <label class="form-label">Linienverstärkung</label>
                    <input type="range" class="form-range" id="vector-line-width" 
                           min="1" max="5" step="1" value="2">
                    <div class="text-center mt-1">
                        <small class="fw-bold">Breite: <span id="vector-line-width-value">2</span></small>
                    </div>
                </div>
            `;
        
        default:
            return '<p class="text-muted">Keine erweiterten Einstellungen verfügbar.</p>';
    }
}

// Erweiterte Filter
function applyAdvancedFilter(filterType) {
    showLoadingWithTimeout();
    
    fetch('/images/api/advanced-filter/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify({
            project_id: projectId,
            filter_type: filterType,
            parameters: {}
        })
    })
    .then(response => response.json())
    .then(data => {
        hideLoadingAndClearTimeout();
        if (data.success) {
            showMessage('success', data.message);
            if (data.preview_base64) {
                document.getElementById('preview-image').src = data.preview_base64;
            }
            addToHistory(filterType, {});
            // refreshPreview(); // Entfernt, da wir bereits das Bild aktualisiert haben
        } else {
            showMessage('danger', data.error);
        }
    })
    .catch(error => {
        hideLoadingAndClearTimeout();
        showMessage('danger', 'Fehler bei der Verarbeitung: ' + error);
    });
}

// Hintergrund entfernen
function removeBackground() {
    showLoadingWithTimeout();
    
    fetch('/images/api/remove-background/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify({
            project_id: projectId,
            model: 'u2net'
        })
    })
    .then(response => response.json())
    .then(data => {
        hideLoadingAndClearTimeout();
        if (data.success) {
            showMessage('success', data.message);
            if (data.preview_base64) {
                document.getElementById('preview-image').src = data.preview_base64;
            }
            addToHistory('remove_background', {model: 'u2net'});
        } else {
            showMessage('danger', data.error);
        }
    })
    .catch(error => {
        hideLoadingAndClearTimeout();
        showMessage('danger', 'Fehler bei Hintergrundentfernung: ' + error);
    });
}

// Gravur vorbereiten
function prepareEngraving() {
    const beamWidth = parseFloat(document.getElementById('beam-width').value);
    const lineThickness = parseFloat(document.getElementById('line-thickness').value);
    const depthLevels = parseInt(document.getElementById('depth-levels').value);
    
    showLoadingWithTimeout();
    
    fetch('/images/api/prepare-engraving/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify({
            project_id: projectId,
            beam_width: beamWidth,
            line_thickness: lineThickness,
            depth_levels: depthLevels
        })
    })
    .then(response => response.json())
    .then(data => {
        hideLoadingAndClearTimeout();
        if (data.success) {
            showMessage('success', data.message);
            if (data.preview_base64) {
                document.getElementById('preview-image').src = data.preview_base64;
            }
            addToHistory('prepare_engraving', {
                beam_width: beamWidth,
                line_thickness: lineThickness,
                depth_levels: depthLevels
            });
        } else {
            showMessage('danger', data.error);
        }
    })
    .catch(error => {
        hideLoadingAndClearTimeout();
        showMessage('danger', 'Fehler bei Gravur-Vorbereitung: ' + error);
    });
}

// Vektorisierung
function vectorizeImage() {
    showLoadingWithTimeout();
    
    fetch('/images/api/vectorize/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify({
            project_id: projectId,
            threshold: 128,
            simplify_tolerance: 1.0,
            enhance_lines: true,
            line_width: 2
        })
    })
    .then(response => response.json())
    .then(data => {
        hideLoadingAndClearTimeout();
        if (data.success) {
            showMessage('success', data.message);
            if (data.svg_content) {
                // SVG in neuem Fenster anzeigen
                const newWindow = window.open('', '_blank');
                newWindow.document.write(data.svg_content);
                newWindow.document.title = 'Vektorisiert: ' + ('{{ project.name|default:"Unbekannt"|escapejs }}');
            }
            addToHistory('vectorize', {threshold: 128, simplify_tolerance: 1.0});
        } else {
            showMessage('danger', data.error);
        }
    })
    .catch(error => {
        hideLoadingAndClearTimeout();
        showMessage('danger', 'Fehler bei Vektorisierung: ' + error);
    });
}

// Export
function exportImage() {
    const format = document.getElementById('export-format').value;
    const quality = document.getElementById('export-quality').value;
    
    showLoadingWithTimeout();
    
    fetch('/images/api/export/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify({
            project_id: projectId,
            format: format,
            quality: quality,
            dpi: 300
        })
    })
    .then(response => response.json())
    .then(data => {
        hideLoadingAndClearTimeout();
        if (data.success) {
            showMessage('success', data.message);
            
            // Download starten
            const downloadLink = document.createElement('a');
            downloadLink.href = data.download_url;
            downloadLink.download = `${'{{ project.name|default:"export"|escapejs }}'}_export.${format.toLowerCase()}`;
            downloadLink.click();
        } else {
            showMessage('danger', data.error);
        }
    })
    .catch(error => {
        hideLoadingAndClearTimeout();
        showMessage('danger', 'Fehler beim Export: ' + error);
    });
}

// Bild-Verarbeitung
function processImage(operation, parameters) {
    if (!projectId) {
        showMessage('danger', 'Projekt-ID nicht verfügbar. Bitte laden Sie die Seite neu.');
        return;
    }
    
    showLoadingWithTimeout();
    
    fetch('/images/api/process-image/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify({
            project_id: projectId,
            operation: operation,
            parameters: parameters
        })
    })
    .then(response => {
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json();
    })
    .then(data => {
        hideLoadingAndClearTimeout();
        if (data.success) {
            showMessage('success', data.message);
            if (data.preview_base64) {
                const previewImage = document.getElementById('preview-image');
                if (previewImage) {
                    previewImage.src = data.preview_base64;
                }
            } else {
                refreshPreview();
            }
            addToHistory(operation, parameters);
        } else {
            showMessage('danger', data.error || 'Unbekannter Fehler bei der Verarbeitung');
        }
    })
    .catch(error => {
        hideLoadingAndClearTimeout();
        console.error('Processing error:', error);
        showMessage('danger', 'Fehler bei der Verarbeitung: ' + error.message);
    });
}

// Auf Original zurücksetzen
function resetToOriginal() {
    if (confirm('Alle Bearbeitungen zurücksetzen und zum Original zurückkehren?')) {
        const originalImageUrl = '{{ project.original_image.url|default:""|escapejs }}';
        if (originalImageUrl) {
            document.getElementById('preview-image').src = originalImageUrl;
        }
        
        // Slider zurücksetzen
        document.getElementById('brightness-slider').value = 1.0;
        document.getElementById('contrast-slider').value = 1.0;
        document.getElementById('saturation-slider').value = 1.0;
        document.getElementById('brightness-value').textContent = '1.0';
        document.getElementById('contrast-value').textContent = '1.0';
        document.getElementById('saturation-value').textContent = '1.0';
        
        showMessage('info', 'Auf ursprüngliches Bild zurückgesetzt');
    }
}

// UI-Hilfsfunktionen
function showLoading() {
    const overlay = document.getElementById('loading-overlay');
    if (overlay) {
        overlay.classList.add('show');
        console.log('Loading angezeigt');
    }
}

function hideLoading() {
    const overlay = document.getElementById('loading-overlay');
    if (overlay) {
        overlay.classList.remove('show');
        console.log('Loading versteckt');
    }
}

// Sicherheitsfunktion: Loading nach 30 Sekunden automatisch verstecken
let loadingTimeout;
function showLoadingWithTimeout() {
    showLoading();
    clearTimeout(loadingTimeout);
    loadingTimeout = setTimeout(() => {
        hideLoading();
        showMessage('warning', 'Verarbeitung dauert länger als erwartet. Bitte versuchen Sie es erneut.');
    }, 30000);
}

function hideLoadingAndClearTimeout() {
    hideLoading();
    clearTimeout(loadingTimeout);
}

function showMessage(type, message) {
    const messageDiv = document.createElement('div');
    messageDiv.className = `alert alert-${type} alert-dismissible fade show`;
    messageDiv.innerHTML = `
        ${message}
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
    `;
    
    const container = document.getElementById('status-messages');
    container.appendChild(messageDiv);
    
    // Automatisch entfernen nach 5 Sekunden
    setTimeout(() => {
        if (messageDiv.parentNode) {
            messageDiv.remove();
        }
    }, 5000);
}

function addToHistory(operation, parameters) {
    const historyContainer = document.getElementById('processing-history');
    
    const historyItem = document.createElement('div');
    historyItem.className = 'border-bottom pb-2 mb-2';
    historyItem.innerHTML = `
        <small class="fw-bold">${operation}</small>
        <div class="text-muted small">
            ${new Date().toLocaleTimeString()}
        </div>
        <div class="text-muted small">
            ${Object.entries(parameters).map(([k, v]) => `${k}: ${v}`).join(', ')}
        </div>
    `;
    
    historyContainer.prepend(historyItem);
}

function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}


// Filter-Parameter extrahieren
function getFilterParameters(filterType) {
    switch(filterType) {
        case 'emboss':
            const embossStrength = document.getElementById('emboss-strength');
            return {
                strength: embossStrength ? parseFloat(embossStrength.value) : 1.0
            };
        
        case 'edge_detect':
            const edgeMethod = document.getElementById('edge-method');
            const edgeLow = document.getElementById('edge-low');
            const edgeHigh = document.getElementById('edge-high');
            return {
                method: edgeMethod ? edgeMethod.value : 'canny',
                low_threshold: edgeLow ? parseInt(edgeLow.value) : 50,
                high_threshold: edgeHigh ? parseInt(edgeHigh.value) : 150
            };
        
        case 'oil_painting':
            const oilSize = document.getElementById('oil-size');
            const oilLevels = document.getElementById('oil-levels');
            return {
                size: oilSize ? parseInt(oilSize.value) : 7,
                levels: oilLevels ? parseInt(oilLevels.value) : 8
            };
        
        case 'pencil_sketch':
            const pencilLine = document.getElementById('pencil-line');
            const pencilBlur = document.getElementById('pencil-blur');
            return {
                line_size: pencilLine ? parseInt(pencilLine.value) : 7,
                blur_value: pencilBlur ? parseInt(pencilBlur.value) : 7
            };
        
        case 'vintage':
            const vintageSepia = document.getElementById('vintage-sepia');
            const vintageVignette = document.getElementById('vintage-vignette');
            return {
                sepia_strength: vintageSepia ? parseFloat(vintageSepia.value) : 0.8,
                vignette_strength: vintageVignette ? parseFloat(vintageVignette.value) : 0.3
            };
        
        default:
            return {};
    }
}

// Gravur-Parameter extrahieren
function getGravurParameters(toolType) {
    switch(toolType) {
        case 'remove_background':
            const bgModel = document.getElementById('bg-model');
            return {
                model: bgModel ? bgModel.value : 'u2net'
            };
        
        case 'prepare_engraving':
            const engraveBeam = document.getElementById('engrave-beam');
            const engraveLine = document.getElementById('engrave-line');
            const engraveDepth = document.getElementById('engrave-depth');
            const engraveContrast = document.getElementById('engrave-contrast');
            const ditherStrength = document.getElementById('dither-strength');
            const ditherAlgorithm = document.getElementById('dither-algorithm');
            const engraveMode = document.querySelector('input[name="engraveMode"]:checked');
            
            const engraveParameters = {
                beam_width: engraveBeam ? parseFloat(engraveBeam.value) : 0.1,
                line_thickness: engraveLine ? parseFloat(engraveLine.value) : 0.1,
                depth_levels: engraveDepth ? parseInt(engraveDepth.value) : 8,
                mode: engraveMode ? engraveMode.value : 'grayscale'
            };
            
            // Add contrast for grayscale and dithering modes
            if (engraveMode && (engraveMode.value === 'grayscale' || engraveMode.value === 'dithering')) {
                engraveParameters.contrast = engraveContrast ? parseFloat(engraveContrast.value) : 1.2;
            }
            
            // Add dithering parameters
            if (engraveMode && engraveMode.value === 'dithering') {
                engraveParameters.dither_algorithm = ditherAlgorithm ? ditherAlgorithm.value : 'floyd_steinberg';
                engraveParameters.dither_strength = ditherStrength ? parseFloat(ditherStrength.value) : 1.0;
            }
            
            return engraveParameters;
        
        case 'vectorize':
            const vectorThreshold = document.getElementById('vector-threshold');
            const vectorSimplify = document.getElementById('vector-simplify');
            const vectorEnhance = document.getElementById('vector-enhance');
            const vectorLineWidth = document.getElementById('vector-line-width');
            
            const vectorParameters = {
                threshold: vectorThreshold ? parseInt(vectorThreshold.value) : 128,
                simplify_tolerance: vectorSimplify ? parseFloat(vectorSimplify.value) : 1.0
            };
            
            // Prüfe ob Linienverstärkung aktiviert ist
            if (vectorEnhance && vectorEnhance.checked) {
                vectorParameters.enhance_lines = true;
                vectorParameters.line_width = vectorLineWidth ? parseInt(vectorLineWidth.value) : 2;
            } else {
                vectorParameters.enhance_lines = false;
            }
            
            return vectorParameters;
        
        default:
            return {};
    }
}

// Live-Vorschau für Filter/Gravur-Einstellungen
function triggerLivePreview() {
    // Debug-Ausgabe
    console.log('triggerLivePreview called', {
        isLivePreviewActive,
        currentFilterType,
        currentGravurType
    });
    
    // Debounce: Warte 300ms nach der letzten Änderung für schnellere Response
    clearTimeout(previewTimeout);
    previewTimeout = setTimeout(() => {
        if (isLivePreviewActive) {
            if (currentFilterType) {
                console.log('Applying filter preview:', currentFilterType);
                applyFilterPreview();
            } else if (currentGravurType) {
                console.log('Applying gravur preview:', currentGravurType);
                applyGravurPreview();
            }
        } else {
            console.log('Live preview not active');
        }
    }, 300);
}

// Filter-Vorschau anwenden (temporär)
function applyFilterPreview() {
    if (!currentFilterType || isProcessing) {
        console.log('applyFilterPreview blocked:', {currentFilterType, isProcessing});
        return;
    }
    
    if (!projectId) {
        console.error('Project ID not available for preview');
        return;
    }
    
    const parameters = getFilterParameters(currentFilterType);
    console.log('Filter preview parameters:', parameters);
    console.log('Project ID:', projectId);
    console.log('Filter type:', currentFilterType);
    
    // Zeige kurzen Loading-Indikator
    const previewImage = document.getElementById('preview-image');
    previewImage.style.opacity = '0.7';
    
    fetch('/images/api/preview-filter/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify({
            project_id: projectId,
            filter_type: currentFilterType,
            parameters: parameters,
            preview_only: true
        })
    })
    .then(response => {
        console.log('Preview response status:', response.status);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json();
    })
    .then(data => {
        console.log('Preview response data:', data);
        previewImage.style.opacity = '1';
        if (data.success && data.preview_base64) {
            previewImage.src = data.preview_base64;
            console.log('Preview image updated successfully');
        } else {
            console.error('Preview failed:', data.error);
        }
    })
    .catch(error => {
        previewImage.style.opacity = '1';
        console.error('Vorschau-Fehler:', error);
    });
}

// Gravur-Vorschau anwenden (temporär)
function applyGravurPreview() {
    if (!currentGravurType || isProcessing) {
        console.log('applyGravurPreview blocked:', {currentGravurType, isProcessing});
        return;
    }
    
    if (!projectId) {
        console.error('Project ID not available for gravur preview');
        return;
    }
    
    const parameters = getGravurParameters(currentGravurType);
    console.log('Gravur preview parameters:', parameters);
    console.log('Project ID:', projectId);
    console.log('Gravur type:', currentGravurType);
    
    // Zeige kurzen Loading-Indikator
    const previewImage = document.getElementById('preview-image');
    previewImage.style.opacity = '0.7';
    
    let endpoint;
    switch(currentGravurType) {
        case 'remove_background':
            endpoint = '/images/api/preview-remove-background/';
            break;
        case 'prepare_engraving':
            endpoint = '/images/api/preview-prepare-engraving/';
            break;
        case 'vectorize':
            endpoint = '/images/api/preview-vectorize/';
            break;
        default:
            console.error('Unknown gravur type:', currentGravurType);
            previewImage.style.opacity = '1';
            return;
    }
    
    console.log('Using endpoint:', endpoint);
    
    fetch(endpoint, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify(Object.assign({
            project_id: projectId,
            preview_only: true
        }, parameters))
    })
    .then(response => {
        console.log('Gravur preview response status:', response.status);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json();
    })
    .then(data => {
        console.log('Gravur preview response data:', data);
        previewImage.style.opacity = '1';
        if (data.success && data.preview_base64) {
            previewImage.src = data.preview_base64;
            console.log('Gravur preview image updated successfully');
        } else {
            console.error('Gravur preview failed:', data.error);
        }
    })
    .catch(error => {
        previewImage.style.opacity = '1';
        console.error('Gravur Vorschau-Fehler:', error);
    });
}

// Filter-Einstellungen bestätigen (dauerhaft speichern)
function confirmFilterSettings() {
    if (!currentFilterType) return;
    
    const parameters = getFilterParameters(currentFilterType);
    showLoadingWithTimeout();
    
    fetch('/images/api/advanced-filter/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify({
            project_id: projectId,
            filter_type: currentFilterType,
            parameters: parameters
        })
    })
    .then(response => response.json())
    .then(data => {
        hideLoadingAndClearTimeout();
        if (data.success) {
            showMessage('success', data.message);
            addToHistory(currentFilterType, parameters);
            hideSettings();
            // Bild im Frontend aktualisieren
            if (data.preview_base64) {
                document.getElementById('preview-image').src = data.preview_base64;
                originalImageSrc = data.preview_base64;
            }
        } else {
            showMessage('danger', data.error);
        }
    })
    .catch(error => {
        hideLoadingAndClearTimeout();
        showMessage('danger', 'Fehler bei der Verarbeitung: ' + error);
    });
}

// Gravur-Einstellungen bestätigen (dauerhaft speichern)
function confirmGravurSettings() {
    if (!currentGravurType) return;
    
    const parameters = getGravurParameters(currentGravurType);
    showLoadingWithTimeout();
    
    let endpoint;
    switch(currentGravurType) {
        case 'remove_background':
            endpoint = '/images/api/remove-background/';
            break;
        case 'prepare_engraving':
            endpoint = '/images/api/prepare-engraving/';
            break;
        case 'vectorize':
            endpoint = '/images/api/vectorize/';
            break;
        default:
            showMessage('danger', 'Unbekannter Gravur-Tool-Typ');
            hideLoadingAndClearTimeout();
            return;
    }
    
    fetch(endpoint, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify(Object.assign({project_id: projectId}, parameters))
    })
    .then(response => response.json())
    .then(data => {
        hideLoadingAndClearTimeout();
        if (data.success) {
            showMessage('success', data.message);
            // Bild im Frontend aktualisieren
            if (data.preview_base64) {
                document.getElementById('preview-image').src = data.preview_base64;
                originalImageSrc = data.preview_base64;
            }
            if (data.svg_content && currentGravurType === 'vectorize') {
                const newWindow = window.open('', '_blank');
                newWindow.document.write(data.svg_content);
                newWindow.document.title = 'Vektorisiert: ' + ('{{ project.name|default:"Unbekannt"|escapejs }}');
            }
            addToHistory(currentGravurType, parameters);
            hideSettings();
        } else {
            showMessage('danger', data.error);
        }
    })
    .catch(error => {
        hideLoadingAndClearTimeout();
        showMessage('danger', 'Fehler bei der Verarbeitung: ' + error);
    });
}

// Filter-Vorschau zurücksetzen
function resetFilterPreview() {
    if (originalImageSrc) {
        document.getElementById('preview-image').src = originalImageSrc;
    }
}

// Gravur-Vorschau zurücksetzen
function resetGravurPreview() {
    if (originalImageSrc) {
        document.getElementById('preview-image').src = originalImageSrc;
    }
}

// Event Listener für Live-Updates in den Settings hinzufügen
function addSettingsEventListeners() {
    // Event-Handler für alle Range-Inputs und Select-Inputs hinzufügen
    document.addEventListener('input', function(e) {
        if (e.target.type === 'range') {
            const valueSpan = document.getElementById(e.target.id + '-value');
            if (valueSpan) {
                valueSpan.textContent = e.target.value;
            }
            // Live-Vorschau triggern
            triggerLivePreview();
        }
        
        // Auch für Number-Inputs
        if (e.target.type === 'number') {
            triggerLivePreview();
        }
    });
    
    // Event-Handler für Select-Änderungen
    document.addEventListener('change', function(e) {
        if (e.target.tagName === 'SELECT') {
            triggerLivePreview();
        }
        
        // Spezielle Handler für Vektorisierungs-Enhance Checkbox
        if (e.target.id === 'vector-enhance') {
            const enhanceOptions = document.getElementById('enhance-options');
            if (enhanceOptions) {
                enhanceOptions.style.display = e.target.checked ? 'block' : 'none';
            }
            triggerLivePreview();
        }
        
        // Für alle anderen Checkboxes
        if (e.target.type === 'checkbox') {
            triggerLivePreview();
        }
    });
}

// Initial preview laden
document.addEventListener('DOMContentLoaded', function() {
    // Forciere das Verstecken des Loading-Spinners beim Start
    const overlay = document.getElementById('loading-overlay');
    if (overlay) {
        overlay.classList.remove('show');
        overlay.style.display = 'none';
    }
    
    // Event Listener für Settings hinzufügen
    addSettingsEventListeners();
    
    // Prüfe ob das Bild bereits geladen ist
    const previewImage = document.getElementById('preview-image');
    if (previewImage) {
        // Wenn das Bild bereits eine src hat, ist es geladen
        if (previewImage.src && previewImage.src !== window.location.href) {
            console.log('Image already loaded from template');
        } else {
            console.log('Loading image via API');
            // Initial Preview laden (ohne Loading-Spinner für das erste Laden)
            setTimeout(() => {
                refreshPreview();
            }, 100); // Kurze Verzögerung für bessere UX
        }
    }
});

// === Shopify Export Functions ===
function showShopifyExport() {
    try {
        const modal = new bootstrap.Modal(document.getElementById('shopifyExportModal'));
        loadShopifyStores();
        
        // Safely set the project name in the product title field
        const productTitleField = document.getElementById('productTitle');
        if (productTitleField) {
            // Get project name safely
            const projectNameElement = document.querySelector('h1 .h2');
            if (projectNameElement) {
                const fullText = projectNameElement.textContent;
                const projectName = fullText.replace('Bildeditor: ', '').trim();
                productTitleField.value = projectName;
            }
        }
        
        // Event listeners für Export Type radio buttons
        const exportTypeRadios = document.querySelectorAll('input[name="exportType"]');
        exportTypeRadios.forEach(radio => {
            radio.addEventListener('change', function() {
                const newProductFields = document.getElementById('newProductFields');
                const existingProductFields = document.getElementById('existingProductFields');
                
                if (this.value === 'new_product') {
                    if (newProductFields) newProductFields.style.display = 'block';
                    if (existingProductFields) existingProductFields.style.display = 'none';
                } else {
                    if (newProductFields) newProductFields.style.display = 'none';
                    if (existingProductFields) existingProductFields.style.display = 'block';
                }
            });
        });
        
        modal.show();
    } catch (error) {
        console.error('Error in showShopifyExport:', error);
        alert('Fehler beim Öffnen der Shopify-Export Einstellungen');
    }
}

function loadShopifyStores() {
    try {
        const storeSelect = document.getElementById('shopifyStoreSelect');
        if (!storeSelect) {
            console.error('Shopify store select element not found');
            return;
        }
        
        storeSelect.innerHTML = '<option value="">-- Store auswählen --</option>';
        
        // Safer template variable handling
        const storesJsonElement = document.getElementById('shopify-stores-data');
        let stores = [];
        
        if (storesJsonElement && storesJsonElement.textContent.trim()) {
            try {
                stores = JSON.parse(storesJsonElement.textContent);
            } catch (parseError) {
                console.error('Error parsing stores JSON:', parseError);
                stores = [];
            }
        }
        
        if (stores && stores.length > 0) {
            stores.forEach(store => {
                const option = document.createElement('option');
                option.value = store.id || '';
                option.textContent = `${store.name || 'Unnamed Store'} (${store.shop_domain || 'No Domain'})`;
                storeSelect.appendChild(option);
            });
        } else {
            const option = document.createElement('option');
            option.value = '';
            option.textContent = 'Keine Stores verfügbar - Erst in API-Einstellungen konfigurieren';
            storeSelect.appendChild(option);
        }
    } catch (error) {
        console.error('Error in loadShopifyStores:', error);
        const storeSelect = document.getElementById('shopifyStoreSelect');
        if (storeSelect) {
            const option = document.createElement('option');
            option.value = '';
            option.textContent = 'Fehler beim Laden der Stores';
            storeSelect.appendChild(option);
        }
    }
}

// Neue Suchfunktion für Shopify Produkte
function searchShopifyProducts() {
    const storeSelect = document.getElementById('shopifyStoreSelect');
    const searchInput = document.getElementById('productSearchInput');
    const storeId = storeSelect.value;
    const searchTerm = searchInput.value.trim();
    
    if (!storeId) {
        alert('Bitte wählen Sie zuerst einen Store aus.');
        return;
    }
    
    if (!searchTerm || searchTerm.length < 2) {
        alert('Bitte geben Sie mindestens 2 Zeichen für die Suche ein.');
        return;
    }
    
    const resultsList = document.getElementById('productResultsList');
    const resultsDiv = document.getElementById('productSearchResults');
    
    resultsList.innerHTML = '<div class="list-group-item">Suche läuft...</div>';
    resultsDiv.style.display = 'block';
    
    fetch('/images/api/shopify-products/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify({
            store_id: storeId,
            search: searchTerm,
            limit: 50
        })
    })
    .then(response => response.json())
    .then(data => {
        resultsList.innerHTML = '';
        
        if (data.success && data.products.length > 0) {
            data.products.forEach(product => {
                const item = document.createElement('div');
                item.className = 'list-group-item list-group-item-action';
                item.style.cursor = 'pointer';
                item.innerHTML = `
                    <div class="d-flex justify-content-between align-items-start">
                        <div>
                            <h6 class="mb-1">${product.title}</h6>
                            <p class="mb-1 text-muted small">${product.image_count} Bilder</p>
                        </div>
                        <small class="text-muted">ID: ${product.id}</small>
                    </div>
                `;
                item.onclick = () => selectProduct(product.id, product.title);
                resultsList.appendChild(item);
            });
        } else {
            resultsList.innerHTML = '<div class="list-group-item text-muted">Keine Produkte gefunden</div>';
        }
    })
    .catch(error => {
        console.error('Fehler bei der Produktsuche:', error);
        resultsList.innerHTML = '<div class="list-group-item text-danger">Fehler bei der Suche</div>';
    });
}

// Alle Produkte laden (ursprüngliche Funktion umbenannt)
function loadAllShopifyProducts() {
    const storeSelect = document.getElementById('shopifyStoreSelect');
    const storeId = storeSelect.value;
    
    if (!storeId) {
        alert('Bitte wählen Sie zuerst einen Store aus.');
        return;
    }
    
    const resultsList = document.getElementById('productResultsList');
    const resultsDiv = document.getElementById('productSearchResults');
    
    resultsList.innerHTML = '<div class="list-group-item">Lade alle Produkte...</div>';
    resultsDiv.style.display = 'block';
    
    fetch('/images/api/shopify-products/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify({
            store_id: storeId,
            limit: 100
        })
    })
    .then(response => response.json())
    .then(data => {
        resultsList.innerHTML = '';
        
        if (data.success && data.products.length > 0) {
            data.products.forEach(product => {
                const item = document.createElement('div');
                item.className = 'list-group-item list-group-item-action';
                item.style.cursor = 'pointer';
                item.innerHTML = `
                    <div class="d-flex justify-content-between align-items-start">
                        <div>
                            <h6 class="mb-1">${product.title}</h6>
                            <p class="mb-1 text-muted small">${product.image_count} Bilder</p>
                        </div>
                        <small class="text-muted">ID: ${product.id}</small>
                    </div>
                `;
                item.onclick = () => selectProduct(product.id, product.title);
                resultsList.appendChild(item);
            });
        } else {
            resultsList.innerHTML = '<div class="list-group-item text-muted">Keine Produkte gefunden</div>';
        }
    })
    .catch(error => {
        console.error('Error loading products:', error);
        resultsList.innerHTML = '<div class="list-group-item text-danger">Fehler beim Laden</div>';
    });
}

// Produkt auswählen
function selectProduct(productId, productTitle) {
    document.getElementById('selectedProductId').value = productId;
    document.getElementById('selectedProductName').textContent = productTitle;
    
    // Zeige die Auswahl-Info und verstecke die Suchergebnisse
    document.getElementById('selectedProductInfo').style.display = 'block';
    document.getElementById('productSearchResults').style.display = 'none';
    
    // Leere das Suchfeld
    document.getElementById('productSearchInput').value = '';
}

// Produktauswahl zurücksetzen
function clearSelectedProduct() {
    document.getElementById('selectedProductId').value = '';
    document.getElementById('selectedProductName').textContent = '';
    document.getElementById('selectedProductInfo').style.display = 'none';
    document.getElementById('productSearchResults').style.display = 'none';
}

// Enter-Taste für Suche aktivieren
document.addEventListener('DOMContentLoaded', function() {
    const searchInput = document.getElementById('productSearchInput');
    if (searchInput) {
        searchInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                searchShopifyProducts();
            }
        });
    }
});

function confirmShopifyExport() {
    const storeSelect = document.getElementById('shopifyStoreSelect');
    const exportType = document.querySelector('input[name="exportType"]:checked').value;
    const storeId = storeSelect.value;
    // Using the globally defined projectId from above
    
    if (!storeId) {
        alert('Bitte wählen Sie einen Store aus.');
        return;
    }
    
    let exportData = {
        store_id: storeId,
        project_id: projectId,
        export_type: exportType
    };
    
    if (exportType === 'new_product') {
        const productTitle = document.getElementById('productTitle').value;
        const productDescription = document.getElementById('productDescription').value;
        const altText = document.getElementById('altText').value;
        
        if (!productTitle.trim()) {
            alert('Bitte geben Sie einen Produktnamen ein.');
            return;
        }
        
        exportData.product_title = productTitle;
        exportData.product_description = productDescription;
        exportData.alt_text = altText;
    } else {
        const selectedProductId = document.getElementById('selectedProductId').value;
        const existingAltText = document.getElementById('existingAltText').value;
        
        if (!selectedProductId) {
            alert('Bitte suchen und wählen Sie ein Produkt aus.');
            return;
        }
        
        exportData.product_id = selectedProductId;
        exportData.alt_text = existingAltText;
    }
    
    // Modal schließen
    const modal = bootstrap.Modal.getInstance(document.getElementById('shopifyExportModal'));
    modal.hide();
    
    // Loading-Toast anzeigen
    const loadingToast = document.createElement('div');
    loadingToast.className = 'toast position-fixed top-0 end-0 m-3';
    loadingToast.innerHTML = `
        <div class="toast-body">
            <div class="d-flex align-items-center">
                <div class="spinner-border spinner-border-sm me-2" role="status"></div>
                <span>Export zu Shopify läuft...</span>
            </div>
        </div>
    `;
    document.body.appendChild(loadingToast);
    const toast = new bootstrap.Toast(loadingToast);
    toast.show();
    
    // Export API aufrufen
    fetch('/images/api/shopify-export-image/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify(exportData)
    })
    .then(response => response.json())
    .then(data => {
        toast.hide();
        loadingToast.remove();
        
        if (data.success) {
            // Erfolgs-Toast
            showMessage('success', data.message);
        } else {
            showMessage('danger', `Export fehlgeschlagen: ${data.error}`);
        }
    })
    .catch(error => {
        toast.hide();
        loadingToast.remove();
        showMessage('danger', 'Netzwerkfehler beim Export');
        console.error('Error:', error);
    });
}
</script>

<!-- Shopify Export Modal -->
<div class="modal fade" id="shopifyExportModal" tabindex="-1">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title"><i class="fab fa-shopify"></i> Zu Shopify exportieren</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <!-- Store Auswahl -->
                <div class="mb-3">
                    <label class="form-label">Shopify Store</label>
                    <select class="form-select" id="shopifyStoreSelect">
                        <option value="">Laden...</option>
                    </select>
                </div>
                
                <!-- Export Type -->
                <div class="mb-3">
                    <label class="form-label">Export-Typ</label>
                    <div class="row">
                        <div class="col-md-6">
                            <div class="form-check">
                                <input class="form-check-input" type="radio" name="exportType" id="newProduct" value="new_product" checked>
                                <label class="form-check-label" for="newProduct">
                                    <strong>Neues Produkt erstellen</strong>
                                </label>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="form-check">
                                <input class="form-check-input" type="radio" name="exportType" id="existingProduct" value="existing_product">
                                <label class="form-check-label" for="existingProduct">
                                    <strong>Zu bestehendem Produkt hinzufügen</strong>
                                </label>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Neues Produkt Felder -->
                <div id="newProductFields">
                    <div class="row">
                        <div class="col-md-6">
                            <div class="mb-3">
                                <label class="form-label">Produktname</label>
                                <input type="text" class="form-control" id="productTitle" value="">
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="mb-3">
                                <label class="form-label">Alt-Text</label>
                                <input type="text" class="form-control" id="altText" placeholder="Beschreibung des Bildes">
                            </div>
                        </div>
                    </div>
                    <div class="mb-3">
                        <label class="form-label">Produktbeschreibung</label>
                        <textarea class="form-control" id="productDescription" rows="3" 
                                  placeholder="Detaillierte Beschreibung des Produkts"></textarea>
                    </div>
                </div>
                
                <!-- Bestehendes Produkt Felder -->
                <div id="existingProductFields" style="display: none;">
                    <div class="mb-3">
                        <label class="form-label">Produkt suchen</label>
                        <div class="input-group">
                            <input type="text" class="form-control" id="productSearchInput" 
                                   placeholder="Produktname eingeben..." autocomplete="off">
                            <button type="button" class="btn btn-outline-primary" onclick="searchShopifyProducts()">
                                <i class="fas fa-search"></i> Suchen
                            </button>
                        </div>
                        <div class="form-text">
                            <button type="button" class="btn btn-sm btn-outline-secondary mt-2" onclick="loadAllShopifyProducts()">
                                <i class="fas fa-list"></i> Alle Produkte anzeigen
                            </button>
                        </div>
                    </div>
                    
                    <!-- Suchergebnisse -->
                    <div id="productSearchResults" style="display: none;">
                        <label class="form-label">Suchergebnisse</label>
                        <div class="list-group" id="productResultsList" style="max-height: 200px; overflow-y: auto;">
                            <!-- Wird dynamisch gefüllt -->
                        </div>
                    </div>
                    
                    <!-- Ausgewähltes Produkt -->
                    <div id="selectedProductInfo" style="display: none;">
                        <div class="alert alert-info d-flex justify-content-between align-items-center">
                            <div>
                                <strong>Ausgewähltes Produkt:</strong>
                                <span id="selectedProductName"></span>
                            </div>
                            <button type="button" class="btn btn-sm btn-outline-secondary" onclick="clearSelectedProduct()">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                    </div>
                    
                    <div class="mb-3">
                        <label class="form-label">Alt-Text</label>
                        <input type="text" class="form-control" id="existingAltText" placeholder="Beschreibung des Bildes">
                    </div>
                    
                    <!-- Hidden field für die ausgewählte Produkt-ID -->
                    <input type="hidden" id="selectedProductId" value="">
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Abbrechen</button>
                <button type="button" class="btn btn-warning" onclick="confirmShopifyExport()" id="shopifyExportBtn">
                    <i class="fab fa-shopify"></i> Zu Shopify exportieren
                </button>
            </div>
        </div>
    </div>
</div>

<style>
#image-container {
    min-height: 300px;
}

.form-range {
    cursor: pointer;
}

.btn-group-sm .btn {
    font-size: 0.75rem;
}

#loading-overlay {
    border-radius: 0.375rem;
    display: none !important; /* Standardmäßig versteckt */
}

#loading-overlay.show {
    display: flex !important; /* Nur anzeigen wenn explizit gewünscht */
}

.processing-step {
    transition: all 0.2s ease-in-out;
}

.processing-step:hover {
    background-color: rgba(0, 0, 0, 0.05);
}

/* Live-Vorschau Effekte */
#preview-image {
    transition: opacity 0.3s ease-in-out;
}

#settings-panel {
    animation: slideInUp 0.3s ease-out;
}

@keyframes slideInUp {
    from {
        opacity: 0;
        transform: translateY(20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.form-range:hover {
    cursor: grab;
}

.form-range:active {
    cursor: grabbing;
}

/* Subtile Hervorhebung bei Parametern */
.form-range:focus {
    box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
}

.form-control:focus, .form-select:focus {
    border-color: #86b7fe;
    box-shadow: 0 0 0 0.2rem rgba(13, 110, 253, 0.25);
}
</style>


{% endblock %}