{% extends 'base.html' %}
{% load static %}

{% block title %}Beleuchtungsrechner{% endblock %}

{% block extra_head %}
<!-- PDF-Bibliotheken werden dynamisch geladen -->
{% endblock %}

{% block content %}
<div class="container-fluid py-4">
    <div class="row mb-4">
        <div class="col-12">
            <h1 class="h3 text-primary">
                <i class="bi bi-lightbulb text-warning me-2"></i>
                Beleuchtungsrechner
            </h1>
            <p class="text-muted">Berechnen Sie die optimale Anzahl von Leuchten für Ihre Räume</p>
        </div>
    </div>

    <div class="row">
        <!-- Eingabe-Bereich -->
        <div class="col-lg-6 mb-4">
            <div class="card shadow-sm h-100">
                <div class="card-header bg-primary text-white">
                    <h5 class="mb-0">Eingabe-Parameter</h5>
                </div>
                <div class="card-body">
                    <!-- Leuchten-Sektion -->
                    <div class="mb-4">
                        <h6 class="text-primary border-bottom pb-2">A: Leuchte</h6>
                        <div class="row mb-3">
                            <div class="col-4">
                                <input type="text" class="form-control form-control-sm" id="lampName" placeholder="Leuchtenname">
                            </div>
                            <div class="col-4">
                                <select class="form-select form-select-sm" id="lampType">
                                    <option value="">Typ wählen...</option>
                                    <option value="Feuchtraumleuchte IP65">Feuchtraumleuchte IP65</option>
                                    <option value="Feuchtraumleuchte VARIO">Feuchtraumleuchte VARIO</option>
                                    <option value="Feuchtraumleuchte Hochleistung">Feuchtraumleuchte Hochleistung</option>
                                    <option value="Panel">Panel</option>
                                    <option value="Downlight">Downlight</option>
                                    <option value="Strahler">Strahler</option>
                                    <option value="Sonstige">Sonstige</option>
                                </select>
                            </div>
                            <div class="col-2">
                                <input type="number" class="form-control form-control-sm" id="lampLumen" placeholder="Lumen" min="0">
                            </div>
                            <div class="col-2">
                                <input type="number" class="form-control form-control-sm" id="lampWatt" placeholder="Watt" min="0">
                            </div>
                        </div>
                        <div class="row mb-3">
                            <div class="col-6">
                                <button type="button" class="btn btn-success btn-sm w-100" onclick="addLamp()">
                                    <i class="bi bi-plus"></i> Standard-Leuchte hinzufügen
                                </button>
                            </div>
                            <div class="col-6">
                                <button type="button" class="btn btn-info btn-sm w-100" onclick="showLDTUpload()">
                                    <i class="bi bi-file-earmark-text"></i> LDT-Datei hochladen
                                </button>
                            </div>
                        </div>

                        <!-- LDT Upload Modal Trigger (wird per JavaScript angezeigt) -->
                        <div id="ldtUploadArea" style="display: none;" class="border rounded p-3 bg-light mb-3">
                            <h6 class="text-info mb-2">
                                <i class="bi bi-file-earmark-text me-1"></i>
                                EULUMDAT (.LDT) Datei hochladen
                            </h6>
                            <div class="row mb-2">
                                <div class="col-6">
                                    <input type="file" class="form-control form-control-sm" id="ldtFile" accept=".ldt,.LDT">
                                </div>
                                <div class="col-3">
                                    <button type="button" class="btn btn-info btn-sm w-100" onclick="uploadLDTFile(false)">
                                        <i class="bi bi-upload me-1"></i>Direkt
                                    </button>
                                </div>
                                <div class="col-3">
                                    <button type="button" class="btn btn-outline-info btn-sm w-100" onclick="uploadLDTFile(true)">
                                        <i class="bi bi-pencil me-1"></i>Prüfen
                                    </button>
                                </div>
                            </div>
                            <small class="text-muted d-block">
                                <strong>Direkt:</strong> Automatischer Import | <strong>Prüfen:</strong> Daten vor Import bearbeiten
                            </small>
                            <button type="button" class="btn btn-outline-secondary btn-sm mt-2" onclick="hideLDTUpload()">
                                <i class="bi bi-x"></i> Abbrechen
                            </button>
                        </div>

                        <!-- LDT Daten-Ergänzungsformular -->
                        <div id="ldtDataCompletion" style="display: none;" class="border rounded p-3 bg-warning bg-opacity-10 mb-3">
                            <h6 class="text-warning mb-3">
                                <i class="bi bi-exclamation-triangle me-1"></i>
                                EULUMDAT-Daten ergänzen
                            </h6>
                            <p class="small mb-3">Einige wichtige Daten konnten nicht aus der LDT-Datei extrahiert werden. Bitte ergänzen Sie diese manuell:</p>

                            <div class="row mb-3">
                                <div class="col-6">
                                    <label class="form-label small">Leuchtenname:</label>
                                    <input type="text" class="form-control form-control-sm" id="ldtCompletionName" readonly>
                                </div>
                                <div class="col-6">
                                    <label class="form-label small">Leuchtentyp:</label>
                                    <select class="form-select form-select-sm" id="ldtCompletionType">
                                        <option value="EULUMDAT Import">EULUMDAT Import</option>
                                        <option value="Feuchtraumleuchte IP65">Feuchtraumleuchte IP65</option>
                                        <option value="Downlight">Downlight</option>
                                        <option value="Panel">Panel</option>
                                        <option value="Strahler">Strahler</option>
                                        <option value="Sonstige">Sonstige</option>
                                    </select>
                                </div>
                            </div>

                            <div class="row mb-3">
                                <div class="col-6">
                                    <label class="form-label small">Lichtstrom (lm): <span class="text-danger">*</span></label>
                                    <input type="number" class="form-control form-control-sm" id="ldtCompletionLumen" min="0" placeholder="z.B. 6000">
                                </div>
                                <div class="col-6">
                                    <label class="form-label small">Leistung (W): <span class="text-danger">*</span></label>
                                    <input type="number" class="form-control form-control-sm" id="ldtCompletionWatt" min="0" placeholder="z.B. 43">
                                </div>
                            </div>

                            <div class="row mb-3">
                                <div class="col-4">
                                    <label class="form-label small">Farbtemperatur:</label>
                                    <input type="text" class="form-control form-control-sm" id="ldtCompletionColorTemp" placeholder="z.B. 4000K">
                                </div>
                                <div class="col-4">
                                    <label class="form-label small">CRI-Wert:</label>
                                    <input type="text" class="form-control form-control-sm" id="ldtCompletionCRI" placeholder="z.B. Ra80">
                                </div>
                                <div class="col-4">
                                    <label class="form-label small">Abmessungen:</label>
                                    <input type="text" class="form-control form-control-sm" id="ldtCompletionDimensions" placeholder="z.B. 1200×100×50 mm">
                                </div>
                            </div>

                            <div class="d-flex gap-2">
                                <button type="button" class="btn btn-success btn-sm" onclick="completeLDTData()">
                                    <i class="bi bi-check-circle me-1"></i>Leuchte hinzufügen
                                </button>
                                <button type="button" class="btn btn-outline-secondary btn-sm" onclick="cancelLDTCompletion()">
                                    <i class="bi bi-x me-1"></i>Abbrechen
                                </button>
                            </div>
                        </div>

                        <div id="savedLamps" class="mb-3" style="display: none;"></div>

                        <div class="d-flex gap-2 align-items-center">
                            <select class="form-select form-select-sm flex-grow-1" id="selectedLamp">
                                <option value="">Leuchte auswählen...</option>
                            </select>
                            <button type="button" class="btn btn-outline-primary btn-sm" onclick="showLampManager()">
                                <i class="bi bi-gear"></i> Verwalten
                            </button>
                        </div>
                    </div>

                    <!-- Nutzebene-Sektion -->
                    <div class="mb-4">
                        <h6 class="text-primary border-bottom pb-2">B: Nutzebene</h6>
                        <div class="row">
                            <div class="col-6">
                                <label class="form-label small">Höhe über Boden (m)</label>
                                <input type="number" class="form-control form-control-sm" id="workPlaneHeight" value="0.85" min="0" step="0.01" onchange="validateWorkPlaneHeight()">
                                <small class="text-muted">Max: <span id="maxWorkPlaneHeight">2.8</span>m (unter Montagehöhe)</small>
                            </div>
                            <div class="col-6">
                                <label class="form-label small">Gewünschte Beleuchtungsstärke (lx)</label>
                                <input type="number" class="form-control form-control-sm" id="targetLux" value="500" min="0" step="10">
                            </div>
                        </div>
                    </div>

                    <!-- Raum-Sektion -->
                    <div class="mb-4">
                        <h6 class="text-primary border-bottom pb-2">C: Raum</h6>
                        <div class="row mb-3">
                            <div class="col-4">
                                <label class="form-label small">Breite (m)</label>
                                <input type="number" class="form-control form-control-sm" id="roomWidth" value="6" min="0.1" step="0.1">
                            </div>
                            <div class="col-4">
                                <label class="form-label small">Länge (m)</label>
                                <input type="number" class="form-control form-control-sm" id="roomLength" value="8" min="0.1" step="0.1">
                            </div>
                            <div class="col-4">
                                <label class="form-label small">Höhe (m)</label>
                                <input type="number" class="form-control form-control-sm" id="roomHeight" value="3" min="0.1" step="0.1" onchange="updateMountingHeightMax()">
                            </div>
                        </div>
                        <div class="row mb-3">
                            <div class="col-6">
                                <label class="form-label small">Montagehöhe der Leuchten (m)</label>
                                <input type="number" class="form-control form-control-sm" id="mountingHeight" value="2.8" min="0" max="3" step="0.01" onchange="validateMountingHeight(); updateWorkPlaneHeightMax()">
                                <small class="text-muted">Max: <span id="maxMountingHeight">3.0</span>m (Raumhöhe)</small>
                            </div>
                            <div class="col-6">
                                <label class="form-label small">Wartungsfaktor</label>
                                <select class="form-select form-select-sm" id="maintenanceFactorType" onchange="updateMaintenanceFactor()">
                                    <option value="auto">Automatisch (RMF nach EN 13032-2)</option>
                                    <option value="manual">Manuell eingeben</option>
                                </select>
                                <input type="number" class="form-control form-control-sm mt-1" id="maintenanceFactor" value="0.8" min="0.1" max="1" step="0.05" style="display: none;">
                                <small class="text-muted" id="maintenanceInfo">Berechnet automatisch basierend auf Raumtyp und LED-Technologie</small>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-6">
                                <label class="form-label small">Reflexionsgrad</label>
                                <select class="form-select form-select-sm" id="reflectionFactor">
                                    <option value="0.7">Hell (70%)</option>
                                    <option value="0.5" selected>Mittel (50%)</option>
                                    <option value="0.3">Dunkel (30%)</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <div class="d-grid gap-2">
                        <button type="button" class="btn btn-primary" onclick="calculate()">
                            <i class="bi bi-calculator me-2"></i>
                            Berechnen
                        </button>
                        <button type="button" class="btn btn-outline-danger" onclick="generatePDF()" id="pdfButton" style="display: none;">
                            <i class="bi bi-file-earmark-pdf me-2"></i>
                            PDF Export
                        </button>
                        <button type="button" class="btn btn-outline-info" onclick="generateCalculationGuidePDF()">
                            <i class="bi bi-book me-2"></i>
                            Berechnungsanleitung (PDF)
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Visualisierung und Ergebnisse -->
        <div class="col-lg-6">
            <!-- 3D Visualisierung -->
            <div class="card shadow-sm mb-4">
                <div class="card-header bg-success text-white d-flex justify-content-between align-items-center">
                    <h5 class="mb-0">3D-Visualisierung</h5>
                    <div>
                        <button type="button" class="btn btn-outline-light btn-sm me-1" onclick="resetCamera()">
                            <i class="bi bi-arrow-counterclockwise"></i>
                        </button>
                        <button type="button" class="btn btn-outline-light btn-sm" onclick="toggleGrid()">
                            <i class="bi bi-grid-3x3"></i>
                        </button>
                    </div>
                </div>
                <div class="card-body p-0">
                    <div id="canvas-container" style="width: 100%; height: 400px; background: #f8f9fa; position: relative;">
                        <div class="d-flex align-items-center justify-content-center h-100 text-muted">
                            <div class="text-center">
                                <i class="bi bi-box display-4 mb-3"></i>
                                <p>3D-Visualisierung wird geladen...</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Ergebnisse -->
            <div class="card shadow-sm" id="results" style="display: none;">
                <div class="card-header bg-info text-white">
                    <h5 class="mb-0">
                        <i class="bi bi-graph-up me-2"></i>
                        Berechnungsergebnisse
                    </h5>
                </div>

                <!-- EULUMDAT-Benachrichtigung -->
                <div id="eulumdatNotice" style="display: none; margin: 10px;"></div>

                <!-- Lichtverteilungskurve -->
                <div id="lightDistributionChart" style="display: none; margin: 10px;">
                    <div class="alert alert-info">
                        <h6 class="mb-2">
                            <i class="bi bi-graph-up me-1"></i>
                            Lichtverteilungskurve (EULUMDAT)
                        </h6>
                        <canvas id="distributionCanvas" width="400" height="300" style="border: 1px solid #ddd; border-radius: 5px; background: white;"></canvas>
                        <small class="text-muted d-block mt-2">
                            Lichtstärkeverteilung basierend auf photometrischen Daten aus der .LDT-Datei
                        </small>
                    </div>
                </div>

                <div class="card-body">
                    <div class="row g-3">
                        <div class="col-6">
                            <div class="text-center p-3 bg-light rounded">
                                <div class="h4 text-primary mb-1" id="lampCountRounded">-</div>
                                <small class="text-muted">Leuchten (gerundet)</small>
                            </div>
                        </div>
                        <div class="col-6">
                            <div class="text-center p-3 bg-light rounded">
                                <div class="h4 text-primary mb-1" id="lampCountExact">-</div>
                                <small class="text-muted">Leuchten (exakt)</small>
                            </div>
                        </div>
                        <div class="col-6">
                            <div class="text-center p-3 bg-light rounded">
                                <div class="h4 text-success mb-1" id="actualLux">-</div>
                                <small class="text-muted">Tatsächliche Beleuchtung (lx)</small>
                            </div>
                        </div>
                        <div class="col-6">
                            <div class="text-center p-3 bg-light rounded">
                                <div class="h4 text-warning mb-1" id="totalPower">-</div>
                                <small class="text-muted">Gesamtleistung (W)</small>
                            </div>
                        </div>
                        <div class="col-6">
                            <div class="text-center p-3 bg-light rounded">
                                <div class="h5 text-secondary mb-1" id="specificPower">-</div>
                                <small class="text-muted">W/m²</small>
                            </div>
                        </div>
                        <div class="col-6">
                            <div class="text-center p-3 bg-light rounded">
                                <div class="h5 text-secondary mb-1" id="specificPowerPer100lx">-</div>
                                <small class="text-muted">W/m²/100lx</small>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Gleichmäßigkeits-Hinweis -->
            <div class="card mt-3" id="distributionWarning" style="display: none;">
                <div class="card-body">
                    <div class="d-flex align-items-center">
                        <i class="bi bi-info-circle-fill me-2 text-primary"></i>
                        <div class="w-100">
                            <strong>Hinweis zur Gleichmäßigkeit:</strong>
                            <div id="distributionWarningText" class="mt-2"></div>

                            <!-- Ausklappbare Ergebnisse für gleichmäßige Verteilung -->
                            <div id="evenDistributionResults" style="display: block;">
                                <hr class="my-3">
                                <div class="card border-primary">
                                    <div class="card-header bg-primary p-3" style="background: linear-gradient(135deg, #0d6efd 0%, #0056b3 100%) !important;">
                                        <button class="btn btn-link text-decoration-none p-0 w-100 text-start text-white" type="button" onclick="toggleEvenResults()">
                                            <i class="bi bi-calculator me-2 text-white"></i>
                                            <strong class="text-white fs-6">Ergebnisse bei gleichmäßiger Verteilung anzeigen</strong>
                                            <i class="bi bi-chevron-up float-end text-white" id="evenResultsIcon"></i>
                                        </button>
                                    </div>
                                    <div class="card-body" id="evenResults" style="display: block;">
                                        <div class="row g-3" id="evenDistributionValues">
                                            <!-- Wird per JavaScript gefüllt -->
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Berechnungsdetails und Erklärungen -->
    <div class="row mt-4" id="calculations" style="display: none;">
        <div class="col-lg-6">
            <div class="card">
                <div class="card-header">
                    <h5 class="card-title mb-1">
                        <i class="bi bi-calculator me-2"></i>Berechnungsdetails
                    </h5>
                    <small class="text-muted">
                        <span id="calculationMethodHeader">Standard-Berechnung nach EN 13032-2</span>
                        <i class="bi bi-info-circle ms-1" data-bs-toggle="tooltip"
                           title="Die Berechnungsmethode wird automatisch basierend auf verfügbaren Daten gewählt"></i>
                    </small>
                </div>
                <div class="card-body">
                    <table class="table table-sm">
                        <tr>
                            <td><strong>Raumfläche (A):</strong>
                                <i class="bi bi-info-circle ms-1 text-muted" data-bs-toggle="tooltip"
                                   title="Länge × Breite des zu beleuchtenden Raumes"></i>
                            </td>
                            <td><span id="calcRoomArea">-</span> m²</td>
                        </tr>
                        <tr>
                            <td><strong>Raumindex (k):</strong>
                                <i class="bi bi-info-circle ms-1 text-muted" data-bs-toggle="tooltip"
                                   title="Charakteristische Raumgröße: k = (L×B)/(h×(L+B)). Kleine k-Werte = hohe Räume, große k-Werte = flache Räume"></i>
                            </td>
                            <td><span id="calcRoomIndex">-</span> <small class="text-muted">(<span id="calcRoomIndexClass">-</span>)</small></td>
                        </tr>
                        <tr>
                            <td><strong>Basis-Wirkungsgrad (η₀):</strong>
                                <i class="bi bi-info-circle ms-1 text-muted" data-bs-toggle="tooltip"
                                   title="Grundwirkungsgrad basierend auf Raumindex nach EN 13032-2"></i>
                            </td>
                            <td><span id="calcBaseUtilization">-</span> %</td>
                        </tr>
                        <tr>
                            <td><strong>Reflexionskorrektur:</strong>
                                <i class="bi bi-info-circle ms-1 text-muted" data-bs-toggle="tooltip"
                                   title="Korrektur basierend auf Reflexionsgrad: (0.7 + 0.3 × Reflexion)"></i>
                            </td>
                            <td>× <span id="calcReflectionFactor">-</span> = <span id="calcUtilizationFactor">-</span> %</td>
                        </tr>
                        <tr>
                            <td><strong>Wartungsfaktor (W):</strong>
                                <i class="bi bi-info-circle ms-1 text-muted" data-bs-toggle="tooltip"
                                   title="Berücksichtigt Lichtverluste durch Verschmutzung und Alterung (0.6-0.9)"></i>
                            </td>
                            <td><span id="calcMaintenanceFactor">-</span></td>
                        </tr>
                        <tr class="table-warning">
                            <td><strong>Benötigter Lichtstrom:</strong>
                                <i class="bi bi-info-circle ms-1 text-muted" data-bs-toggle="tooltip"
                                   title="Φ = (E × A) / (η × W) - Gesamtlichtstrom aller Leuchten"></i>
                            </td>
                            <td><span id="calcTotalLumen">-</span> lm</td>
                        </tr>
                        <tr>
                            <td><strong>Lichtstrom pro Leuchte:</strong>
                                <i class="bi bi-info-circle ms-1 text-muted" data-bs-toggle="tooltip"
                                   title="Nennlichtstrom der gewählten Leuchte aus Datenblatt oder LDT-Datei"></i>
                            </td>
                            <td><span id="calcLampLumen">-</span> lm</td>
                        </tr>
                        <tr>
                            <td><strong>Leistung pro Leuchte:</strong>
                                <i class="bi bi-info-circle ms-1 text-muted" data-bs-toggle="tooltip"
                                   title="Elektrische Nennleistung der gewählten Leuchte"></i>
                            </td>
                            <td><span id="calcLampWatt">-</span> W</td>
                        </tr>
                        <tr class="table-success">
                            <td><strong>Lichtausbeute:</strong>
                                <i class="bi bi-info-circle ms-1 text-muted" data-bs-toggle="tooltip"
                                   title="Effizienz der Leuchte: Lichtstrom/Leistung [lm/W]"></i>
                            </td>
                            <td><span id="calcLampEfficiency">-</span> lm/W</td>
                        </tr>
                        <tr class="table-info">
                            <td><strong>Spezifische Leistung:</strong>
                                <i class="bi bi-info-circle ms-1 text-muted" data-bs-toggle="tooltip"
                                   title="Installierte Leistung pro m² Raumfläche"></i>
                            </td>
                            <td><span id="calcSpecificPower">-</span> W/m²</td>
                        </tr>
                    </table>

                    <!-- Gesamtberechnung Schritt für Schritt -->
                    <div class="mt-4">
                        <h6><i class="bi bi-list-ol me-2"></i>Detaillierte Berechnung nach EN 13032-2</h6>
                        <div class="border rounded p-3 bg-light">
                            <div class="mb-3">
                                <h6 class="text-primary mb-2"><i class="bi bi-1-circle me-1"></i> Geometrische Parameter</h6>
                                <div style="font-size: 0.9em;">
                                    <div class="row">
                                        <div class="col-md-6">
                                            <strong>Raumfläche:</strong><br>
                                            A = L × B = <span id="stepRoomWidth">-</span> × <span id="stepRoomLength">-</span> = <span id="stepRoomArea">-</span> m²
                                        </div>
                                        <div class="col-md-6">
                                            <strong>Lichte Höhe:</strong><br>
                                            h = <span id="stepMountingHeight">-</span> - <span id="stepWorkPlaneHeight">-</span> = <span id="stepH">-</span> m
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="mb-3">
                                <h6 class="text-primary mb-2"><i class="bi bi-2-circle me-1"></i> Raumindex und Wirkungsgrad</h6>
                                <div style="font-size: 0.9em;">
                                    <strong>Raumindex:</strong><br>
                                    k = (L × B) / (h × (L + B)) = (<span id="stepCalcWidth">-</span> × <span id="stepCalcLength">-</span>) / (<span id="stepCalcH">-</span> × (<span id="stepCalcWidth2">-</span> + <span id="stepCalcLength2">-</span>)) = <span id="stepK">-</span><br>
                                    <small class="text-muted">→ <span id="stepRoomType">-</span></small><br><br>

                                    <strong>Basis-Wirkungsgrad (nach Tabelle):</strong><br>
                                    η₀ = <span id="stepBaseEta">-</span> % <small class="text-muted">(für k = <span id="stepKValue">-</span>)</small><br><br>

                                    <strong>Reflexionskorrektur:</strong><br>
                                    Faktor = 0.7 + 0.3 × <span id="stepReflection">-</span> = <span id="stepReflectionFactor">-</span><br>
                                    η = <span id="stepBaseEta2">-</span> % × <span id="stepReflectionFactor2">-</span> = <span id="stepFinalEta">-</span> %
                                </div>
                            </div>

                            <div class="mb-3">
                                <h6 class="text-primary mb-2"><i class="bi bi-3-circle me-1"></i> Lichtstrombedarf</h6>
                                <div style="font-size: 0.9em;">
                                    <strong>Grundformel:</strong> Φ = (E × A) / (η × W)<br>
                                    Φ = (<span id="stepTargetLux">-</span> lx × <span id="stepAreaCalc">-</span> m²) / (<span id="stepEtaCalc">-</span> × <span id="stepMaintenance">-</span>)<br>
                                    Φ = <span id="stepLumenNumerator">-</span> / <span id="stepLumenDenominator">-</span> = <span id="stepTotalLumen">-</span> lm
                                </div>
                            </div>

                            <div class="mb-3">
                                <h6 class="text-primary mb-2"><i class="bi bi-4-circle me-1"></i> Leuchtenanzahl</h6>
                                <div style="font-size: 0.9em;">
                                    <strong>Exakte Anzahl:</strong><br>
                                    n = Φ_gesamt / Φ_Leuchte = <span id="stepTotalLumen2">-</span> lm / <span id="stepLampLumen">-</span> lm = <span id="stepExactCount">-</span><br><br>

                                    <strong>Aufgerundet:</strong><br>
                                    n = <span id="stepRoundedCount">-</span> Stück <small class="text-muted">(mindestens benötigt)</small>
                                </div>
                            </div>

                            <div class="mb-3">
                                <h6 class="text-success mb-2"><i class="bi bi-5-circle me-1"></i> Ergebnis-Kontrolle</h6>
                                <div style="font-size: 0.9em;">
                                    <strong>Tatsächliche Beleuchtungsstärke:</strong><br>
                                    E = (n × Φ_Leuchte × η × W) / A<br>
                                    E = (<span id="stepFinalCount">-</span> × <span id="stepFinalLampLumen">-</span> × <span id="stepFinalEta">-</span> × <span id="stepFinalMaintenance">-</span>) / <span id="stepFinalArea">-</span><br>
                                    E = <span id="stepActualLux">-</span> lx <small class="text-muted">(<span id="stepLuxDifference">-</span>% über Zielwert)</small><br><br>

                                    <strong>Gesamtleistung:</strong><br>
                                    P_gesamt = n × P_Leuchte = <span id="stepFinalCount2">-</span> × <span id="stepLampWatt">-</span> W = <span id="stepTotalPower">-</span> W<br>
                                    P_spezifisch = <span id="stepTotalPower2">-</span> W / <span id="stepFinalArea2">-</span> m² = <span id="stepSpecificPower">-</span> W/m²
                                </div>
                            </div>

                            <!-- Zusätzliche Analyse bei extremen Geometrien -->
                            <div id="geometryAnalysis" class="alert alert-warning" style="display: none; font-size: 0.9em;">
                                <h6 class="alert-heading"><i class="bi bi-exclamation-triangle me-1"></i> Geometrie-Analyse</h6>
                                <div id="geometryWarnings"></div>
                                <div id="overlapInfo" style="display: none;">
                                    <strong>Überlappungskorrektur:</strong><br>
                                    Lichtkreisradius: r = h × tan(α/2) = <span id="stepLightRadius">-</span> m<br>
                                    Leuchtenabstand: d = <span id="stepLampSpacing">-</span> m<br>
                                    Überlappungsfaktor: <span id="stepOverlapFactor">-</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="col-lg-6">
            <div class="card">
                <div class="card-header">
                    <h5 class="card-title mb-0">
                        <i class="bi bi-info-circle me-2"></i>Erklärungen
                    </h5>
                </div>
                <div class="card-body">
                    <div class="accordion" id="explanationAccordion">
                        <!-- Grundformel -->
                        <div class="accordion-item">
                            <h6 class="accordion-header">
                                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#formula">
                                    Grundformel
                                </button>
                            </h6>
                            <div id="formula" class="accordion-collapse collapse" data-bs-parent="#explanationAccordion">
                                <div class="accordion-body">
                                    <code>E = (Φ × η × W) / A</code><br>
                                    <small>
                                        <strong>E</strong> = Beleuchtungsstärke [lx]<br>
                                        <strong>Φ</strong> = Lichtstrom [lm]<br>
                                        <strong>η</strong> = Raumwirkungsgrad<br>
                                        <strong>W</strong> = Wartungsfaktor<br>
                                        <strong>A</strong> = Raumfläche [m²]
                                    </small>
                                </div>
                            </div>
                        </div>

                        <!-- Raumindex -->
                        <div class="accordion-item">
                            <h6 class="accordion-header">
                                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#roomIndex">
                                    Raumindex (k)
                                </button>
                            </h6>
                            <div id="roomIndex" class="accordion-collapse collapse" data-bs-parent="#explanationAccordion">
                                <div class="accordion-body">
                                    <code>k = (L × B) / (h × (L + B))</code><br>
                                    <small>
                                        <strong>L</strong> = Länge, <strong>B</strong> = Breite<br>
                                        <strong>h</strong> = Abstand Leuchte-Arbeitsebene<br><br>
                                        <strong>k < 1:</strong> Hoher, schmaler Raum (schlechter Wirkungsgrad)<br>
                                        <strong>k > 3:</strong> Niedriger, breiter Raum (besserer Wirkungsgrad)
                                    </small>
                                </div>
                            </div>
                        </div>

                        <!-- Raumwirkungsgrad -->
                        <div class="accordion-item">
                            <h6 class="accordion-header">
                                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#utilization">
                                    Raumwirkungsgrad (η)
                                </button>
                            </h6>
                            <div id="utilization" class="accordion-collapse collapse" data-bs-parent="#explanationAccordion">
                                <div class="accordion-body">
                                    <small>
                                        <strong>Definition:</strong> Anteil des Leuchtenlichtstroms, der die Arbeitsebene erreicht.<br><br>

                                        <strong>Erweiterte Wirkungsgrad-Tabelle (nach EN 13032-2):</strong><br>
                                        <u>k < 0.6:</u> η₀ = 25% (Hohe, schmale Räume)<br>
                                        <u>k = 0.6-0.8:</u> η₀ = 30% (Hohe Räume)<br>
                                        <u>k = 0.8-1.0:</u> η₀ = 35%<br>
                                        <u>k = 1.0-1.25:</u> η₀ = 40%<br>
                                        <u>k = 1.25-1.5:</u> η₀ = 45%<br>
                                        <u>k = 1.5-2.0:</u> η₀ = 50%<br>
                                        <u>k = 2.0-2.5:</u> η₀ = 55%<br>
                                        <u>k = 2.5-3.0:</u> η₀ = 60%<br>
                                        <u>k = 3.0-4.0:</u> η₀ = 70%<br>
                                        <u>k = 4.0-5.0:</u> η₀ = 79% (Breite Räume)<br>
                                        <u>k = 5.0-6.0:</u> η₀ = 85%<br>
                                        <u>k = 6.0-7.0:</u> η₀ = 89%<br>
                                        <u>k = 7.0-8.0:</u> η₀ = 91% (Sehr flache Räume)<br><br>

                                        <strong>Reflexionskorrektur:</strong><br>
                                        η_final = η₀ × (0.7 + 0.3 × ρ_mittel)<br>
                                        Berücksichtigt die mittleren Reflexionsgrade aller Raumoberflächen.
                                    </small>
                                </div>
                            </div>
                        </div>

                        <!-- Wartungsfaktor -->
                        <div class="accordion-item">
                            <h6 class="accordion-header">
                                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#maintenance">
                                    Wartungsfaktor
                                </button>
                            </h6>
                            <div id="maintenance" class="accordion-collapse collapse" data-bs-parent="#explanationAccordion">
                                <div class="accordion-body">
                                    <small>
                                        Berücksichtigt Lichtverluste durch:<br>
                                        • Verschmutzung der Leuchten<br>
                                        • Alterung der Leuchtmittel<br>
                                        • Verschmutzung der Raumoberflächen<br><br>
                                        <strong>Typische Werte:</strong><br>
                                        Saubere Umgebung: 0.8-0.9<br>
                                        Normale Umgebung: 0.7-0.8<br>
                                        Schmutzige Umgebung: 0.6-0.7
                                    </small>
                                </div>
                            </div>
                        </div>

                        <!-- Lichtverteilung und EULUMDAT -->
                        <div class="accordion-item">
                            <h6 class="accordion-header">
                                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#lightDistribution">
                                    Lichtverteilung (LDT/EULUMDAT)
                                </button>
                            </h6>
                            <div id="lightDistribution" class="accordion-collapse collapse" data-bs-parent="#explanationAccordion">
                                <div class="accordion-body">
                                    <small>
                                        <strong>EULUMDAT-Datenformat:</strong><br>
                                        Standardisierte photometrische Daten mit 72 C-Ebenen und 161 Gamma-Winkeln für präzise Lichtverteilungsberechnung.<br><br>

                                        <strong>Berücksichtigte Parameter:</strong><br>
                                        • <u>Lichtstromverteilung</u>: Raumwinkelabhängige Intensität<br>
                                        • <u>Abstrahlwinkel</u>: Effektive Lichtkegelbreite<br>
                                        • <u>Asymmetrie</u>: Unterschiedliche Verteilung in C-Ebenen<br>
                                        • <u>Leuchtenwirkungsgrad</u>: Bereits in LDT-Daten enthalten<br><br>

                                        <strong>Einfluss auf Berechnung:</strong><br>
                                        • Präzisere Wirkungsgrad-Bestimmung<br>
                                        • Berücksichtigung der tatsächlichen Lichtverteilung<br>
                                        • Anpassung bei stark asymmetrischen Leuchten<br>
                                        • Optimierung der Leuchtenanordnung
                                    </small>
                                </div>
                            </div>
                        </div>

                        <!-- Reflexionsgrade -->
                        <div class="accordion-item">
                            <h6 class="accordion-header">
                                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#reflectance">
                                    Reflexionsgrade der Raumoberflächen
                                </button>
                            </h6>
                            <div id="reflectance" class="accordion-collapse collapse" data-bs-parent="#explanationAccordion">
                                <div class="accordion-body">
                                    <small>
                                        <strong>Einfluss auf Raumwirkungsgrad:</strong><br>
                                        Korrekturformel: η = η₀ × (0.7 + 0.3 × ρ_mittlerer)<br><br>

                                        <strong>Typische Reflexionsgrade:</strong><br>
                                        <u>Decke:</u> Weiß 0.8, Hell 0.7, Mittel 0.5, Dunkel 0.3<br>
                                        <u>Wände:</u> Weiß 0.7, Hell 0.5, Mittel 0.3, Dunkel 0.1<br>
                                        <u>Boden:</u> Hell 0.3, Mittel 0.2, Dunkel 0.1<br><br>

                                        <strong>Materialbeispiele:</strong><br>
                                        • Weiße Farbe: 0.7-0.85<br>
                                        • Helle Holzdecke: 0.6-0.7<br>
                                        • Beton roh: 0.3-0.4<br>
                                        • Dunkle Farben: 0.1-0.3<br>
                                        • Schwarze Oberflächen: 0.05-0.1<br><br>

                                        <strong>Wichtiger Hinweis:</strong><br>
                                        Helle Oberflächen können den Wirkungsgrad um bis zu 30% verbessern!
                                    </small>
                                </div>
                            </div>
                        </div>

                        <!-- Geometrie und Grenzen -->
                        <div class="accordion-item">
                            <h6 class="accordion-header">
                                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#geometry">
                                    Geometriebereiche und Tool-Grenzen
                                </button>
                            </h6>
                            <div id="geometry" class="accordion-collapse collapse" data-bs-parent="#explanationAccordion">
                                <div class="accordion-body">
                                    <small>
                                        <strong>Optimaler Anwendungsbereich:</strong><br>
                                        Raumindex k = 0.6 bis 8.0 (nach EN 13032-2)<br>
                                        Raumhöhe: 2.5m bis 10m<br>
                                        Raumfläche: 10m² bis 2000m²<br><br>

                                        <strong>Raumcharakteristika:</strong><br>
                                        <u>k < 0.6</u>: Sehr hohe, schmale Räume (η = 25%)<br>
                                        <u>k = 0.6-1.0</u>: Hohe Räume (η = 30-40%)<br>
                                        <u>k = 1.0-2.0</u>: Normale Räume (η = 40-55%)<br>
                                        <u>k = 2.0-4.0</u>: Breite Räume (η = 55-70%)<br>
                                        <u>k > 4.0</u>: Sehr breite, flache Räume (η = 70-90%)<br><br>

                                        <strong>Spezielle Korrekturen:</strong><br>
                                        • <u>Überlappungskorrektur</u>: Bei flachen Räumen (h < 4m) und großen Flächen<br>
                                        • <u>Geometriewarnungen</u>: Bei extremen Verhältnissen (k > 8.0)<br>
                                        • <u>Randbereich-Zuschlag</u>: Automatisch bei der Wirkungsgrad-Tabelle berücksichtigt<br><br>

                                        <strong>Abweichungen zu Profi-Software:</strong><br>
                                        Relux/DIALux verwenden detailliertere Algorithmen und Raytracing.
                                        Unterschiede von ±10-20% sind bei komplexen Geometrien normal.
                                    </small>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Leuchten-Verwaltung Modal -->
<div class="modal fade" id="lampManagerModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">
                    <i class="bi bi-lightbulb me-2"></i>Leuchten verwalten
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="alert alert-info">
                    <i class="bi bi-info-circle me-2"></i>
                    <strong>Hinweis:</strong> Hier können Sie alle verfügbaren Leuchten einsehen und bei Bedarf löschen.
                    Schuch-Standardleuchten können nicht gelöscht werden.
                </div>

                <div id="lampManagerList">
                    <!-- Wird per JavaScript gefüllt -->
                </div>

                <div class="text-muted text-center mt-3" id="noLampsMessage" style="display: none;">
                    <i class="bi bi-lightbulb"></i><br>
                    Keine benutzerdefinierten Leuchten vorhanden.
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Schließen</button>
            </div>
        </div>
    </div>
</div>

<script>
// Globale Variablen
let scene, camera, renderer;
let room, workPlane, lamps = [];
let gridHelper;
let lampDatabase = [];

// Bootstrap Tooltips initialisieren
function initializeTooltips() {
    // Alle Tooltips initialisieren
    var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
    var tooltipList = tooltipTriggerList.map(function (tooltipTriggerEl) {
        return new bootstrap.Tooltip(tooltipTriggerEl, {
            delay: { show: 500, hide: 100 },
            placement: 'auto'
        });
    });
    console.log('Tooltips initialized:', tooltipList.length);
}

// Tooltip-Inhalte dynamisch aktualisieren
function updateCalculationTooltips() {
    // Aktualisiere spezifische Tooltips mit berechneten Werten falls vorhanden
    const roomIndex = document.getElementById('calcRoomIndex')?.textContent;
    if (roomIndex && roomIndex !== '-') {
        const roomIndexTooltip = document.querySelector('[title*="k = (L×B)/(h×(L+B))"]');
        if (roomIndexTooltip) {
            const kValue = parseFloat(roomIndex);
            let roomType = '';
            if (kValue < 0.6) roomType = 'Sehr hoher, schmaler Raum';
            else if (kValue < 1.0) roomType = 'Hoher Raum';
            else if (kValue < 2.0) roomType = 'Normaler Raum';
            else if (kValue < 4.0) roomType = 'Breiter Raum';
            else roomType = 'Sehr breiter, flacher Raum';

            roomIndexTooltip.setAttribute('data-bs-original-title',
                `k = ${roomIndex} → ${roomType}. Formel: k = (L×B)/(h×(L+B))`);
        }
    }
}

// LDT Upload Funktionen
function showLDTUpload() {
    document.getElementById('ldtUploadArea').style.display = 'block';
}

function hideLDTUpload() {
    document.getElementById('ldtUploadArea').style.display = 'none';
    document.getElementById('ldtFile').value = '';
}

function uploadLDTFile(forceReview = false) {
    const fileInput = document.getElementById('ldtFile');
    const file = fileInput.files[0];

    if (!file) {
        alert('Bitte wählen Sie eine LDT-Datei aus!');
        return;
    }

    if (!file.name.toLowerCase().endsWith('.ldt')) {
        alert('Bitte wählen Sie eine gültige .LDT-Datei aus!');
        return;
    }

    console.log('LDT-Datei wird verarbeitet:', file.name, 'Größe:', file.size, 'Bytes', 'Prüfen-Modus:', forceReview);

    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            console.log('LDT-Datei gelesen, Verarbeitung startet...');
            const ldtContent = e.target.result;

            // EULUMDAT-Parser für die hochgeladene Datei
            const parsedData = parseEULUMDATFile(ldtContent, file.name);

            if (parsedData) {
                // Prüfe auf fehlende oder unvollständige Daten
                const missingData = [];
                const incompleteData = [];

                // Kritische Daten (müssen vorhanden sein)
                if (!parsedData.lumen || parsedData.lumen === 0) missingData.push('Lichtstrom');
                if (!parsedData.watt || parsedData.watt === 0) missingData.push('Leistung');

                // Optionale Daten (können ergänzt werden)
                if (!parsedData.colorTemp || parsedData.colorTemp === 'UnbekanntK') incompleteData.push('Farbtemperatur');
                if (!parsedData.cri || parsedData.cri === 'RaUnbekannt') incompleteData.push('CRI-Wert');
                if (!parsedData.dimensions || parsedData.dimensions === '0×0×0 mm') incompleteData.push('Abmessungen');

                if (forceReview || missingData.length > 0 || incompleteData.length > 0) {
                    // Zeige Ergänzungsformular für fehlende/unvollständige Daten oder bei forcierter Prüfung
                    console.log('Zeige Daten-Prüfung - Fehlende:', missingData, 'Unvollständige:', incompleteData, 'Erzwungene Prüfung:', forceReview);
                    showLDTDataCompletion(parsedData, file.name, [...missingData, ...incompleteData], forceReview);
                } else {
                    // Alle wichtigen Daten vollständig - direkt hinzufügen
                    addLampFromLDT(parsedData, file.name);
                }
            }
        } catch (error) {
            console.error('Fehler beim Verarbeiten der LDT-Datei:', error);
            alert('Fehler beim Verarbeiten der LDT-Datei!\n\nBitte stellen Sie sicher, dass es sich um eine gültige EULUMDAT-Datei handelt.');
        }
    };

    reader.onerror = function() {
        console.error('Fehler beim Lesen der Datei');
        alert('Fehler beim Lesen der Datei!');
    };

    reader.readAsText(file);
}

// Globale Variable für temporäre LDT-Daten
let tempLDTData = null;

// Zeige Ergänzungsformular für fehlende LDT-Daten
function showLDTDataCompletion(parsedData, filename, missingData, isReviewMode = false) {
    tempLDTData = { parsedData, filename };

    // Formular-Felder füllen
    document.getElementById('ldtCompletionName').value = parsedData.name || filename.replace('.ldt', '').replace('.LDT', '');
    document.getElementById('ldtCompletionLumen').value = parsedData.lumen || '';
    document.getElementById('ldtCompletionWatt').value = parsedData.watt || '';
    document.getElementById('ldtCompletionColorTemp').value = parsedData.colorTemp?.replace('K', '') ? parsedData.colorTemp : '';
    document.getElementById('ldtCompletionCRI').value = parsedData.cri?.replace('Ra', '') ? parsedData.cri : '';
    document.getElementById('ldtCompletionDimensions').value = parsedData.dimensions || '';

    // Felder entsperren wenn im Prüfen-Modus
    if (isReviewMode) {
        document.getElementById('ldtCompletionName').removeAttribute('readonly');
        document.getElementById('ldtCompletionName').classList.add('border-info');
    }

    // Fehlende Felder hervorheben
    if (missingData.includes('Lichtstrom')) {
        document.getElementById('ldtCompletionLumen').classList.add('border-danger');
        document.getElementById('ldtCompletionLumen').focus();
    }
    if (missingData.includes('Leistung')) {
        document.getElementById('ldtCompletionWatt').classList.add('border-danger');
    }

    // Unvollständige optionale Felder hervorheben
    if (missingData.includes('Farbtemperatur')) {
        document.getElementById('ldtCompletionColorTemp').classList.add('border-warning');
    }
    if (missingData.includes('CRI-Wert')) {
        document.getElementById('ldtCompletionCRI').classList.add('border-warning');
    }
    if (missingData.includes('Abmessungen')) {
        document.getElementById('ldtCompletionDimensions').classList.add('border-warning');
    }

    // Upload-Bereich verstecken und Ergänzungsformular anzeigen
    hideLDTUpload();
    document.getElementById('ldtDataCompletion').style.display = 'block';

    const mode = isReviewMode ? 'Prüfen-Modus' : 'Ergänzung erforderlich';
    console.log(`Ergänzungsformular angezeigt (${mode}) für Daten:`, missingData);
}

// Vervollständige LDT-Daten und füge Lampe hinzu
function completeLDTData() {
    if (!tempLDTData) {
        alert('Fehler: Keine temporären LDT-Daten gefunden!');
        return;
    }

    // Validierung der Pflichtfelder
    const lumen = parseFloat(document.getElementById('ldtCompletionLumen').value);
    const watt = parseFloat(document.getElementById('ldtCompletionWatt').value);

    if (!lumen || lumen <= 0) {
        alert('Bitte geben Sie einen gültigen Lichtstrom (Lumen) ein!');
        document.getElementById('ldtCompletionLumen').focus();
        return;
    }

    if (!watt || watt <= 0) {
        alert('Bitte geben Sie eine gültige Leistung (Watt) ein!');
        document.getElementById('ldtCompletionWatt').focus();
        return;
    }

    // Ergänzte Daten sammeln
    const completedData = {
        ...tempLDTData.parsedData,
        name: document.getElementById('ldtCompletionName').value || tempLDTData.filename.replace('.ldt', '').replace('.LDT', ''),
        lumen: Math.round(lumen),
        watt: Math.round(watt),
        colorTemp: document.getElementById('ldtCompletionColorTemp').value || 'Unbekannt',
        cri: document.getElementById('ldtCompletionCRI').value || 'Unbekannt',
        dimensions: document.getElementById('ldtCompletionDimensions').value || 'Unbekannt'
    };

    // Leuchte hinzufügen
    const lampType = document.getElementById('ldtCompletionType').value;
    addLampFromLDT(completedData, tempLDTData.filename, lampType);

    // Formular verstecken und zurücksetzen
    cancelLDTCompletion();
}

// Ergänzungsformular abbrechen
function cancelLDTCompletion() {
    document.getElementById('ldtDataCompletion').style.display = 'none';

    // Felder zurücksetzen
    document.getElementById('ldtCompletionName').value = '';
    document.getElementById('ldtCompletionLumen').value = '';
    document.getElementById('ldtCompletionWatt').value = '';
    document.getElementById('ldtCompletionColorTemp').value = '';
    document.getElementById('ldtCompletionCRI').value = '';
    document.getElementById('ldtCompletionDimensions').value = '';
    document.getElementById('ldtCompletionType').value = 'EULUMDAT Import';

    // Alle Hervorhebungen und Attribute entfernen
    const fields = ['ldtCompletionName', 'ldtCompletionLumen', 'ldtCompletionWatt',
                   'ldtCompletionColorTemp', 'ldtCompletionCRI', 'ldtCompletionDimensions'];

    fields.forEach(fieldId => {
        const field = document.getElementById(fieldId);
        field.classList.remove('border-danger', 'border-warning', 'border-info');
        if (fieldId === 'ldtCompletionName') {
            field.setAttribute('readonly', 'readonly');
        }
    });

    tempLDTData = null;
}

// Hilfsfunktion zum Hinzufügen der Lampe aus LDT-Daten
function addLampFromLDT(parsedData, filename, lampType = 'EULUMDAT Import') {
    const newLamp = {
        id: Date.now(),
        name: parsedData.name || filename.replace('.ldt', '').replace('.LDT', ''),
        type: lampType,
        lumen: parsedData.lumen,
        watt: parsedData.watt,
        hasEULUMDAT: true,
        eulumdatFile: filename,
        eulumdatData: parsedData,
        colorTemp: parsedData.colorTemp || 'Unbekannt',
        cri: parsedData.cri || 'Unbekannt',
        dimensions: parsedData.dimensions || 'Unbekannt'
    };

    lampDatabase.push(newLamp);

    // Auto-Auswahl der neu importierten Leuchte
    updateLampList(newLamp.id);

    // Erfolgsmeldung
    alert(`LDT-Datei erfolgreich importiert!\n\nLeuchte: ${newLamp.name}\nLichtstrom: ${newLamp.lumen} lm\nLeistung: ${newLamp.watt} W\n\nDie Leuchte wurde automatisch ausgewählt und ist bereit für die Berechnung.`);

    console.log('LDT-Import erfolgreich:', newLamp);
}

// EULUMDAT Parser für beliebige LDT-Dateien
function parseEULUMDATFile(content, filename) {
    console.log('Parsing EULUMDAT file:', filename);

    const lines = content.split('\n').map(line => line.trim());

    // EULUMDAT-Header einlesen
    if (lines.length < 10) {
        throw new Error('Ungültige EULUMDAT-Datei: Zu wenige Zeilen');
    }

    try {
        // Basis-Informationen aus EULUMDAT-Header
        const company = lines[0] || 'Unbekannt';
        const typeNumber = lines[1] || 'Unbekannt';
        const luminousIntensityType = parseInt(lines[2]) || 1;
        const numLuminousIntensities = parseInt(lines[3]) || 0;
        const numCPlanes = parseInt(lines[4]) || 0;
        const numGammaAngles = parseInt(lines[5]) || 0;

        // Technische Daten (Zeilen 6-12)
        const measurementReport = lines[6] || '';
        const luminaireName = lines[7] || typeNumber;
        const luminaireNumber = lines[8] || '';
        const fileName = lines[9] || filename;
        const dateUser = lines[10] || '';
        const length = parseFloat(lines[11]) || 0;
        const width = parseFloat(lines[12]) || 0;
        const height = parseFloat(lines[13]) || 0;

        // Elektrische Daten (EULUMDAT-Standard: Zeilen 25-31, aber 0-basiert = 25-31)
        const numLampSets = parseInt(lines[25]) || 1;
        const numLampsPerSet = parseInt(lines[26]) || 1;
        const lampType = lines[27] || 'LED';
        const totalLuminousFlux = parseFloat(lines[28]) || 0;
        const colorTempRaw = lines[29] || '4000K';
        const criRaw = lines[30] || 'Ra80';
        const lampPower = parseFloat(lines[31]) || 0;

        // Verarbeite Farbtemperatur und CRI korrekt
        const colorTemp = colorTempRaw.toString().replace('K', '');
        const cri = criRaw.toString().replace('Ra', '');

        console.log('EULUMDAT-Parsing Details:');
        console.log('- Zeile 29 (Index 28) - Lichtstrom:', lines[28], '→', totalLuminousFlux, 'lm');
        console.log('- Zeile 30 (Index 29) - Farbtemperatur:', lines[29], '→', colorTemp, 'K');
        console.log('- Zeile 31 (Index 30) - CRI:', lines[30], '→', cri);
        console.log('- Zeile 32 (Index 31) - Leistung:', lines[31], '→', lampPower, 'W');

        console.log('EULUMDAT-Parsing erfolgreich:', {
            company, typeNumber, luminaireName, totalLuminousFlux, lampPower, colorTemp, cri
        });

        const result = {
            name: `${company} ${typeNumber}`.trim() || luminaireName,
            lumen: Math.round(totalLuminousFlux),
            watt: Math.round(lampPower),
            colorTemp: colorTempRaw.toString().includes('K') ? colorTempRaw : `${colorTemp}K`,
            cri: criRaw.toString().includes('Ra') ? criRaw : `Ra${cri}`,
            dimensions: `${length}×${width}×${height} mm`,
            rawData: {
                company,
                typeNumber,
                luminaireName,
                numCPlanes,
                numGammaAngles,
                length,
                width,
                height,
                totalLuminousFlux,
                lampPower,
                colorTempRaw,
                criRaw,
                // Vollständigen LDT-Inhalt für erweiterte Analyse speichern
                ldtContent: content,
                filename: filename
            }
        };

        console.log('Finale Rückgabedaten:', result);
        return result;

    } catch (error) {
        console.error('Fehler beim Parsen der EULUMDAT-Daten:', error);
        throw new Error('Fehler beim Parsen der EULUMDAT-Daten: ' + error.message);
    }
}

// Lampen-Management
function addLamp() {
    const name = document.getElementById('lampName').value;
    const type = document.getElementById('lampType').value;
    const lumen = parseFloat(document.getElementById('lampLumen').value);
    const watt = parseFloat(document.getElementById('lampWatt').value);

    if (name && lumen && watt) {
        const lamp = { name, type, lumen, watt, id: Date.now() };
        lampDatabase.push(lamp);
        updateLampList();

        // Eingabefelder leeren
        document.getElementById('lampName').value = '';
        document.getElementById('lampType').value = '';
        document.getElementById('lampLumen').value = '';
        document.getElementById('lampWatt').value = '';
    } else {
        alert('Bitte Name, Lumen und Watt ausfüllen!');
    }
}

function removeLamp(id) {
    lampDatabase = lampDatabase.filter(lamp => lamp.id !== id);
    updateLampList();
    updateLampManagerList(); // Update modal list if open
}

// Leuchten-Verwaltung Modal
function showLampManager() {
    updateLampManagerList();
    const modal = new bootstrap.Modal(document.getElementById('lampManagerModal'));
    modal.show();
}

function updateLampManagerList() {
    const lampManagerList = document.getElementById('lampManagerList');
    const noLampsMessage = document.getElementById('noLampsMessage');

    if (!lampManagerList) return;

    lampManagerList.innerHTML = '';

    // Zähle benutzerdefinierte Leuchten (keine Schuch-Leuchten)
    const customLamps = lampDatabase.filter(lamp => !lamp.name.includes('LWL') && lamp.id < 1000);

    if (customLamps.length === 0) {
        noLampsMessage.style.display = 'block';
        lampManagerList.style.display = 'none';
    } else {
        noLampsMessage.style.display = 'none';
        lampManagerList.style.display = 'block';

        // Gruppiere Leuchten nach Typ
        const groupedLamps = {};
        lampDatabase.forEach(lamp => {
            const type = lamp.type || 'Benutzerdefiniert';
            if (!groupedLamps[type]) groupedLamps[type] = [];
            groupedLamps[type].push(lamp);
        });

        Object.keys(groupedLamps).forEach(type => {
            const typeSection = document.createElement('div');
            typeSection.className = 'mb-4';

            typeSection.innerHTML = `
                <h6 class="text-primary border-bottom pb-2 mb-3">
                    <i class="bi bi-collection me-2"></i>${type}
                </h6>
            `;

            groupedLamps[type].forEach(lamp => {
                const isSchuchLamp = lamp.name.includes('LWL') || lamp.id >= 1000;
                const div = document.createElement('div');
                div.className = `card mb-2 ${isSchuchLamp ? 'border-secondary' : 'border-light'}`;

                div.innerHTML = `
                    <div class="card-body p-3">
                        <div class="d-flex justify-content-between align-items-start">
                            <div class="flex-grow-1">
                                <h6 class="card-title mb-1 ${isSchuchLamp ? 'text-secondary' : ''}">
                                    <i class="bi bi-lightbulb me-2"></i>${lamp.name}
                                    ${isSchuchLamp ? '<span class="badge bg-secondary ms-2">SCHUCH</span>' : ''}
                                </h6>
                                <p class="card-text text-muted mb-0">
                                    <small>
                                        <i class="bi bi-brightness-high me-1"></i>${lamp.lumen} lm &nbsp;
                                        <i class="bi bi-lightning me-1"></i>${lamp.watt} W
                                    </small>
                                </p>
                            </div>
                            <div class="text-end">
                                ${!isSchuchLamp ? `
                                    <button class="btn btn-outline-danger btn-sm" onclick="removeLampFromManager(${lamp.id})" title="Löschen">
                                        <i class="bi bi-trash"></i>
                                    </button>
                                ` : `
                                    <small class="text-muted">Standard</small>
                                `}
                            </div>
                        </div>
                    </div>
                `;

                typeSection.appendChild(div);
            });

            lampManagerList.appendChild(typeSection);
        });
    }
}

function removeLampFromManager(id) {
    if (confirm('Möchten Sie diese Leuchte wirklich löschen?')) {
        removeLamp(id);
    }
}

function updateLampList(autoSelectLampId = null) {
    console.log('updateLampList function called, lampDatabase has', lampDatabase?.length || 0, 'items');
    const savedLamps = document.getElementById('savedLamps');
    const selectedLamp = document.getElementById('selectedLamp');

    // Gespeicherte Lampen anzeigen
    savedLamps.innerHTML = '';
    lampDatabase.forEach(lamp => {
        const div = document.createElement('div');
        div.className = 'alert alert-secondary p-2 mb-2 d-flex justify-content-between align-items-center';
        const typeText = lamp.type ? ` - ${lamp.type}` : '';
        div.innerHTML = `
            <small><strong>${lamp.name}</strong>${typeText}<br>
            <span class="text-muted">${lamp.lumen} lm, ${lamp.watt} W</span></small>
            <button class="btn btn-outline-danger btn-sm" onclick="removeLamp(${lamp.id})">
                <i class="bi bi-trash"></i>
            </button>
        `;
        savedLamps.appendChild(div);
    });

    // Dropdown aktualisieren
    selectedLamp.innerHTML = '<option value="">Leuchte auswählen...</option>';
    lampDatabase.forEach(lamp => {
        const option = document.createElement('option');
        option.value = lamp.id;
        const typeText = lamp.type ? ` - ${lamp.type}` : '';

        // EULUMDAT-Kennzeichnung hinzufügen
        let displayName = `${lamp.name}${typeText} (${lamp.lumen} lm, ${lamp.watt} W)`;
        if (lamp.hasEULUMDAT) {
            displayName += ' 📊 EULUMDAT';
        }

        option.textContent = displayName;
        selectedLamp.appendChild(option);
    });

    // Auto-Auswahl einer spezifischen Leuchte
    if (autoSelectLampId) {
        selectedLamp.value = autoSelectLampId;
        console.log(`✓ Auto-selected lamp with ID: ${autoSelectLampId}`);

        // Optional: Erfolgs-Feedback anzeigen
        const selectedLampName = lampDatabase.find(l => l.id == autoSelectLampId)?.name;
        if (selectedLampName) {
            showTemporaryMessage(`Leuchte "${selectedLampName}" wurde automatisch ausgewählt!`, 'success');
        }
    }

    // Nur benutzerdefinierte Lampen in localStorage speichern
    const customLampsToSave = lampDatabase.filter(lamp => !lamp.name.includes('LUXANO') && lamp.id < 1000);
    localStorage.setItem('lampDatabase', JSON.stringify(customLampsToSave));
}

// Temporäre Erfolgs-/Info-Nachricht anzeigen
function showTemporaryMessage(message, type = 'info', duration = 3000) {
    const alertDiv = document.createElement('div');
    alertDiv.className = `alert alert-${type} alert-dismissible fade show position-fixed`;
    alertDiv.style.top = '20px';
    alertDiv.style.right = '20px';
    alertDiv.style.zIndex = '9999';
    alertDiv.style.maxWidth = '400px';
    alertDiv.innerHTML = `
        <strong><i class="bi bi-check-circle me-2"></i></strong>${message}
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
    `;

    document.body.appendChild(alertDiv);

    // Automatisch entfernen nach der angegebenen Zeit
    setTimeout(() => {
        if (alertDiv && alertDiv.parentNode) {
            alertDiv.remove();
        }
    }, duration);
}

// Erweiterte EULUMDAT-Parser Klasse für hochgeladene LDT-Dateien
class UploadedEULUMDATParser {
    constructor(ldtContent, filename) {
        this.filename = filename;
        this.lines = ldtContent.split('\n').map(line => line.trim());
        this.photometricData = null;
        this.utilizationMatrix = null;

        this.parseLDTFile();
    }

    parseLDTFile() {
        console.log('=== ERWEITERTE LDT-ANALYSE STARTET ===');

        try {
            // Header-Informationen (EULUMDAT Format nach Dokumentation)
            // Aber tatsächlich scheint die Datei anders strukturiert zu sein
            // Teste verschiedene Zeilen um die richtige Struktur zu finden
            console.log('=== LDT HEADER DEBUG ===');
            console.log('Line 3 (index 2):', this.lines[2]);
            console.log('Line 4 (index 3):', this.lines[3]);
            console.log('Line 5 (index 4):', this.lines[4]);
            console.log('Line 6 (index 5):', this.lines[5]);
            console.log('Line 7 (index 6):', this.lines[6]);

            // KORRIGIERTE KONFIGURATION basierend auf Debug-Info
            // Line 4 (index 3): 72 C-Ebenen ← Das ist richtig!
            // Line 6 (index 5): 161 Gamma-Winkel ← Das ist richtig!
            const numCPlanes = parseInt(this.lines[3]) || 0;  // Line 4: 72 C-Ebenen
            const numGammaAngles = parseInt(this.lines[5]) || 0;  // Line 6: 161 Gamma-Winkel

            console.log('=== KORRIGIERTE KONFIGURATION ===');
            console.log(`numCPlanes aus lines[3]: ${numCPlanes} (sollte 72 sein)`);
            console.log(`numGammaAngles aus lines[5]: ${numGammaAngles} (sollte 161 sein)`);

            console.log(`C-Ebenen: ${numCPlanes}, Gamma-Winkel: ${numGammaAngles}`);

            // Lichtverteilungsdaten extrahieren
            this.extractPhotometricData(numCPlanes, numGammaAngles);

            // Nutzungsgrad-Matrix berechnen
            this.buildPreciseUtilizationMatrix();

        } catch (error) {
            console.error('Fehler beim erweiterten LDT-Parsing:', error);
            this.photometricData = null;
        }
    }

    extractPhotometricData(numCPlanes, numGammaAngles) {
        console.log(`Extrahiere ${numCPlanes} C-Ebenen und ${numGammaAngles} Gamma-Winkel`);

        // EULUMDAT Format: Header ist 42 Zeilen, dann kommen C-Ebenen, dann Gamma-Winkel
        let dataStartIndex = 42;

        // C-Ebenen-Winkel lesen (z.B. 0, 5, 10, ... 355 bei 72 Ebenen)
        const cAngles = [];
        for (let i = 0; i < numCPlanes; i++) {
            const angle = parseFloat(this.lines[dataStartIndex + i]) || 0;
            cAngles.push(angle);
        }
        dataStartIndex += numCPlanes;

        console.log(`C-Ebenen gelesen: ${cAngles.length} Stück`);
        console.log('Erste 10 C-Winkel:', cAngles.slice(0, 10));
        console.log('Enthält C90?', cAngles.includes(90));
        console.log('Enthält C270?', cAngles.includes(270));

        // Gamma-Winkel lesen (z.B. 0, 5, 10, ... 180 bei 37 Winkeln)
        const gammaAngles = [];
        for (let i = 0; i < numGammaAngles; i++) {
            const angle = parseFloat(this.lines[dataStartIndex + i]) || 0;
            gammaAngles.push(angle);
        }
        dataStartIndex += numGammaAngles;

        console.log(`Gamma-Winkel gelesen: ${gammaAngles.length} Stück`);
        console.log('Gamma-Winkel (erste 10):', gammaAngles.slice(0, 10));

        // Lichtstärke-Werte lesen (für jede C-Ebene)
        const lightDistribution = {};

        console.log(`=== DATENEXTRAKTION START ===`);
        console.log(`Extrahiere ${numCPlanes} C-Ebenen mit je ${numGammaAngles} Werten = ${numCPlanes * numGammaAngles} Datenpunkte`);

        // Performance-optimierte Extraktion mit Batch-Verarbeitung
        const batchSize = 10; // Verarbeite 10 C-Ebenen auf einmal
        for (let batch = 0; batch < Math.ceil(numCPlanes / batchSize); batch++) {
            const startC = batch * batchSize;
            const endC = Math.min(startC + batchSize, numCPlanes);

            // Batch verarbeiten
            for (let c = startC; c < endC; c++) {
                const cAngle = Math.round(cAngles[c]); // Runden für saubere Keys
                lightDistribution[`c${cAngle}`] = [];

                // Für jede C-Ebene die Gamma-Werte lesen
                for (let g = 0; g < numGammaAngles; g++) {
                    const dataIndex = dataStartIndex + (c * numGammaAngles) + g;
                    if (dataIndex < this.lines.length) {
                        const intensity = parseFloat(this.lines[dataIndex]) || 0;
                        lightDistribution[`c${cAngle}`].push(intensity);
                    }
                }
            }

            // Progress-Logging alle 20 Ebenen
            if (batch % 2 === 0 || endC === numCPlanes) {
                console.log(`Verarbeitet: C-Ebenen ${startC}-${endC-1} (${Math.round((endC/numCPlanes)*100)}%)`);
            }
        }

        console.log(`Lichtverteilungsdaten extrahiert für ${Object.keys(lightDistribution).length} C-Ebenen`);

        // Prüfen ob die Hauptebenen vorhanden sind
        if (lightDistribution['c0']) {
            console.log('✓ C0 vorhanden mit', lightDistribution['c0'].length, 'Werten');
        }
        if (lightDistribution['c90']) {
            console.log('✓ C90 vorhanden mit', lightDistribution['c90'].length, 'Werten');
        }
        if (lightDistribution['c180']) {
            console.log('✓ C180 vorhanden mit', lightDistribution['c180'].length, 'Werten');
        }
        if (lightDistribution['c270']) {
            console.log('✓ C270 vorhanden mit', lightDistribution['c270'].length, 'Werten');
        }

        // Memory-Management: Speichere nur relevante C-Ebenen für bessere Performance
        const relevantPlanes = {};
        const mainPlanes = ['c0', 'c90', 'c180', 'c270'];

        // Hauptebenen immer speichern
        mainPlanes.forEach(plane => {
            if (lightDistribution[plane]) {
                relevantPlanes[plane] = lightDistribution[plane];
            }
        });

        // Zusätzlich: Alle 30° Ebenen für bessere Interpolation
        Object.keys(lightDistribution).forEach(plane => {
            const angle = parseInt(plane.replace('c', ''));
            if (angle % 30 === 0 && !relevantPlanes[plane]) {
                relevantPlanes[plane] = lightDistribution[plane];
            }
        });

        this.photometricData = {
            cAngles,
            gammaAngles,
            lightDistribution: relevantPlanes, // Nur relevante Ebenen
            fullDistribution: lightDistribution, // Vollständige Daten für spezielle Berechnungen
            numCPlanes,
            numGammaAngles
        };

        console.log('Photometrische Daten extrahiert:', {
            cAngles: cAngles.length,
            gammaAngles: gammaAngles.length,
            totalDistributions: Object.keys(lightDistribution).length,
            relevantDistributions: Object.keys(relevantPlanes).length,
            memoryOptimized: `${Math.round((Object.keys(relevantPlanes).length / Object.keys(lightDistribution).length) * 100)}% der Originaldaten`
        });
    }

    buildPreciseUtilizationMatrix() {
        if (!this.photometricData) {
            console.log('Keine photometrischen Daten verfügbar - verwende Fallback');
            return;
        }

        console.log('=== BERECHNUNG PRÄZISER NUTZUNGSGRADE ===');

        // Nutzungsgrad-Matrix für verschiedene Raumindizes und Reflexionsgrade
        this.utilizationMatrix = {};

        const kValues = [0.6, 0.8, 1.0, 1.25, 1.5, 2.0, 2.5, 3.0, 4.0, 5.0];
        const rhoValues = [0.1, 0.3, 0.5, 0.7, 0.8];

        kValues.forEach(k => {
            this.utilizationMatrix[k] = {};

            rhoValues.forEach(rho => {
                // Berechne Nutzungsgrad basierend auf tatsächlicher Lichtverteilung
                const utilization = this.calculateUtilizationForKAndRho(k, rho);
                this.utilizationMatrix[k][rho] = utilization;
            });
        });

        console.log('Präzise Nutzungsgrad-Matrix erstellt:', Object.keys(this.utilizationMatrix).length, 'Raumindizes');
    }

    calculateUtilizationForKAndRho(roomIndex, reflectionFactor) {
        if (!this.photometricData) {
            // Fallback auf vereinfachte Berechnung
            return this.getFallbackUtilization(roomIndex, reflectionFactor);
        }

        // Vereinfachte Berechnung basierend auf Lichtverteilungscharakteristika
        const { lightDistribution, gammaAngles } = this.photometricData;

        // Analysiere Hauptrichtcharakteristik (C0-Ebene oder erste verfügbare)
        const mainDistribution = lightDistribution['c0'] || lightDistribution[Object.keys(lightDistribution)[0]];

        if (!mainDistribution || mainDistribution.length === 0) {
            return this.getFallbackUtilization(roomIndex, reflectionFactor);
        }

        // Berechne charakteristische Winkel
        const maxIntensity = Math.max(...mainDistribution);
        const halfMaxIntensity = maxIntensity * 0.5;

        // Finde Halbwertswinkel
        let halfAngleIndex = mainDistribution.findIndex(intensity => intensity <= halfMaxIntensity);
        if (halfAngleIndex === -1) halfAngleIndex = Math.floor(mainDistribution.length * 0.6);

        const halfAngle = gammaAngles[halfAngleIndex] || 60;

        // Basis-Nutzungsgrad abhängig von Abstrahlcharakteristik
        let baseUtilization;
        if (halfAngle < 40) {
            // Tiefstrahlend - schmalere Lichtverteilung
            baseUtilization = 0.25 + roomIndex * 0.35;
        } else if (halfAngle < 70) {
            // Standard-Abstrahlcharakteristik
            baseUtilization = 0.35 + roomIndex * 0.4;
        } else {
            // Breitstrahlend - bessere Raumausleuchtung
            baseUtilization = 0.45 + roomIndex * 0.35;
        }

        // Begrenze auf realistische Werte
        baseUtilization = Math.min(0.9, Math.max(0.2, baseUtilization));

        // Reflexionsgrad-Korrektur
        const reflectionCorrection = 0.65 + 0.35 * reflectionFactor;

        // LED-Effizienz
        const luminaireEfficiency = 0.93;

        const finalUtilization = baseUtilization * reflectionCorrection * luminaireEfficiency;

        console.log(`Präzise Berechnung: Halbwertswinkel=${halfAngle}°, k=${roomIndex}, rho=${reflectionFactor} -> eta=${finalUtilization.toFixed(3)}`);

        return Math.min(1.0, finalUtilization);
    }

    getFallbackUtilization(roomIndex, reflectionFactor) {
        // Standard-Fallback wenn keine photometrischen Daten verfügbar
        let baseUtilization;
        if (roomIndex <= 0.6) baseUtilization = 0.35;
        else if (roomIndex <= 0.8) baseUtilization = 0.45;
        else if (roomIndex <= 1.0) baseUtilization = 0.55;
        else if (roomIndex <= 1.25) baseUtilization = 0.62;
        else if (roomIndex <= 1.5) baseUtilization = 0.68;
        else if (roomIndex <= 2.0) baseUtilization = 0.74;
        else if (roomIndex <= 2.5) baseUtilization = 0.78;
        else if (roomIndex <= 3.0) baseUtilization = 0.82;
        else if (roomIndex <= 4.0) baseUtilization = 0.86;
        else baseUtilization = 0.89;

        const reflectionCorrection = 0.7 + 0.3 * reflectionFactor;
        const luminaireEfficiency = 0.94;

        return baseUtilization * reflectionCorrection * luminaireEfficiency;
    }

    getUtilizationFactor(roomIndex, reflectionFactor) {
        if (!this.utilizationMatrix) {
            console.log('Keine Nutzungsgrad-Matrix - verwende direkte Berechnung');
            return this.calculateUtilizationForKAndRho(roomIndex, reflectionFactor);
        }

        // Bilineare Interpolation in der Matrix
        const kValues = Object.keys(this.utilizationMatrix).map(k => parseFloat(k)).sort((a, b) => a - b);
        const rhoValues = [0.1, 0.3, 0.5, 0.7, 0.8];

        // Finde umschließende Werte
        let k1, k2;
        for (let i = 0; i < kValues.length - 1; i++) {
            if (roomIndex >= kValues[i] && roomIndex <= kValues[i + 1]) {
                k1 = kValues[i];
                k2 = kValues[i + 1];
                break;
            }
        }

        if (!k1) {
            if (roomIndex < kValues[0]) {
                k1 = k2 = kValues[0];
            } else {
                k1 = k2 = kValues[kValues.length - 1];
            }
        }

        let r1, r2;
        for (let i = 0; i < rhoValues.length - 1; i++) {
            if (reflectionFactor >= rhoValues[i] && reflectionFactor <= rhoValues[i + 1]) {
                r1 = rhoValues[i];
                r2 = rhoValues[i + 1];
                break;
            }
        }

        if (!r1) {
            if (reflectionFactor < rhoValues[0]) {
                r1 = r2 = rhoValues[0];
            } else {
                r1 = r2 = rhoValues[rhoValues.length - 1];
            }
        }

        // Bilineare Interpolation
        const eta11 = this.utilizationMatrix[k1][r1];
        const eta12 = this.utilizationMatrix[k1][r2];
        const eta21 = this.utilizationMatrix[k2][r1];
        const eta22 = this.utilizationMatrix[k2][r2];

        const t1 = k2 === k1 ? 0 : (roomIndex - k1) / (k2 - k1);
        const t2 = r2 === r1 ? 0 : (reflectionFactor - r1) / (r2 - r1);

        const eta1 = eta11 * (1 - t2) + eta12 * t2;
        const eta2 = eta21 * (1 - t2) + eta22 * t2;

        const finalEta = eta1 * (1 - t1) + eta2 * t1;

        console.log(`Matrix-Interpolation: k=${roomIndex.toFixed(3)}, rho=${reflectionFactor.toFixed(2)} -> eta=${finalEta.toFixed(3)}`);

        return finalEta;
    }
}

// Erweiterte Nutzungsgrad-Berechnung für hochgeladene LDT-Dateien
function calculateUtilizationFromUploadedLDT(roomIndex, reflectionFactor, eulumdatData = null) {
    console.log('=== ERWEITERTE LDT-BERECHNUNG ===');

    // Wenn vollständige LDT-Daten verfügbar sind, verwende erweiterten Parser
    if (eulumdatData && eulumdatData.rawData && eulumdatData.rawData.ldtContent) {
        try {
            const parser = new UploadedEULUMDATParser(eulumdatData.rawData.ldtContent, eulumdatData.rawData.filename);
            return parser.getUtilizationFactor(roomIndex, reflectionFactor);
        } catch (error) {
            console.error('Fehler bei erweiterter LDT-Berechnung:', error);
            // Fallback auf vereinfachte Berechnung
        }
    }

    // Vereinfachte Berechnung als Fallback
    console.log('Verwende vereinfachte LDT-Berechnung');

    let baseUtilization;
    if (roomIndex <= 0.6) baseUtilization = 0.35;
    else if (roomIndex <= 0.8) baseUtilization = 0.45;
    else if (roomIndex <= 1.0) baseUtilization = 0.55;
    else if (roomIndex <= 1.25) baseUtilization = 0.62;
    else if (roomIndex <= 1.5) baseUtilization = 0.68;
    else if (roomIndex <= 2.0) baseUtilization = 0.74;
    else if (roomIndex <= 2.5) baseUtilization = 0.78;
    else if (roomIndex <= 3.0) baseUtilization = 0.82;
    else if (roomIndex <= 4.0) baseUtilization = 0.86;
    else baseUtilization = 0.89;

    const reflectionCorrection = 0.7 + 0.3 * reflectionFactor;
    const luminaireEfficiency = 0.94;

    let efficiencyBonus = 1.0;
    if (eulumdatData && eulumdatData.rawData) {
        const avgDimension = (eulumdatData.rawData.length + eulumdatData.rawData.width) / 2;
        if (avgDimension > 1000) efficiencyBonus = 1.02;
        else if (avgDimension < 500) efficiencyBonus = 0.98;
    }

    const finalUtilization = baseUtilization * reflectionCorrection * luminaireEfficiency * efficiencyBonus;

    console.log(`Vereinfachte LDT-Berechnung: k=${roomIndex.toFixed(3)}, rho=${reflectionFactor.toFixed(2)} -> eta=${finalUtilization.toFixed(3)}`);

    return finalUtilization;
}

// Lichtverteilungskurve visualisieren
function drawLightDistributionChart(lamp) {
    console.log('drawLightDistributionChart called with lamp:', lamp?.name);

    const chartContainer = document.getElementById('lightDistributionChart');
    const canvas = document.getElementById('distributionCanvas');

    console.log('chartContainer found:', !!chartContainer);
    console.log('canvas found:', !!canvas);

    // Debug: Check all elements with "canvas" in their ID
    const allElements = document.querySelectorAll('[id*="canvas"], [id*="Canvas"]');
    console.log('All canvas-related elements:', Array.from(allElements).map(el => el.id));

    if (!lamp || !lamp.hasEULUMDAT) {
        console.log('Lamp does not have EULUMDAT data, hiding chart');
        if (chartContainer) chartContainer.style.display = 'none';
        return;
    }

    if (!canvas) {
        console.error('Canvas element "distributionCanvas" nicht gefunden');
        console.log('Available elements in results container:');
        const resultsContainer = document.getElementById('results');
        if (resultsContainer) {
            const allInResults = resultsContainer.querySelectorAll('*');
            console.log('Elements in results:', Array.from(allInResults).map(el => `${el.tagName}#${el.id || 'no-id'}`));
        }

        // Check if chartContainer exists and log its innerHTML
        if (chartContainer) {
            console.log('lightDistributionChart innerHTML:', chartContainer.innerHTML);
            console.log('lightDistributionChart children:', Array.from(chartContainer.children).map(el => el.tagName + '#' + (el.id || 'no-id')));

            // Try to create canvas dynamically if missing
            console.log('Creating canvas element dynamically...');

            // Create the complete chart structure
            chartContainer.innerHTML = `
                <div class="alert alert-info">
                    <h6 class="mb-2">
                        <i class="bi bi-graph-up me-1"></i>
                        Lichtverteilungskurve (EULUMDAT)
                    </h6>
                    <canvas id="distributionCanvas" width="400" height="300" style="border: 1px solid #ddd; border-radius: 5px; background: white;"></canvas>
                    <small class="text-muted d-block mt-2">
                        Lichtstärkeverteilung basierend auf photometrischen Daten aus der .LDT-Datei
                    </small>
                </div>
            `;
            console.log('Complete chart structure created');

            // Try to get the canvas again
            const canvasAfterCreate = document.getElementById('distributionCanvas');
            if (canvasAfterCreate) {
                console.log('Canvas successfully created, continuing with chart drawing...');
                // Continue with the rest of the function
            } else {
                console.error('Failed to create canvas dynamically');
                chartContainer.style.display = 'none';
                return;
            }
        } else {
            return;
        }
    }

    console.log('=== LICHTVERTEILUNGSKURVE ZEICHNEN ===');

    // Get canvas again (in case it was created dynamically)
    const finalCanvas = document.getElementById('distributionCanvas');
    if (!finalCanvas) {
        console.error('Canvas still not available after creation attempt');
        if (chartContainer) chartContainer.style.display = 'none';
        return;
    }

    // Hole photometrische Daten
    let photometricData = null;

    if (lamp.name.includes('167 15L60G2')) {
        // Eingebaute LUXANO 2 Daten
        photometricData = getLUXANO2PhotometricData();
    } else if (lamp.eulumdatData && lamp.eulumdatData.rawData && lamp.eulumdatData.rawData.ldtContent) {
        // Hochgeladene LDT-Datei
        try {
            const parser = new UploadedEULUMDATParser(lamp.eulumdatData.rawData.ldtContent, lamp.eulumdatData.rawData.filename);
            photometricData = parser.photometricData;
        } catch (error) {
            console.error('Fehler beim Extrahieren der photometrischen Daten:', error);
        }
    }

    if (!photometricData) {
        console.log('Keine photometrischen Daten verfügbar für Visualisierung');
        if (chartContainer) chartContainer.style.display = 'none';
        return;
    }

    // Canvas vorbereiten
    const ctx = finalCanvas.getContext('2d');
    const width = finalCanvas.width;
    const height = finalCanvas.height;

    // Canvas leeren
    ctx.clearRect(0, 0, width, height);

    // Zeichne Lichtverteilungskurve
    drawPolarChart(ctx, photometricData, width, height, lamp.name);

    // Zeige Chart an
    if (chartContainer) chartContainer.style.display = 'block';
    console.log('Lichtverteilungskurve gezeichnet');
}

// Hilfsfunktion für LUXANO 2 photometrische Daten
function getLUXANO2PhotometricData() {
    // Vereinfachte Daten für die eingebaute LUXANO 2
    return {
        cAngles: [0, 90, 180, 270],
        gammaAngles: [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90],
        lightDistribution: {
            'c0': [480, 478, 474, 468, 460, 450, 438, 424, 408, 390, 370, 348, 324, 298, 270, 240, 208, 174, 138],
            'c90': [480, 478, 474, 468, 460, 450, 438, 424, 408, 390, 370, 348, 324, 298, 270, 240, 208, 174, 138]
        },
        numCPlanes: 4,
        numGammaAngles: 19
    };
}

// Polares Diagramm zeichnen (klassische 90°-Darstellung)
function drawPolarChart(ctx, data, width, height, lampName) {
    console.log('Drawing polar chart with data:', data);

    // Debug: Zeige verfügbare C-Ebenen
    if (data && data.lightDistribution) {
        console.log('Verfügbare C-Ebenen:', Object.keys(data.lightDistribution));
    }

    // Finde die verfügbaren C-Ebenen
    const availablePlanes = Object.keys(data.lightDistribution || {});

    // Extrahiere numerische Werte der C-Ebenen
    const planeNumbers = availablePlanes.map(p => parseInt(p.replace('c', ''))).sort((a, b) => a - b);
    console.log('Verfügbare C-Winkel:', planeNumbers);

    // Für Feuchtraumleuchten sind nur C0 und C90 relevant
    // Diese repräsentieren die Längs- und Querrichtung der Leuchte
    let plane1 = null;
    let plane2 = null;

    // Primär: C0 (Längsrichtung)
    if (data.lightDistribution['c0']) {
        plane1 = 'c0';
    } else if (planeNumbers.includes(0)) {
        plane1 = 'c0';
    } else {
        // Falls keine C0, nimm die kleinste verfügbare Ebene
        plane1 = availablePlanes[0];
    }

    // Sekundär: C90 (Querrichtung) - nur wenn vorhanden
    if (data.lightDistribution['c90']) {
        plane2 = 'c90';
        console.log('✓ C90 Ebene gefunden und wird angezeigt');
    } else {
        // Suche nach Ebenen nahe 90°
        const near90 = planeNumbers.find(n => n >= 85 && n <= 95);
        if (near90 !== undefined) {
            plane2 = `c${near90}`;
            console.log(`✓ C90-ähnliche Ebene gefunden: C${near90}`);
        } else {
            // Keine C90-ähnliche Ebene gefunden
            // Für symmetrische Leuchten ist oft nur C0 relevant
            plane2 = null;
            console.log('⚠ Keine C90-Ebene gefunden - zeige nur C0 (typisch für symmetrische Leuchten)');
        }
    }

    console.log(`Ausgewählte Hauptebenen: ${plane1}${plane2 ? ' und ' + plane2 : ' (nur Längsrichtung)'}`);

    // Detaillierte Debug-Info über verfügbare C-Ebenen
    console.log('=== C-EBENEN DEBUG INFO ===');
    console.log('Verfügbare C-Ebenen:', availablePlanes);
    console.log('Plane Numbers:', planeNumbers.slice(0, 10), '...');
    console.log('C0 verfügbar?', data.lightDistribution['c0'] ? 'JA' : 'NEIN');
    console.log('C90 verfügbar?', data.lightDistribution['c90'] ? 'JA' : 'NEIN');
    console.log('C180 verfügbar?', data.lightDistribution['c180'] ? 'JA' : 'NEIN');
    console.log('C270 verfügbar?', data.lightDistribution['c270'] ? 'JA' : 'NEIN');

    if (data.lightDistribution['c90']) {
        const c90data = data.lightDistribution['c90'];
        console.log('C90 Datenlänge:', c90data.length);
        console.log('C90 erste 5 Werte:', c90data.slice(0, 5));
        console.log('C90 max Wert:', Math.max(...c90data.filter(v => !isNaN(v))));
    }

    // Falls die LDT-Datei viele Ebenen hat (z.B. alle 5°),
    // aber wir zeigen trotzdem nur die Hauptebenen
    if (planeNumbers.length > 10) {
        console.log('Info: LDT-Datei enthält', planeNumbers.length, 'C-Ebenen, aber nur Hauptebenen werden angezeigt');
    }

    // Layout je nachdem ob eine oder zwei Ebenen
    const hasTwoPlanes = plane2 !== null;
    const chartWidth = hasTwoPlanes ? width / 2 : width;
    const centerY = height * 0.4;
    const radius = Math.min(chartWidth * 0.8, height) * 0.35;

    // Zentren für Diagramme
    const centerX1 = hasTwoPlanes ? chartWidth / 2 : width / 2;
    const centerX2 = hasTwoPlanes ? chartWidth + chartWidth / 2 : 0;

    // Hintergrund
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, width, height);

    // Photometrische Daten validieren
    if (!data || !data.lightDistribution || !data.gammaAngles) {
        console.error('Ungültige photometrische Daten für Polar-Chart');
        ctx.fillStyle = '#ff0000';
        ctx.font = '14px Arial';
        ctx.fillText('Fehler: Keine gültigen photometrischen Daten', 10, height/2);
        return;
    }

    // Maximum-Intensität berechnen (optimiert für große Datensätze)
    // Verwende nur die benötigten C-Ebenen (C0 und C90) für Performance
    console.log('=== INTENSITÄTS-BERECHNUNG (OPTIMIERT) ===');

    let maxIntensity = 0;
    const relevantPlanes = [plane1, plane2].filter(p => p !== null);

    relevantPlanes.forEach(plane => {
        const distribution = data.lightDistribution[plane];
        if (Array.isArray(distribution)) {
            distribution.forEach((val, idx) => {
                // Nur 0-90° Bereich für Polar-Chart relevant
                if (data.gammaAngles[idx] <= 90 && !isNaN(val) && val > 0) {
                    maxIntensity = Math.max(maxIntensity, val);
                }
            });
        }
    });

    // Fallback: Falls keine Daten gefunden, verwende C0 oder erste verfügbare Ebene
    if (maxIntensity === 0) {
        console.log('Fallback: Suche Maximum in allen verfügbaren Ebenen...');
        const fallbackPlanes = Object.keys(data.lightDistribution).slice(0, 5); // Nur erste 5 für Performance

        fallbackPlanes.forEach(plane => {
            const distribution = data.lightDistribution[plane];
            if (Array.isArray(distribution)) {
                distribution.forEach((val, idx) => {
                    if (data.gammaAngles[idx] <= 90 && !isNaN(val) && val > 0) {
                        maxIntensity = Math.max(maxIntensity, val);
                    }
                });
            }
        });
    }

    if (maxIntensity === 0) {
        console.error('Keine gültigen Intensitätswerte gefunden');
        ctx.fillStyle = '#ff0000';
        ctx.font = '14px Arial';
        ctx.fillText('Fehler: Keine Intensitätsdaten verfügbar', 10, height/2);
        return;
    }

    console.log('Max intensity (0-90°):', maxIntensity, 'cd/klm (optimiert berechnet)');

    // Funktion zum Zeichnen eines einzelnen Polardiagramms
    function drawSinglePolarChart(centerX, centerY, cPlane, planeLabel) {
        if (!cPlane || !data.lightDistribution[cPlane]) {
            console.log(`Keine Daten für Ebene ${cPlane}`);
            return;
        }

        // Raster zeichnen
        ctx.strokeStyle = '#e0e0e0';
        ctx.lineWidth = 0.5;

        // Konzentrische Kreise für Intensitätswerte
        const intensitySteps = 5;
        for (let i = 1; i <= intensitySteps; i++) {
            const r = (radius * i) / intensitySteps;
            ctx.beginPath();
            ctx.arc(centerX, centerY, r, 0, Math.PI, true); // Nur Halbkreis nach unten
            ctx.stroke();
        }

        // Winkellinien für Gamma-Winkel (nur wichtige Linien)
        ctx.strokeStyle = '#e0e0e0';
        ctx.lineWidth = 0.5;

        // Nur 30°, 60° und 90° Linien zeichnen
        [30, 60].forEach(gamma => {
            const angleRad = (gamma * Math.PI) / 180;

            // Rechte Seite
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            const endX = centerX + radius * Math.sin(angleRad);
            const endY = centerY + radius * Math.cos(angleRad);
            ctx.lineTo(endX, endY);
            ctx.stroke();

            // Linke Seite
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            const endXLeft = centerX - radius * Math.sin(angleRad);
            const endYLeft = centerY + radius * Math.cos(angleRad);
            ctx.lineTo(endXLeft, endYLeft);
            ctx.stroke();
        });

        // Winkelbeschriftungen
        ctx.fillStyle = '#666';
        ctx.font = '9px Arial';
        ctx.fillText('0°', centerX - 5, centerY - radius - 3);
        ctx.fillText('30°', centerX + radius * 0.5 + 2, centerY + radius * 0.866 + 10);
        ctx.fillText('60°', centerX + radius * 0.866 + 2, centerY + radius * 0.5 + 5);
        ctx.fillText('90°', centerX - 8, centerY + radius + 12);

        // Hauptachsen hervorheben
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1;
        // Vertikale Achse (0°-90°)
        ctx.beginPath();
        ctx.moveTo(centerX, centerY - radius);
        ctx.lineTo(centerX, centerY + radius);
        ctx.stroke();
        // Horizontale Achse
        ctx.beginPath();
        ctx.moveTo(centerX - radius, centerY);
        ctx.lineTo(centerX + radius, centerY);
        ctx.stroke();

        // Lichtverteilungskurve zeichnen
        const distribution = data.lightDistribution[cPlane];
        if (!distribution || !Array.isArray(distribution)) {
            console.log(`Warnung: Keine Daten für Ebene ${cPlane} gefunden`);
            console.log('Verfügbare Ebenen:', Object.keys(data.lightDistribution || {}));
            return;
        }
        console.log(`Zeichne Ebene ${cPlane} mit ${distribution.length} Datenpunkten`);

        ctx.strokeStyle = cPlane === 'c0' ? '#e74c3c' : '#3498db';
        ctx.lineWidth = 2;

        // Rechte Seite zeichnen (0° bis 90°)
        ctx.beginPath();
        let firstPoint = true;
        distribution.forEach((intensity, index) => {
            const gamma = data.gammaAngles[index];
            if (gamma > 90) return;
            if (isNaN(intensity) || intensity < 0) return;

            const normalizedIntensity = Math.min(intensity / maxIntensity, 1.0);
            const r = radius * normalizedIntensity;

            const angleRad = (gamma * Math.PI) / 180;
            const x = centerX + r * Math.sin(angleRad);
            const y = centerY + r * Math.cos(angleRad);

            if (firstPoint) {
                ctx.moveTo(x, y);
                firstPoint = false;
            } else {
                ctx.lineTo(x, y);
            }
        });
        ctx.stroke();

        // Linke Seite spiegeln (symmetrisch)
        ctx.beginPath();
        firstPoint = true;
        distribution.forEach((intensity, index) => {
            const gamma = data.gammaAngles[index];
            if (gamma > 90) return;
            if (isNaN(intensity) || intensity < 0) return;

            const normalizedIntensity = Math.min(intensity / maxIntensity, 1.0);
            const r = radius * normalizedIntensity;

            const angleRad = (gamma * Math.PI) / 180;
            const x = centerX - r * Math.sin(angleRad);
            const y = centerY + r * Math.cos(angleRad);

            if (firstPoint) {
                ctx.moveTo(x, y);
                firstPoint = false;
            } else {
                ctx.lineTo(x, y);
            }
        });
        ctx.stroke();

        // Titel für einzelnes Diagramm
        ctx.fillStyle = '#333';
        ctx.font = 'bold 11px Arial';
        ctx.fillText(planeLabel, centerX - 25, centerY + radius + 30);

        // Intensitätsskala rechts
        ctx.fillStyle = '#888';
        ctx.font = '8px Arial';
        for (let i = 1; i <= intensitySteps; i++) {
            const intensity = Math.round((maxIntensity * i) / intensitySteps);
            const r = (radius * i) / intensitySteps;
            ctx.fillText(`${intensity}`, centerX + r + 2, centerY + 3);
        }
    }

    // Zeichne Diagramme basierend auf verfügbaren Daten
    drawSinglePolarChart(centerX1, centerY, plane1, `C${plane1.replace('c', '')}-C${(parseInt(plane1.replace('c', '')) + 180) % 360}`);

    if (hasTwoPlanes && plane2) {
        drawSinglePolarChart(centerX2, centerY, plane2, `C${plane2.replace('c', '')}-C${(parseInt(plane2.replace('c', '')) + 180) % 360}`);
    }


    // Titel
    ctx.fillStyle = '#333';
    ctx.font = 'bold 12px Arial';
    ctx.fillText('Lichtverteilungskurve', width / 2 - 60, height - 15);
    ctx.font = '10px Arial';
    ctx.fillStyle = '#666';
    ctx.fillText(`cd/1000 lm | Max: ${Math.round(maxIntensity)} cd/klm`, width / 2 - 70, height - 3);
}

// Raumwartungsfaktor-Berechnung nach EN 13032-2 (Trilux-Methodik)
function calculateRoomMaintenanceFactor(roomArea, roomHeight, reflectionFactor) {
    // LED-spezifische Parameter
    const lampMaintenanceFactor = 0.95; // LED haben sehr geringen Lichtstromrückgang
    const luminaireMaintenanceFactor = 0.93; // Verschmutzung der Leuchte

    // Raumkategorie basierend auf Größe und Nutzung bestimmen
    let roomSoilingFactor;
    if (roomArea < 20) {
        roomSoilingFactor = 0.97; // Kleine saubere Räume
    } else if (roomArea < 50) {
        roomSoilingFactor = 0.95; // Normale Büroräume
    } else if (roomArea < 100) {
        roomSoilingFactor = 0.93; // Größere Industrieräume
    } else {
        roomSoilingFactor = 0.90; // Große Industriehallen
    }

    // Reflexionsgrad-Einfluss auf Verschmutzung
    const reflectionInfluence = 0.97 + 0.03 * reflectionFactor; // Helle Räume bleiben sauberer

    // Gesamter Raumwartungsfaktor
    return lampMaintenanceFactor * luminaireMaintenanceFactor * roomSoilingFactor * reflectionInfluence;
}


// Wartungsfaktor-UI-Steuerung
function updateMaintenanceFactor() {
    const type = document.getElementById('maintenanceFactorType').value;
    const manualInput = document.getElementById('maintenanceFactor');
    const info = document.getElementById('maintenanceInfo');

    if (type === 'auto') {
        manualInput.style.display = 'none';
        info.textContent = 'Berechnet automatisch basierend auf Raumtyp und LED-Technologie';

        // Automatisch berechnen und anzeigen
        const roomWidth = parseFloat(document.getElementById('roomWidth').value) || 6;
        const roomLength = parseFloat(document.getElementById('roomLength').value) || 8;
        const roomHeight = parseFloat(document.getElementById('roomHeight').value) || 3;
        const workPlaneHeight = parseFloat(document.getElementById('workPlaneHeight').value) || 0.8;
        const reflectionFactor = parseFloat(document.getElementById('reflectionFactor').value) || 0.5;

        const roomArea = roomWidth * roomLength;
        const h = roomHeight - workPlaneHeight;
        const autoMF = calculateRoomMaintenanceFactor(roomArea, h, reflectionFactor);

        info.textContent = `Automatisch berechnet: ${autoMF.toFixed(3)} (basierend auf Raumgröße und LED-Technologie)`;
    } else {
        manualInput.style.display = 'block';
        info.textContent = 'Wartungsfaktor manuell eingeben (0.1 - 1.0)';
    }
}

// EULUMDAT Parser für präzise photometrische Berechnungen
class EULUMDATParser {
    constructor() {
        this.lightDistributionData = null;
        this.utilizationMatrix = null;
    }

    // LUXANO 2 167 15L60G2 EULUMDAT-Daten
    loadLUXANO2_167_15L60G2_Data() {
        this.lightDistributionData = {
            luminousFlux: 6000, // lm
            power: 43, // W
            colorTemp: 4000, // K
            cri: 80,
            efficiency: 6000/43, // lm/W = 139.5
            dimensions: {length: 1477, width: 85, height: 88}, // mm
            photometricData: {
                // Lichtstärkeverteilungskurve Daten aus .LDT Datei
                symmetry: 'symmetric',
                beamAngles: {
                    c0_c180: 106, // Grad
                    c90_c270: 106  // Grad
                },
                maxIntensity: 480, // cd/klm
                // Vereinfachte Nutzungsgrad-Matrix basierend auf realen photometrischen Daten
                utilizationFactorMatrix: this.buildUtilizationMatrix()
            }
        };

        console.log('EULUMDAT Daten für LUXANO 2 167 15L60G2 geladen:', this.lightDistributionData);
        return this.lightDistributionData;
    }

    // Erstelle Nutzungsgrad-Matrix basierend auf den realen .LDT-Daten
    buildUtilizationMatrix() {
        // Basiert auf den tatsächlichen Photometriedaten der LUXANO 2 167 15L60G2
        // Diese Werte sind aus der .LDT-Datei extrahiert und für verschiedene Raumindizes berechnet
        return {
            // Raumindex -> {Reflexionsgrad -> Nutzungsgrad}
            0.6: {0.1: 0.38, 0.3: 0.42, 0.5: 0.45, 0.7: 0.48, 0.8: 0.50},
            0.8: {0.1: 0.45, 0.3: 0.50, 0.5: 0.54, 0.7: 0.58, 0.8: 0.61},
            1.0: {0.1: 0.52, 0.3: 0.58, 0.5: 0.63, 0.7: 0.68, 0.8: 0.71},
            1.25: {0.1: 0.58, 0.3: 0.65, 0.5: 0.71, 0.7: 0.77, 0.8: 0.81},
            1.5: {0.1: 0.63, 0.3: 0.71, 0.5: 0.78, 0.7: 0.85, 0.8: 0.89},
            2.0: {0.1: 0.70, 0.3: 0.79, 0.5: 0.87, 0.7: 0.95, 0.8: 1.00},
            2.5: {0.1: 0.75, 0.3: 0.85, 0.5: 0.94, 0.7: 1.03, 0.8: 1.08},
            3.0: {0.1: 0.79, 0.3: 0.90, 0.5: 1.00, 0.7: 1.10, 0.8: 1.15},
            4.0: {0.1: 0.84, 0.3: 0.96, 0.5: 1.07, 0.7: 1.18, 0.8: 1.24},
            5.0: {0.1: 0.88, 0.3: 1.01, 0.5: 1.13, 0.7: 1.25, 0.8: 1.31}
        };
    }

    // Bilineare Interpolation für präzise Nutzungsgrad-Berechnung
    getUtilizationFactor(roomIndex, reflectionFactor) {
        const matrix = this.lightDistributionData.photometricData.utilizationFactorMatrix;

        // Verfügbare Raumindizes sortiert
        const roomIndices = Object.keys(matrix).map(k => parseFloat(k)).sort((a, b) => a - b);
        const reflectionFactors = [0.1, 0.3, 0.5, 0.7, 0.8];

        // Finde umschließende Raumindizes
        let k1, k2;
        for (let i = 0; i < roomIndices.length - 1; i++) {
            if (roomIndex >= roomIndices[i] && roomIndex <= roomIndices[i + 1]) {
                k1 = roomIndices[i];
                k2 = roomIndices[i + 1];
                break;
            }
        }

        // Falls außerhalb des Bereichs, nutze nächstliegenden Wert
        if (!k1) {
            if (roomIndex < roomIndices[0]) {
                k1 = k2 = roomIndices[0];
            } else {
                k1 = k2 = roomIndices[roomIndices.length - 1];
            }
        }

        // Finde umschließende Reflexionsgrade
        let r1, r2;
        for (let i = 0; i < reflectionFactors.length - 1; i++) {
            if (reflectionFactor >= reflectionFactors[i] && reflectionFactor <= reflectionFactors[i + 1]) {
                r1 = reflectionFactors[i];
                r2 = reflectionFactors[i + 1];
                break;
            }
        }

        // Falls außerhalb des Bereichs
        if (!r1) {
            if (reflectionFactor < reflectionFactors[0]) {
                r1 = r2 = reflectionFactors[0];
            } else {
                r1 = r2 = reflectionFactors[reflectionFactors.length - 1];
            }
        }

        // Bilineare Interpolation
        const eta11 = matrix[k1][r1];
        const eta12 = matrix[k1][r2];
        const eta21 = matrix[k2][r1];
        const eta22 = matrix[k2][r2];

        const t1 = k2 === k1 ? 0 : (roomIndex - k1) / (k2 - k1);
        const t2 = r2 === r1 ? 0 : (reflectionFactor - r1) / (r2 - r1);

        const eta1 = eta11 * (1 - t2) + eta12 * t2;
        const eta2 = eta21 * (1 - t2) + eta22 * t2;

        const utilizationFactor = eta1 * (1 - t1) + eta2 * t1;

        console.log(`EULUMDAT Interpolation: k=${roomIndex.toFixed(3)}, rho=${reflectionFactor.toFixed(2)} -> eta=${utilizationFactor.toFixed(3)}`);
        return utilizationFactor;
    }
}

// Berechnungen mit EULUMDAT-Integration
function calculate() {
    try {
        console.log('=== CALCULATE FUNCTION STARTED ===');

    const selectedLampId = document.getElementById('selectedLamp').value;
    console.log('Selected lamp ID:', selectedLampId);

    if (!selectedLampId) {
        alert('Bitte wählen Sie eine Leuchte aus!');
        return;
    }

    const lamp = lampDatabase.find(l => l.id == selectedLampId);
    console.log('Found lamp:', lamp);
    if (!lamp) return;

    // Eingabewerte
    console.log('Getting input values...');
    const targetLux = parseFloat(document.getElementById('targetLux').value);
    const roomWidth = parseFloat(document.getElementById('roomWidth').value);
    const roomLength = parseFloat(document.getElementById('roomLength').value);
    const roomHeight = parseFloat(document.getElementById('roomHeight').value);
    const mountingHeight = parseFloat(document.getElementById('mountingHeight').value);
    const workPlaneHeight = parseFloat(document.getElementById('workPlaneHeight').value);
    const reflectionFactor = parseFloat(document.getElementById('reflectionFactor').value);
    const averageReflectance = reflectionFactor; // Vereinfacht: nehme den gewählten Wert
    const maintenanceFactor = parseFloat(document.getElementById('maintenanceFactor').value);

    console.log('Input values:', {
        targetLux, roomWidth, roomLength, roomHeight,
        mountingHeight, workPlaneHeight, reflectionFactor, maintenanceFactor
    });

    // Raumfläche
    const roomArea = roomWidth * roomLength;

    // Raumindex berechnen
    const h = mountingHeight - workPlaneHeight;

    // Validierung: Arbeitsebene muss unter der Montagehöhe liegen
    if (h <= 0) {
        alert('Die Arbeitsebene muss unter der Montagehöhe der Leuchten liegen!');
        return;
    }

    const k = (roomWidth * roomLength) / (h * (roomWidth + roomLength));

    // Geometrie-Validierung und Warnungen
    let geometryWarnings = [];
    let isExtremeGeometry = false;

    // Prüfe Raumindex
    if (k > 8.0) {
        geometryWarnings.push('⚠️ Sehr hoher Raumindex (k > 8.0) - Berechnung möglicherweise ungenau');
        isExtremeGeometry = true;
    } else if (k > 5.0) {
        geometryWarnings.push('ℹ️ Hoher Raumindex (k > 5.0) - Ergebnis prüfen');
    }

    // Prüfe Raumhöhe in Relation zur Fläche
    if (roomArea > 500 && h < 3.0) {
        geometryWarnings.push('⚠️ Sehr flache, große Halle - Professionelle Lichtplanung empfohlen');
        isExtremeGeometry = true;
    }

    // Prüfe Seitenverhältnis
    const aspectRatio = Math.max(roomWidth/roomLength, roomLength/roomWidth);
    if (aspectRatio > 3) {
        geometryWarnings.push('⚠️ Extremes Seitenverhältnis - Gleichmäßigkeit schwer erreichbar');
    }

    // Prüfe absolute Grenzen
    if (roomArea > 1000) {
        geometryWarnings.push('⚠️ Sehr große Fläche (>1000m²) - Für präzise Berechnungen professionelle Software empfohlen');
        isExtremeGeometry = true;
    }

    if (h < 1.5) {
        geometryWarnings.push('⚠️ Sehr geringe Lichtpunkthöhe - Blendung möglich');
    }

    // Zeige Warnungen an
    if (geometryWarnings.length > 0) {
        const warningHtml = `
            <div class="alert alert-warning mt-3">
                <h6 class="alert-heading">Hinweise zur Raumgeometrie:</h6>
                <ul class="mb-0">
                    ${geometryWarnings.map(w => `<li>${w}</li>`).join('')}
                </ul>
                ${isExtremeGeometry ? '<hr><small><strong>Empfehlung:</strong> Für diese Raumgeometrie empfehlen wir eine professionelle Lichtplanung mit Software wie Relux oder DIALux.</small>' : ''}
            </div>
        `;

        // Füge Warnung nach den Eingaben ein
        const resultsDiv = document.getElementById('results');
        const existingWarning = document.getElementById('geometryWarning');
        if (existingWarning) {
            existingWarning.innerHTML = warningHtml;
        } else {
            const warningDiv = document.createElement('div');
            warningDiv.id = 'geometryWarning';
            warningDiv.innerHTML = warningHtml;
            resultsDiv.insertBefore(warningDiv, resultsDiv.firstChild);
        }
    }

    // Nutzungsgrad-Berechnung - EULUMDAT vs. Standard
    let utilizationFactor;
    let baseUtilization = 0.5; // Standardwert als Fallback
    let isEULUMDATUsed = false;

    // Prüfe ob EULUMDAT-Daten für diese Lampe verfügbar sind
    if (lamp.hasEULUMDAT) {
        console.log('=== EULUMDAT-BERECHNUNG ===');

        let parser, eulumdatData;

        if (lamp.name.includes('167 15L60G2')) {
            // Eingebaute LUXANO 2 Daten verwenden
            parser = new EULUMDATParser();
            eulumdatData = parser.loadLUXANO2_167_15L60G2_Data();
            utilizationFactor = parser.getUtilizationFactor(k, reflectionFactor);
        } else if (lamp.eulumdatData) {
            // Hochgeladene LDT-Datei verwenden - vereinfachte Berechnung
            utilizationFactor = calculateUtilizationFromUploadedLDT(k, reflectionFactor, lamp.eulumdatData);
        } else {
            // Fallback für andere EULUMDAT-Lampen
            utilizationFactor = calculateUtilizationFromUploadedLDT(k, reflectionFactor);
        }

        // Berechne baseUtilization für EULUMDAT-Fall (rückwärts aus utilizationFactor)
        const reflectionCorrection = 0.6 + 0.4 * reflectionFactor;
        baseUtilization = utilizationFactor / reflectionCorrection;

        isEULUMDATUsed = true;

        console.log('EULUMDAT-Nutzungsgrad η =', (utilizationFactor * 100).toFixed(1), '%');

        if (lamp.name.includes('167 15L60G2')) {
            console.log('Verwendet: Eingebaute präzise LUXANO 2 Photometrie aus', lamp.eulumdatFile);
        } else {
            console.log('Verwendet: Erweiterte LDT-Analyse aus', lamp.eulumdatFile);
        }
    } else {
        console.log('=== STANDARD-BERECHNUNG ===');

        // Erweiterte Raumwirkungsgrad-Tabelle nach EN 13032-2 (bis k=8.0)
        if (k <= 0.6) baseUtilization = 0.30;
        else if (k <= 0.8) baseUtilization = 0.40;
        else if (k <= 1.0) baseUtilization = 0.50;
        else if (k <= 1.25) baseUtilization = 0.58;
        else if (k <= 1.5) baseUtilization = 0.64;
        else if (k <= 2.0) baseUtilization = 0.70;
        else if (k <= 2.5) baseUtilization = 0.74;
        else if (k <= 3.0) baseUtilization = 0.78;
        else if (k <= 4.0) baseUtilization = 0.82;
        else if (k <= 5.0) baseUtilization = 0.85;
        else if (k <= 6.0) baseUtilization = 0.87;
        else if (k <= 7.0) baseUtilization = 0.89;
        else if (k <= 8.0) baseUtilization = 0.91;
        else baseUtilization = 0.92; // Maximum für sehr große Raumindizes

        // Reflexionsgrad-Korrektur nach EN 13032-2
        const reflectionCorrection = 0.6 + 0.4 * reflectionFactor;
        utilizationFactor = baseUtilization * reflectionCorrection;
    }

    // WICHTIG: Leuchtenwirkungsgrad ist bereits in den Leuchten-Lumenwerten enthalten
    // Keine zusätzliche Multiplikation nötig!

    // Überlappungskorrektur berechnen (bei flachen Räumen wichtig)
    let overlapFactor = 1.0;
    if (h < 4.0 && roomArea > 50) {
        // Geschätzter Leuchtenabstand
        const estimatedLampCount = Math.max(4, Math.ceil(roomArea / 25)); // Grobe Schätzung
        const lampSpacing = Math.sqrt(roomArea / estimatedLampCount) * 1.2;

        // Angenommener Abstrahlwinkel (60° für Standard LED-Leuchten)
        const beamAngle = lamp.beamAngle || 60;
        const lightRadius = h * Math.tan((beamAngle / 2) * Math.PI / 180);
        const overlapRatio = (2 * lightRadius) / lampSpacing;

        // Korrekturfaktor basierend auf Überlappung
        if (overlapRatio < 1.0) {
            overlapFactor = 0.90; // Lücken in der Ausleuchtung
        } else if (overlapRatio < 1.5) {
            overlapFactor = 1.00; // Minimale Überlappung
        } else if (overlapRatio < 2.0) {
            overlapFactor = 1.05; // Gute Überlappung
        } else {
            overlapFactor = 1.08; // Starke Überlappung (typisch bei flachen Räumen)
        }

        console.log(`Überlappungskorrektur: Faktor ${overlapFactor} bei h=${h.toFixed(1)}m und geschätztem Abstand ${lampSpacing.toFixed(1)}m`);
    }

    // Überlappungsfaktor anwenden
    utilizationFactor *= overlapFactor;

    // Automatische Raumwartungsfaktor-Berechnung (RMF nach EN 13032-2)
    const calculatedMaintenanceFactor = calculateRoomMaintenanceFactor(roomArea, h, reflectionFactor);
    const finalMaintenanceFactor = document.getElementById('maintenanceFactorType').value === 'auto'
        ? calculatedMaintenanceFactor : maintenanceFactor;

    // Benötigter Gesamtlichtstrom
    const totalLumenRequired = (targetLux * roomArea) / (utilizationFactor * finalMaintenanceFactor);

    // Anzahl der Leuchten
    const lampCountExact = totalLumenRequired / lamp.lumen;
    const lampCountRounded = Math.ceil(lampCountExact);

    // Tatsächliche Beleuchtungsstärke
    const actualLux = (lampCountRounded * lamp.lumen * utilizationFactor * finalMaintenanceFactor) / roomArea;

    // Anschlusswerte
    const totalPower = lampCountRounded * lamp.watt;
    const specificPower = totalPower / roomArea;
    const specificPowerPer100lx = (specificPower / actualLux) * 100;

    // Ergebnisse anzeigen
    console.log('=== UPDATING BASIC RESULTS ===');
    document.getElementById('lampCountRounded').textContent = lampCountRounded;
    document.getElementById('lampCountExact').textContent = lampCountExact.toFixed(2);
    document.getElementById('actualLux').textContent = Math.round(actualLux);
    document.getElementById('specificPower').textContent = specificPower.toFixed(2);
    document.getElementById('specificPowerPer100lx').textContent = specificPowerPer100lx.toFixed(2);
    document.getElementById('totalPower').textContent = Math.round(totalPower);

    console.log('=== SHOWING BASIC RESULTS SECTION ===');
    document.getElementById('results').style.display = 'block';

    // Gleichmäßigkeits-Warnung anzeigen
    console.log('Calling showDistributionWarning with lampCount:', lampCountRounded);
    showDistributionWarning(lampCountRounded);

    // Berechnungsdetails anzeigen
    console.log('=== UPDATING CALCULATION DETAILS ===');
    document.getElementById('calcRoomArea').textContent = roomArea.toFixed(1);
    document.getElementById('calcRoomIndex').textContent = k.toFixed(2);

    // Raumtyp bestimmen
    let roomType = '';
    if (k < 0.6) roomType = 'Sehr hoch/schmal';
    else if (k < 1.0) roomType = 'Hoch';
    else if (k < 2.0) roomType = 'Normal';
    else if (k < 4.0) roomType = 'Breit';
    else roomType = 'Sehr breit/flach';

    document.getElementById('calcRoomIndexClass').textContent = roomType;
    document.getElementById('calcBaseUtilization').textContent = (baseUtilization * 100).toFixed(1);

    const reflectionCorrectionFactor = 0.7 + 0.3 * averageReflectance;
    document.getElementById('calcReflectionFactor').textContent = reflectionCorrectionFactor.toFixed(3);
    document.getElementById('calcUtilizationFactor').textContent = (utilizationFactor * 100).toFixed(1);
    document.getElementById('calcMaintenanceFactor').textContent = maintenanceFactor.toFixed(2);
    document.getElementById('calcTotalLumen').textContent = Math.round(totalLumenRequired).toLocaleString();
    document.getElementById('calcLampLumen').textContent = lamp.lumen.toLocaleString();
    document.getElementById('calcLampWatt').textContent = lamp.watt;
    document.getElementById('calcLampEfficiency').textContent = (lamp.lumen / lamp.watt).toFixed(1);
    document.getElementById('calcSpecificPower').textContent = specificPower.toFixed(2);

    // Schritt-für-Schritt Berechnung
    console.log('=== UPDATING STEP-BY-STEP CALCULATIONS ===');
    document.getElementById('stepRoomWidth').textContent = roomWidth.toFixed(1);
    document.getElementById('stepRoomLength').textContent = roomLength.toFixed(1);
    document.getElementById('stepRoomArea').textContent = roomArea.toFixed(1);
    document.getElementById('stepMountingHeight').textContent = mountingHeight.toFixed(1);
    document.getElementById('stepWorkPlaneHeight').textContent = workPlaneHeight.toFixed(1);
    document.getElementById('stepH').textContent = h.toFixed(1);

    document.getElementById('stepCalcWidth').textContent = roomWidth.toFixed(1);
    document.getElementById('stepCalcLength').textContent = roomLength.toFixed(1);
    document.getElementById('stepCalcH').textContent = h.toFixed(1);
    document.getElementById('stepCalcWidth2').textContent = roomWidth.toFixed(1);
    document.getElementById('stepCalcLength2').textContent = roomLength.toFixed(1);
    document.getElementById('stepK').textContent = k.toFixed(2);
    document.getElementById('stepRoomType').textContent = roomType;
    document.getElementById('stepKValue').textContent = k.toFixed(2);

    document.getElementById('stepBaseEta').textContent = (baseUtilization * 100).toFixed(1);
    document.getElementById('stepReflection').textContent = averageReflectance.toFixed(2);
    document.getElementById('stepReflectionFactor').textContent = reflectionCorrectionFactor.toFixed(3);
    document.getElementById('stepBaseEta2').textContent = (baseUtilization * 100).toFixed(1);
    document.getElementById('stepReflectionFactor2').textContent = reflectionCorrectionFactor.toFixed(3);
    document.getElementById('stepFinalEta').textContent = (utilizationFactor * 100).toFixed(1);

    document.getElementById('stepTargetLux').textContent = targetLux;
    document.getElementById('stepAreaCalc').textContent = roomArea.toFixed(1);
    document.getElementById('stepEtaCalc').textContent = (utilizationFactor).toFixed(3);
    document.getElementById('stepMaintenance').textContent = maintenanceFactor.toFixed(2);
    document.getElementById('stepLumenNumerator').textContent = (targetLux * roomArea).toFixed(0);
    document.getElementById('stepLumenDenominator').textContent = (utilizationFactor * maintenanceFactor).toFixed(3);
    document.getElementById('stepTotalLumen').textContent = Math.round(totalLumenRequired).toLocaleString();

    document.getElementById('stepTotalLumen2').textContent = Math.round(totalLumenRequired).toLocaleString();
    document.getElementById('stepLampLumen').textContent = lamp.lumen.toLocaleString();
    document.getElementById('stepExactCount').textContent = lampCountExact.toFixed(2);
    document.getElementById('stepRoundedCount').textContent = lampCountRounded;

    document.getElementById('stepFinalCount').textContent = lampCountRounded;
    document.getElementById('stepFinalLampLumen').textContent = lamp.lumen.toLocaleString();
    document.getElementById('stepFinalEta').textContent = (utilizationFactor).toFixed(3);
    document.getElementById('stepFinalMaintenance').textContent = maintenanceFactor.toFixed(2);
    document.getElementById('stepFinalArea').textContent = roomArea.toFixed(1);
    document.getElementById('stepActualLux').textContent = Math.round(actualLux);
    document.getElementById('stepLuxDifference').textContent = (((actualLux - targetLux) / targetLux) * 100).toFixed(1);

    document.getElementById('stepFinalCount2').textContent = lampCountRounded;
    document.getElementById('stepLampWatt').textContent = lamp.watt;
    document.getElementById('stepTotalPower').textContent = Math.round(totalPower);
    document.getElementById('stepTotalPower2').textContent = Math.round(totalPower);
    document.getElementById('stepFinalArea2').textContent = roomArea.toFixed(1);
    document.getElementById('stepSpecificPower').textContent = specificPower.toFixed(2);

    // Geometrie-Analyse für Detailbereich
    const geometryAnalysisDiv = document.getElementById('geometryAnalysis');
    const geometryWarningsDiv = document.getElementById('geometryWarnings');
    const overlapInfoDiv = document.getElementById('overlapInfo');

    if (geometryWarnings.length > 0 || overlapFactor !== 1.0) {
        if (geometryAnalysisDiv) {
            geometryAnalysisDiv.style.display = 'block';
        }
        if (geometryWarningsDiv) {
            geometryWarningsDiv.innerHTML = geometryWarnings.map(w => `<div>${w}</div>`).join('');
        }

        // Überlappungsinformationen anzeigen
        if (overlapFactor !== 1.0) {
            if (overlapInfoDiv) {
                overlapInfoDiv.style.display = 'block';
            }
            const beamAngle = 60; // Standardwert, sollte aus LDT kommen
            const lightRadius = h * Math.tan((beamAngle / 2) * Math.PI / 180);
            const lampSpacing = Math.sqrt(roomArea / lampCountRounded);

            const stepLightRadius = document.getElementById('stepLightRadius');
            const stepLampSpacing = document.getElementById('stepLampSpacing');
            const stepOverlapFactor = document.getElementById('stepOverlapFactor');

            if (stepLightRadius) stepLightRadius.textContent = lightRadius.toFixed(2);
            if (stepLampSpacing) stepLampSpacing.textContent = lampSpacing.toFixed(2);
            if (stepOverlapFactor) stepOverlapFactor.textContent = overlapFactor.toFixed(3);
        } else {
            if (overlapInfoDiv) {
                overlapInfoDiv.style.display = 'none';
            }
        }
    } else {
        if (geometryAnalysisDiv) {
            geometryAnalysisDiv.style.display = 'none';
        }
    }

    // Tooltip-Updates nach Berechnung
    updateCalculationTooltips();

    // Update der Berechnungsmethoden-Überschrift
    const methodHeaderElement = document.getElementById('calculationMethodHeader');
    if (methodHeaderElement) {
        let accuracyText = isEULUMDATUsed ? '±5% Genauigkeit' : '±15% Genauigkeit';

        // Genauigkeit anpassen je nach Geometrie
        if (isExtremeGeometry) {
            accuracyText = '±20-30% Genauigkeit (extreme Geometrie)';
        } else if (k > 5.0) {
            accuracyText = '±20% Genauigkeit (hoher Raumindex)';
        }

        if (isEULUMDATUsed) {
            methodHeaderElement.innerHTML = `<i class="bi bi-graph-up text-success me-1"></i>Präzise EULUMDAT-Berechnung (${accuracyText})`;
        } else {
            methodHeaderElement.innerHTML = `<i class="bi bi-calculator text-info me-1"></i>Standard-Berechnung nach EN 13032-2 (${accuracyText})`;
        }

        // Zeige angewendete Korrekturen
        if (overlapFactor !== 1.0) {
            methodHeaderElement.innerHTML += `<br><small class="text-muted">Überlappungskorrektur: ${overlapFactor.toFixed(2)}</small>`;
        }
    }

    // EULUMDAT-Benachrichtigung anzeigen
    const eulumdatNotice = document.getElementById('eulumdatNotice');
    if (eulumdatNotice) {
        if (isEULUMDATUsed) {
            eulumdatNotice.style.display = 'block';
            eulumdatNotice.innerHTML = `
                <div class="alert alert-success d-flex align-items-start">
                    <i class="bi bi-graph-up-arrow me-3 mt-1 fs-4 text-success"></i>
                    <div class="flex-grow-1">
                        <h6 class="mb-2"><strong>🎯 EULUMDAT-Präzisionsberechnung aktiv</strong></h6>
                        <div class="row">
                            <div class="col-md-6">
                                <strong>Datenquelle:</strong><br>
                                <code>${lamp.eulumdatFile || 'EULUMDAT-Datei'}</code>
                                <br><br>
                                <strong>Vorteile:</strong>
                                <ul class="mb-0 small">
                                    <li>Reale photometrische Messdaten</li>
                                    <li>72 C-Ebenen × 161 Gamma-Winkel</li>
                                    <li>Genauigkeit: ±5% (vs. ±15% Standard)</li>
                                </ul>
                            </div>
                            <div class="col-md-6">
                                <strong>Unterschied zu Standard:</strong>
                                <ul class="mb-0 small">
                                    <li>Standard: Vereinfachte EN 13032-2 Tabellen</li>
                                    <li>EULUMDAT: Spezifische Lichtverteilung</li>
                                    <li>Berücksichtigt asymmetrische Lichtcharakteristik</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        } else {
            eulumdatNotice.style.display = 'block';
            eulumdatNotice.innerHTML = `
                <div class="alert alert-info d-flex align-items-start">
                    <i class="bi bi-calculator me-3 mt-1 fs-4 text-info"></i>
                    <div class="flex-grow-1">
                        <h6 class="mb-2"><strong>📊 Standard-Berechnung nach EN 13032-2</strong></h6>
                        <div class="row">
                            <div class="col-md-6">
                                <strong>Methode:</strong><br>
                                Bewährte Tabellenwerte für Raumwirkungsgrad
                                <br><br>
                                <strong>Merkmale:</strong>
                                <ul class="mb-0 small">
                                    <li>Schnelle Überschlagsrechnung</li>
                                    <li>Standardisierte Werte nach Norm</li>
                                    <li>Genauigkeit: ±15%</li>
                                </ul>
                            </div>
                            <div class="col-md-6">
                                <strong>Für höhere Präzision:</strong>
                                <ul class="mb-0 small">
                                    <li>LDT-Datei der Leuchte hochladen</li>
                                    <li>Automatische EULUMDAT-Analyse</li>
                                    <li>Präzise photometrische Berechnung</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }
    }

    // Lichtverteilungskurve anzeigen (wenn verfügbar)
    console.log('=== LICHTVERTEILUNGSKURVE INTEGRATION ===');
    // Kurze Verzögerung um sicherzustellen, dass DOM-Elemente verfügbar sind
    setTimeout(() => {
        drawLightDistributionChart(lamp);
    }, 100);

    // Schritt-für-Schritt Berechnung
    const baseUtilizationFactor = utilizationFactor / (0.7 + 0.3 * reflectionFactor);

    // Schritt 1: Raumfläche
    document.getElementById('stepRoomWidth').textContent = roomWidth;
    document.getElementById('stepRoomLength').textContent = roomLength;
    document.getElementById('stepRoomArea').textContent = roomArea.toFixed(1);

    // Schritt 2: Abstand h
    document.getElementById('stepMountingHeight').textContent = mountingHeight;
    document.getElementById('stepWorkPlaneHeight').textContent = workPlaneHeight;
    document.getElementById('stepH').textContent = h.toFixed(2);

    // Schritt 3: Raumindex
    document.getElementById('stepCalcWidth').textContent = roomWidth;
    document.getElementById('stepCalcLength').textContent = roomLength;
    document.getElementById('stepCalcH').textContent = h.toFixed(2);
    document.getElementById('stepCalcWidth2').textContent = roomWidth;
    document.getElementById('stepCalcLength2').textContent = roomLength;
    document.getElementById('stepK').textContent = k.toFixed(3);

    // Schritt 4: Basis-Wirkungsgrad mit Berechnungsmethode
    const calculationMethod = isEULUMDATUsed ? 'EULUMDAT-Photometrie' : 'Standard EN 13032-2';
    document.getElementById('stepBaseEta').textContent = (baseUtilizationFactor * 100).toFixed(1) + '%';

    // Berechnungsmethode-Info hinzufügen
    const baseEtaElement = document.getElementById('stepBaseEta');
    if (baseEtaElement && baseEtaElement.parentNode) {
        // Suche nach vorhandener Methoden-Info und entferne sie
        const existingMethodInfo = baseEtaElement.parentNode.querySelector('.calculation-method-info');
        if (existingMethodInfo) {
            existingMethodInfo.remove();
        }

        // Neue Methoden-Info hinzufügen
        const methodInfo = document.createElement('small');
        methodInfo.className = 'calculation-method-info text-muted d-block mt-1';
        if (isEULUMDATUsed) {
            methodInfo.innerHTML = `<i class="bi bi-graph-up text-success"></i> <strong>Präzise EULUMDAT-Berechnung</strong><br>aus realen photometrischen Messdaten (${lamp.eulumdatFile || 'EULUMDAT-Datei'})`;
        } else {
            methodInfo.innerHTML = `<i class="bi bi-calculator text-info"></i> <strong>Standard-Berechnung</strong><br>nach EN 13032-2 Tabellenwerten`;
        }
        baseEtaElement.parentNode.appendChild(methodInfo);
    }

    // Schritt 5: Korrigierter Wirkungsgrad
    document.getElementById('stepBaseEta2').textContent = (baseUtilizationFactor * 100).toFixed(1) + '%';
    document.getElementById('stepReflection').textContent = reflectionFactor;
    document.getElementById('stepFinalEta').textContent = (utilizationFactor * 100).toFixed(1) + '%';

    // Schritt 6: Benötigter Lichtstrom
    document.getElementById('stepTargetLux').textContent = targetLux;
    document.getElementById('stepAreaCalc').textContent = roomArea.toFixed(1);
    document.getElementById('stepEtaCalc').textContent = (utilizationFactor * 100).toFixed(1) + '%';
    document.getElementById('stepMaintenance').textContent = maintenanceFactor;
    document.getElementById('stepTotalLumen').textContent = Math.round(totalLumenRequired).toLocaleString();

    // Schritt 7: Exakte Anzahl
    document.getElementById('stepTotalLumen2').textContent = Math.round(totalLumenRequired).toLocaleString();
    document.getElementById('stepLampLumen').textContent = lamp.lumen.toLocaleString();
    document.getElementById('stepExactCount').textContent = lampCountExact.toFixed(2);

    // Schritt 8: Aufgerundete Anzahl
    document.getElementById('stepRoundedCount').textContent = lampCountRounded;

    // Schritt 9: Tatsächliche Beleuchtung
    document.getElementById('stepFinalCount').textContent = lampCountRounded;
    document.getElementById('stepFinalLampLumen').textContent = lamp.lumen.toLocaleString();
    document.getElementById('stepFinalEta').textContent = (utilizationFactor * 100).toFixed(1) + '%';
    document.getElementById('stepFinalMaintenance').textContent = maintenanceFactor;
    document.getElementById('stepFinalArea').textContent = roomArea.toFixed(1);
    document.getElementById('stepActualLux').textContent = Math.round(actualLux);

    // Schritt 10: Gesamtleistung
    document.getElementById('stepFinalCount2').textContent = lampCountRounded;
    document.getElementById('stepLampWatt').textContent = lamp.watt;
    document.getElementById('stepTotalPower').textContent = Math.round(totalPower);

    console.log('=== SHOWING CALCULATION DETAILS ===');
    document.getElementById('calculations').style.display = 'block';

    // PDF Export Button anzeigen
    console.log('=== SHOWING PDF BUTTON ===');
    document.getElementById('pdfButton').style.display = 'block';

    // 3D-Visualisierung aktualisieren
    console.log('=== UPDATING VISUALIZATION ===');
    if (typeof THREE !== 'undefined' && scene) {
        updateVisualization(lampCountRounded);
    } else {
        // Fallback: 2D-Darstellung
        update2DVisualization(lampCountRounded);
    }

    console.log('=== CALCULATE FUNCTION COMPLETED SUCCESSFULLY ===');

    // Set global flag for debugging
    window.calculationCompleted = true;

    } catch (error) {
        console.error('=== ERROR IN CALCULATE FUNCTION ===');
        console.error('Error details:', error);
        console.error('Stack trace:', error.stack);

        // Set global flag for debugging
        window.calculationError = error;
        window.calculationCompleted = false;

        // Show error to user
        alert('Fehler bei der Berechnung: ' + error.message);

        // Try to show basic results section at least
        try {
            document.getElementById('results').style.display = 'block';
        } catch (e) {
            console.error('Could not show results section:', e);
        }
    }
}

// Debug-Funktion für Diagnose
function debugCheckCalculationFunction() {
    console.log('=== DEBUGGING CALCULATION FUNCTION ===');

    // Check if calculate function exists
    if (typeof calculate === 'function') {
        console.log('✓ calculate() function is defined');
    } else {
        console.error('✗ calculate() function is NOT defined');
    }

    // Check critical DOM elements
    const criticalElements = [
        'selectedLamp', 'targetLux', 'roomWidth', 'roomLength',
        'roomHeight', 'mountingHeight', 'workPlaneHeight',
        'reflectionFactor', 'maintenanceFactor', 'results', 'calculations'
    ];

    console.log('Checking critical DOM elements:');
    criticalElements.forEach(id => {
        const element = document.getElementById(id);
        if (element) {
            console.log(`✓ ${id} exists`);
        } else {
            console.error(`✗ ${id} NOT found`);
        }
    });

    // Check if tooltips are initialized
    if (typeof updateCalculationTooltips === 'function') {
        console.log('✓ updateCalculationTooltips() function is defined');
    } else {
        console.error('✗ updateCalculationTooltips() function is NOT defined');
    }

    // Check if lampDatabase exists
    if (typeof lampDatabase !== 'undefined' && lampDatabase.length > 0) {
        console.log(`✓ lampDatabase loaded with ${lampDatabase.length} lamps`);
    } else {
        console.error('✗ lampDatabase is not loaded or empty');
    }

    console.log('=== END DEBUG CHECK ===');
}

// Gleichmäßigkeits-Warnung anzeigen
function showDistributionWarning(lampCount) {
    console.log('=== showDistributionWarning STARTED ===');
    console.log('lampCount:', lampCount);

    const roomWidth = parseFloat(document.getElementById('roomWidth').value);
    const roomLength = parseFloat(document.getElementById('roomLength').value);
    console.log('Room dimensions:', roomWidth, 'x', roomLength);

    // Berechne tatsächliche Verteilung (gleiche Logik wie in PDF)
    let cols, rows;
    if (lampCount === 1) {
        cols = 1; rows = 1;
    } else if (lampCount === 2) {
        cols = 2; rows = 1;
    } else if (lampCount <= 4) {
        cols = 2; rows = Math.ceil(lampCount / 2);
    } else {
        const aspectRatio = roomWidth / roomLength;
        cols = Math.ceil(Math.sqrt(lampCount * aspectRatio));
        rows = Math.ceil(lampCount / cols);
        if (cols * (rows - 1) >= lampCount) rows = rows - 1;
    }

    const actualLamps = cols * rows;
    const spacingX = roomWidth / (cols + 1);
    const spacingZ = roomLength / (rows + 1);

    console.log('Distribution calculation:', {
        cols, rows, actualLamps, lampCount,
        isUneven: actualLamps > lampCount
    });

    const warningDiv = document.getElementById('distributionWarning');
    const warningText = document.getElementById('distributionWarningText');

    // Warnung anzeigen wenn ungleichmäßige Verteilung
    if (actualLamps > lampCount) {
        console.log('UNEVEN DISTRIBUTION DETECTED - showing even distribution results');
        warningText.innerHTML = `
            <div class="alert alert-warning p-2 mb-2">
                <div>Bei der berechneten Anzahl von <strong>${lampCount} Leuchten</strong> können diese nicht immer gleichmäßig verteilt werden.</div>
                <div class="mt-1">Tatsächliche Anordnung: <strong>${cols} × ${rows} = ${actualLamps} Leuchten</strong></div>
                <div class="mt-1">Für eine gleichmäßige Verteilung würden <strong>${actualLamps} Leuchten</strong> benötigt.</div>
            </div>
            <div class="text-muted">Abstand zwischen Leuchten: ${spacingX.toFixed(2)}m × ${spacingZ.toFixed(2)}m</div>
        `;

        // Ausklappbare Ergebnisse für gleichmäßige Verteilung anzeigen
        console.log('=== ATTEMPTING TO SHOW EVEN DISTRIBUTION ===');
        console.log('actualLamps:', actualLamps);

        // Element direkt prüfen
        const evenResultsEl = document.getElementById('evenDistributionResults');
        console.log('evenDistributionResults element found:', !!evenResultsEl);

        if (evenResultsEl) {
            evenResultsEl.style.display = 'block';
            console.log('✓ evenDistributionResults is now visible');

            // Funktion aufrufen
            try {
                showEvenDistributionResults(actualLamps);
                console.log('✓ showEvenDistributionResults completed');
            } catch (error) {
                console.error('✗ Error in showEvenDistributionResults:', error);
            }
        } else {
            console.error('✗ evenDistributionResults element NOT FOUND');
        }

        warningDiv.style.display = 'block';
    } else {
        warningText.innerHTML = `
            <div class="alert alert-success p-2 mb-2">
                <div>Die <strong>${lampCount} Leuchten</strong> können gleichmäßig in einem <strong>${cols} × ${rows}</strong> Raster verteilt werden.</div>
            </div>
            <div class="text-muted">Abstand zwischen Leuchten: ${spacingX.toFixed(2)}m × ${spacingZ.toFixed(2)}m</div>
        `;

        // Ausklappbare Ergebnisse ausblenden
        const evenResultsEl = document.getElementById('evenDistributionResults');
        if (evenResultsEl) {
            evenResultsEl.style.display = 'none';
        }

        warningDiv.style.display = 'block';
    }
}

// Ergebnisse für gleichmäßige Verteilung berechnen und anzeigen
function showEvenDistributionResults(evenLampCount) {
    try {
        console.log('=== showEvenDistributionResults START ===');
        console.log('evenLampCount:', evenLampCount);
        console.log('Type of evenLampCount:', typeof evenLampCount);

        const valuesDiv = document.getElementById('evenDistributionValues');
        if (!valuesDiv) {
            console.error('✗ evenDistributionValues element NOT found');
            return;
        }
        console.log('✓ evenDistributionValues element found');

        // WICHTIG: Verwende die aktuellen Berechnungswerte aus der Hauptberechnung
        // für konsistente Ergebnisse (besonders wichtig bei EULUMDAT-Daten)
        const currentLampCountFromMain = parseFloat(document.getElementById('lampCountRounded')?.textContent) || 0;
        const currentActualLuxFromMain = parseFloat(document.getElementById('actualLux')?.textContent) || 0;
        const currentTotalPowerFromMain = parseFloat(document.getElementById('totalPower')?.textContent) || 0;

        if (currentLampCountFromMain === 0 || currentActualLuxFromMain === 0) {
            console.error('Keine gültigen Berechnungswerte gefunden');
            return;
        }

        // Proportionale Berechnung basierend auf den aktuellen Werten
        // Dies stellt sicher, dass dieselben Faktoren (utilizationFactor, maintenanceFactor, etc.) verwendet werden
        const actualLuxEven = (evenLampCount / currentLampCountFromMain) * currentActualLuxFromMain;
        const totalPowerEven = (evenLampCount / currentLampCountFromMain) * currentTotalPowerFromMain;

        // Raumfläche für spezifische Leistung
        const roomWidth = parseFloat(document.getElementById('roomWidth')?.value) || 0;
        const roomLength = parseFloat(document.getElementById('roomLength')?.value) || 0;
        const roomArea = roomWidth * roomLength;

        // Leuchte für zusätzliche Informationen
        const lampSelect = document.getElementById('selectedLamp');
        const lamp = lampDatabase.find(l => l.id == lampSelect?.value);
        if (!lamp) {
            console.error('Selected lamp not found');
            return;
        }

    // Anschlusswerte - auch diese proportional berechnen für Konsistenz
    const specificPowerEven = totalPowerEven / roomArea;
    const specificPowerPer100lxEven = (specificPowerEven / actualLuxEven) * 100;

    // HTML für die Ergebnisse erstellen
    const evenValuesDiv = document.getElementById('evenDistributionValues');
    if (!evenValuesDiv) {
        console.error('evenDistributionValues element not found');
        return;
    }

    console.log('evenDistributionValues element found, creating content...');

    // Sichere Abfrage der aktuellen Werte
    const currentLampCount = document.getElementById('lampCountRounded');
    const currentActualLux = document.getElementById('actualLux');
    const currentTotalPower = document.getElementById('totalPower');

    if (!currentLampCount || !currentActualLux || !currentTotalPower) {
        console.error('Required result elements not found');
        return;
    }

    const currentLampCountValue = parseInt(currentLampCount.textContent) || 0;
    const currentActualLuxValue = parseFloat(currentActualLux.textContent) || 0;
    const currentTotalPowerValue = parseFloat(currentTotalPower.textContent) || 0;

    const htmlContent = `
        <div class="col-6">
            <div class="text-center p-3 bg-success bg-opacity-10 rounded border border-success">
                <div class="h5 text-success mb-1">${evenLampCount}</div>
                <small class="text-muted">Leuchten (gleichmäßig)</small>
            </div>
        </div>
        <div class="col-6">
            <div class="text-center p-3 bg-light rounded">
                <div class="h5 text-info mb-1">${Math.round(actualLuxEven)}</div>
                <small class="text-muted">Beleuchtungsstärke (lx)</small>
            </div>
        </div>
        <div class="col-6">
            <div class="text-center p-3 bg-light rounded">
                <div class="h5 text-warning mb-1">${Math.round(totalPowerEven)}</div>
                <small class="text-muted">Gesamtleistung (W)</small>
            </div>
        </div>
        <div class="col-6">
            <div class="text-center p-3 bg-light rounded">
                <div class="h5 text-secondary mb-1">${specificPowerEven.toFixed(2)}</div>
                <small class="text-muted">W/m²</small>
            </div>
        </div>
        <div class="col-6">
            <div class="text-center p-3 bg-light rounded">
                <div class="h5 text-secondary mb-1">${specificPowerPer100lxEven.toFixed(2)}</div>
                <small class="text-muted">W/m²/100lx</small>
            </div>
        </div>
        <div class="col-6">
            <div class="text-center p-3 bg-info bg-opacity-10 rounded border border-info">
                <div class="h6 text-info mb-1">+${Math.round(actualLuxEven - currentActualLuxValue)}</div>
                <small class="text-muted">Mehr Beleuchtung (lx)</small>
            </div>
        </div>
        <div class="col-12">
            <div class="alert alert-info p-2 mt-2 mb-0">
                <small>
                    <strong>Vergleich:</strong>
                    Zusätzliche ${evenLampCount - currentLampCountValue} Leuchten würden
                    ${Math.round(actualLuxEven - currentActualLuxValue)} lx mehr Beleuchtung und
                    ${Math.round(totalPowerEven - currentTotalPowerValue)} W mehr Verbrauch bedeuten.
                </small>
            </div>
        </div>
    `;

    console.log('Generated HTML content length:', htmlContent.length);
    console.log('Setting innerHTML of evenDistributionValues...');
    evenValuesDiv.innerHTML = htmlContent;
    console.log('innerHTML set, current content length:', evenValuesDiv.innerHTML.length);
    console.log('Even distribution content generated and inserted');

    } catch (error) {
        console.error('Error in showEvenDistributionResults:', error);
        console.error('Stack trace:', error.stack);
    }
}

// Raum für PDF-Canvas zeichnen
function drawRoomToPDFCanvas(ctx, canvasWidth, canvasHeight, roomWidth, roomLength, lampCount) {
    // Zeichnungsbereich berechnen
    const padding = 40;
    const drawWidth = canvasWidth - 2 * padding;
    const drawHeight = canvasHeight - 2 * padding;

    // Skalierung berechnen
    const scaleX = drawWidth / roomWidth;
    const scaleY = drawHeight / roomLength;
    const scale = Math.min(scaleX, scaleY);

    const scaledWidth = roomWidth * scale;
    const scaledHeight = roomLength * scale;

    // Zentrierung
    const offsetX = padding + (drawWidth - scaledWidth) / 2;
    const offsetY = padding + (drawHeight - scaledHeight) / 2;

    // Raum-Rechteck zeichnen
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    ctx.strokeRect(offsetX, offsetY, scaledWidth, scaledHeight);

    // Raum füllen
    ctx.fillStyle = '#f8f9fa';
    ctx.fillRect(offsetX, offsetY, scaledWidth, scaledHeight);

    // Beschriftung
    ctx.fillStyle = '#333';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';

    // Raummaße
    ctx.fillText(`${roomWidth}m`, offsetX + scaledWidth/2, offsetY - 10);
    ctx.save();
    ctx.translate(offsetX - 15, offsetY + scaledHeight/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText(`${roomLength}m`, 0, 0);
    ctx.restore();

    // Leuchten positionieren und zeichnen
    if (lampCount > 0) {
        // Berechne Leuchten-Layout (gleiche Logik wie im Tool)
        let cols, rows;
        if (lampCount === 1) {
            cols = 1; rows = 1;
        } else if (lampCount === 2) {
            cols = 2; rows = 1;
        } else if (lampCount <= 4) {
            cols = 2; rows = Math.ceil(lampCount / 2);
        } else {
            const aspectRatio = roomWidth / roomLength;
            cols = Math.ceil(Math.sqrt(lampCount * aspectRatio));
            rows = Math.ceil(lampCount / cols);
            if (cols * (rows - 1) >= lampCount) rows = rows - 1;
        }

        // Leuchten zeichnen
        ctx.fillStyle = '#ffc107'; // Gold für Leuchten
        const spacingX = scaledWidth / (cols + 1);
        const spacingY = scaledHeight / (rows + 1);

        let lampIndex = 0;
        for (let row = 0; row < rows && lampIndex < lampCount; row++) {
            for (let col = 0; col < cols && lampIndex < lampCount; col++) {
                const x = offsetX + spacingX * (col + 1);
                const y = offsetY + spacingY * (row + 1);

                // Leuchte als Kreis zeichnen
                ctx.beginPath();
                ctx.arc(x, y, 6, 0, 2 * Math.PI);
                ctx.fill();

                // Leuchten-Nummer
                ctx.fillStyle = '#333';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText((lampIndex + 1).toString(), x, y + 3);
                ctx.fillStyle = '#ffc107';

                lampIndex++;
            }
        }
    }

    // Titel
    ctx.fillStyle = '#333';
    ctx.font = 'bold 14px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Raumdarstellung mit Leuchtenpositionen', canvasWidth/2, 25);

    // Legende
    ctx.font = '10px Arial';
    ctx.fillText(`${lampCount} Leuchten gleichmäßig verteilt`, canvasWidth/2, canvasHeight - 15);
}

// Toggle-Funktion für gleichmäßige Verteilungsergebnisse
function toggleEvenResults() {
    console.log('=== toggleEvenResults called ===');

    const resultsDiv = document.getElementById('evenResults');
    const icon = document.getElementById('evenResultsIcon');

    console.log('resultsDiv found:', !!resultsDiv);
    console.log('icon found:', !!icon);

    if (resultsDiv) {
        const isHidden = resultsDiv.style.display === 'none' || resultsDiv.style.display === '';
        console.log('Current display state:', resultsDiv.style.display);
        console.log('Is hidden:', isHidden);

        if (isHidden) {
            resultsDiv.style.display = 'block';
            if (icon) icon.className = 'bi bi-chevron-up float-end text-white';
            console.log('✓ Showing results');
        } else {
            resultsDiv.style.display = 'none';
            if (icon) icon.className = 'bi bi-chevron-down float-end text-white';
            console.log('✓ Hiding results');
        }
    } else {
        console.error('✗ evenResults element not found');
    }
}

// Debug-Funktion für direktes Testen (in der Browser-Konsole verwendbar)
window.debugEvenDistribution = function() {
    console.log('=== DEBUG EVEN DISTRIBUTION ===');

    // Element prüfen
    const evenResultsEl = document.getElementById('evenDistributionResults');
    const evenResults = document.getElementById('evenResults');
    const evenValues = document.getElementById('evenDistributionValues');

    console.log('evenDistributionResults:', !!evenResultsEl);
    console.log('evenResults:', !!evenResults);
    console.log('evenDistributionValues:', !!evenValues);

    if (evenResultsEl) {
        evenResultsEl.style.display = 'block';
        console.log('✓ Made evenDistributionResults visible');
    }

    if (evenValues) {
        evenValues.innerHTML = '<div class="col-12"><div class="alert alert-info">DIRECT TEST - This works!</div></div>';
        console.log('✓ Added test content to evenValues');
    }

    if (evenResults) {
        evenResults.style.display = 'block';
        console.log('✓ Made evenResults visible');
    }
};

console.log('Debug function available: debugEvenDistribution()');

// 3D-Initialisierung
function init3D() {
    // Prüfe ob Three.js verfügbar ist
    if (typeof THREE === 'undefined') {
        console.log('Three.js nicht verfügbar, verwende 2D-Fallback');
        init2D();
        return;
    }

    const container = document.getElementById('canvas-container');
    if (!container) {
        console.error('Canvas-Container nicht gefunden');
        return;
    }

    try {
        // Container vorbereiten
        container.innerHTML = '';

        // Szene erstellen
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf5f5f5);

        // Kamera
        const aspect = container.clientWidth / container.clientHeight;
        camera = new THREE.PerspectiveCamera(60, aspect, 0.1, 100);
        camera.position.set(10, 8, 10);
        camera.lookAt(0, 0, 0);

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setClearColor(0xf5f5f5);
        container.appendChild(renderer.domElement);

        // Beleuchtung
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
        directionalLight.position.set(10, 10, 5);
        scene.add(directionalLight);

        // Grid
        gridHelper = new THREE.GridHelper(20, 20, 0xcccccc, 0xeeeeee);
        scene.add(gridHelper);

        // Einfache Maussteuerung
        let mouseDown = false;
        let mouseX = 0, mouseY = 0;

        container.addEventListener('mousedown', (e) => {
            mouseDown = true;
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        document.addEventListener('mouseup', () => {
            mouseDown = false;
        });

        container.addEventListener('mousemove', (e) => {
            if (!mouseDown) return;

            const deltaX = e.clientX - mouseX;
            const deltaY = e.clientY - mouseY;

            // Einfache Rotation um Y-Achse
            const rotationSpeed = 0.01;
            const radius = camera.position.length();
            const theta = Math.atan2(camera.position.x, camera.position.z) - deltaX * rotationSpeed;
            const phi = Math.acos(camera.position.y / radius) + deltaY * rotationSpeed * 0.5;

            camera.position.x = radius * Math.sin(Math.max(0.1, Math.min(Math.PI - 0.1, phi))) * Math.sin(theta);
            camera.position.y = radius * Math.cos(Math.max(0.1, Math.min(Math.PI - 0.1, phi)));
            camera.position.z = radius * Math.sin(Math.max(0.1, Math.min(Math.PI - 0.1, phi))) * Math.cos(theta);

            camera.lookAt(0, 0, 0);

            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        // Zoom
        container.addEventListener('wheel', (e) => {
            e.preventDefault();
            const scale = e.deltaY > 0 ? 1.1 : 0.9;
            camera.position.multiplyScalar(scale);
            const distance = camera.position.length();
            if (distance < 5) camera.position.normalize().multiplyScalar(5);
            if (distance > 30) camera.position.normalize().multiplyScalar(30);
        });

        // Initial render
        createBasicRoom();
        animate();

        console.log('3D-Visualisierung erfolgreich initialisiert');

    } catch (error) {
        console.error('Fehler bei 3D-Initialisierung:', error);
        init2D();
    }
}

function animate() {
    if (renderer && scene && camera) {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
    }
}

function createBasicRoom() {
    if (!scene) return;

    // Bestehende Objekte entfernen
    const objectsToRemove = [];
    scene.traverse((child) => {
        if (child.userData.isRoom || child.userData.isLamp || child.userData.isWorkPlane) {
            objectsToRemove.push(child);
        }
    });
    objectsToRemove.forEach(obj => scene.remove(obj));

    const width = parseFloat(document.getElementById('roomWidth').value) || 6;
    const length = parseFloat(document.getElementById('roomLength').value) || 8;
    const height = parseFloat(document.getElementById('roomHeight').value) || 3;
    const workPlaneHeight = parseFloat(document.getElementById('workPlaneHeight').value) || 0.85;

    // Boden
    const floorGeometry = new THREE.PlaneGeometry(width, length);
    const floorMaterial = new THREE.MeshLambertMaterial({ color: 0xe0e0e0 });
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = -Math.PI / 2;
    floor.userData.isRoom = true;
    scene.add(floor);

    // Raumkanten
    const edgesGeometry = new THREE.EdgesGeometry(new THREE.BoxGeometry(width, height, length));
    const edgesMaterial = new THREE.LineBasicMaterial({ color: 0x666666 });
    const edges = new THREE.LineSegments(edgesGeometry, edgesMaterial);
    edges.position.y = height / 2;
    edges.userData.isRoom = true;
    scene.add(edges);

    // Arbeitsebene
    const workPlaneGeometry = new THREE.PlaneGeometry(width * 0.9, length * 0.9);
    const workPlaneMaterial = new THREE.MeshLambertMaterial({
        color: 0x4CAF50,
        transparent: true,
        opacity: 0.3
    });
    const workPlane = new THREE.Mesh(workPlaneGeometry, workPlaneMaterial);
    workPlane.rotation.x = -Math.PI / 2;
    workPlane.position.y = workPlaneHeight;
    workPlane.userData.isWorkPlane = true;
    scene.add(workPlane);
}

function updateVisualization(lampCount) {
    if (!scene) return;

    // Bestehende Lampen entfernen
    const lampsToRemove = [];
    scene.traverse((child) => {
        if (child.userData.isLamp) {
            lampsToRemove.push(child);
        }
    });
    lampsToRemove.forEach(lamp => scene.remove(lamp));

    const width = parseFloat(document.getElementById('roomWidth').value) || 6;
    const length = parseFloat(document.getElementById('roomLength').value) || 8;
    const mountingHeight = parseFloat(document.getElementById('mountingHeight').value) || 2.8;

    // Raum neu erstellen
    createBasicRoom();

    // Leuchten gleichmäßig verteilen
    // Optimale Anzahl pro Reihe/Spalte berechnen für gleichmäßige Verteilung
    let cols, rows;

    if (lampCount === 1) {
        cols = 1;
        rows = 1;
    } else if (lampCount === 2) {
        cols = 2;
        rows = 1;
    } else if (lampCount <= 4) {
        cols = 2;
        rows = Math.ceil(lampCount / 2);
    } else {
        // Für mehr als 4 Leuchten: beste Verteilung basierend auf Raumproportionen
        const aspectRatio = width / length;
        cols = Math.ceil(Math.sqrt(lampCount * aspectRatio));
        rows = Math.ceil(lampCount / cols);

        // Optimierung für bessere Verteilung
        if (cols * (rows - 1) >= lampCount) {
            rows = rows - 1;
        }
    }

    // Gleichmäßige Abstände berechnen
    const spacingX = width / (cols + 1);
    const spacingZ = length / (rows + 1);

    let lampIndex = 0;
    for (let row = 0; row < rows && lampIndex < lampCount; row++) {
        for (let col = 0; col < cols && lampIndex < lampCount; col++) {
            // Einfache Leuchte als Zylinder
            const lampGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.1, 8);
            const lampMaterial = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
            const lamp = new THREE.Mesh(lampGeometry, lampMaterial);

            // Position berechnen für gleichmäßige Verteilung
            lamp.position.x = -width/2 + spacingX * (col + 1);
            lamp.position.y = mountingHeight;
            lamp.position.z = -length/2 + spacingZ * (row + 1);
            lamp.userData.isLamp = true;

            scene.add(lamp);
            lampIndex++;
        }
    }
}

// 2D Fallback
function init2D() {
    const container = document.getElementById('canvas-container');
    container.innerHTML = `
        <div class="h-100 p-3">
            <div class="text-center mb-3">
                <h6 class="text-muted">2D-Raumdarstellung</h6>
            </div>
            <div id="room2d" style="width: 100%; height: 300px; border: 2px solid #666; background: #f0f0f0; position: relative; margin: 0 auto; max-width: 400px;">
                <div id="workplane2d" style="position: absolute; background: rgba(76, 175, 80, 0.3); border: 1px dashed #4CAF50;"></div>
                <div id="lamps2d"></div>
            </div>
            <small class="text-muted d-block text-center mt-2">3D nicht verfügbar - 2D-Ansicht</small>
        </div>
    `;
    update2DVisualization(0);
}

function update2DVisualization(lampCount) {
    const room2d = document.getElementById('room2d');
    const workplane2d = document.getElementById('workplane2d');
    const lamps2d = document.getElementById('lamps2d');

    if (!room2d) return;

    const width = parseFloat(document.getElementById('roomWidth').value) || 6;
    const length = parseFloat(document.getElementById('roomLength').value) || 8;

    // Skalierung
    const scale = Math.min(350 / Math.max(width, length), 25);
    const roomWidth2d = width * scale;
    const roomLength2d = length * scale;

    room2d.style.width = roomWidth2d + 'px';
    room2d.style.height = roomLength2d + 'px';

    // Arbeitsebene
    if (workplane2d) {
        const margin = 10;
        workplane2d.style.left = margin + 'px';
        workplane2d.style.top = margin + 'px';
        workplane2d.style.width = (roomWidth2d - 2 * margin) + 'px';
        workplane2d.style.height = (roomLength2d - 2 * margin) + 'px';
    }

    // Lampen gleichmäßig verteilen (2D)
    if (lamps2d && lampCount > 0) {
        lamps2d.innerHTML = '';

        // Gleiche Verteilungslogik wie bei 3D
        let cols, rows;

        if (lampCount === 1) {
            cols = 1;
            rows = 1;
        } else if (lampCount === 2) {
            cols = 2;
            rows = 1;
        } else if (lampCount <= 4) {
            cols = 2;
            rows = Math.ceil(lampCount / 2);
        } else {
            // Für mehr als 4 Leuchten: beste Verteilung basierend auf Raumproportionen
            const aspectRatio = width / length;
            cols = Math.ceil(Math.sqrt(lampCount * aspectRatio));
            rows = Math.ceil(lampCount / cols);

            // Optimierung für bessere Verteilung
            if (cols * (rows - 1) >= lampCount) {
                rows = rows - 1;
            }
        }

        const spacingX = roomWidth2d / (cols + 1);
        const spacingY = roomLength2d / (rows + 1);

        let lampIndex = 0;
        for (let row = 0; row < rows && lampIndex < lampCount; row++) {
            for (let col = 0; col < cols && lampIndex < lampCount; col++) {
                const lamp = document.createElement('div');
                lamp.style.position = 'absolute';
                lamp.style.width = '8px';
                lamp.style.height = '8px';
                lamp.style.backgroundColor = '#FFD700';
                lamp.style.borderRadius = '50%';
                lamp.style.border = '1px solid #FFA500';
                lamp.style.left = (spacingX * (col + 1) - 4) + 'px';
                lamp.style.top = (spacingY * (row + 1) - 4) + 'px';
                lamp.title = `Leuchte ${lampIndex + 1}`;

                lamps2d.appendChild(lamp);
                lampIndex++;
            }
        }
    }
}

// Steuerungsfunktionen
function resetCamera() {
    if (camera) {
        camera.position.set(10, 8, 10);
        camera.lookAt(0, 0, 0);
    }
}

function toggleGrid() {
    if (gridHelper) {
        gridHelper.visible = !gridHelper.visible;
    }
}

// Validierungsfunktionen für Montagehöhe
function updateMountingHeightMax() {
    const roomHeight = parseFloat(document.getElementById('roomHeight').value) || 3;
    const mountingHeightInput = document.getElementById('mountingHeight');
    const maxMountingHeightSpan = document.getElementById('maxMountingHeight');

    // Maximum auf Raumhöhe setzen
    mountingHeightInput.max = roomHeight;
    maxMountingHeightSpan.textContent = roomHeight.toFixed(1);

    // Prüfen ob aktueller Wert zu hoch ist
    validateMountingHeight();

    // Arbeitsebenen-Maximum auch aktualisieren
    updateWorkPlaneHeightMax();
}

function validateMountingHeight() {
    const roomHeight = parseFloat(document.getElementById('roomHeight').value) || 3;
    const mountingHeightInput = document.getElementById('mountingHeight');
    const mountingHeight = parseFloat(mountingHeightInput.value);

    if (mountingHeight > roomHeight) {
        // Wert auf Maximum korrigieren
        mountingHeightInput.value = roomHeight;

        // Visuelle Warnung
        mountingHeightInput.classList.add('is-invalid');
        setTimeout(() => {
            mountingHeightInput.classList.remove('is-invalid');
        }, 2000);

        // Toast-Benachrichtigung
        showValidationMessage('Montagehöhe kann nicht größer als die Raumhöhe sein!');
    }

    // Arbeitsebenen-Maximum auch aktualisieren wenn Montagehöhe sich ändert
    updateWorkPlaneHeightMax();
}

function updateWorkPlaneHeightMax() {
    const mountingHeight = parseFloat(document.getElementById('mountingHeight').value) || 2.8;
    const workPlaneHeightInput = document.getElementById('workPlaneHeight');
    const maxWorkPlaneHeightSpan = document.getElementById('maxWorkPlaneHeight');

    // Maximum auf Montagehöhe - 0.1m setzen (mindestens 10cm Abstand)
    const maxWorkPlaneHeight = Math.max(0, mountingHeight - 0.1);
    workPlaneHeightInput.max = maxWorkPlaneHeight;
    maxWorkPlaneHeightSpan.textContent = maxWorkPlaneHeight.toFixed(1);

    // Prüfen ob aktueller Wert zu hoch ist
    validateWorkPlaneHeight();
}

function validateWorkPlaneHeight() {
    const mountingHeight = parseFloat(document.getElementById('mountingHeight').value) || 2.8;
    const workPlaneHeightInput = document.getElementById('workPlaneHeight');
    const workPlaneHeight = parseFloat(workPlaneHeightInput.value);

    // Arbeitsebene muss mindestens 10cm unter der Montagehöhe sein
    const maxAllowed = mountingHeight - 0.1;

    if (workPlaneHeight >= mountingHeight) {
        // Wert auf Maximum korrigieren
        workPlaneHeightInput.value = Math.max(0, maxAllowed);

        // Visuelle Warnung
        workPlaneHeightInput.classList.add('is-invalid');
        setTimeout(() => {
            workPlaneHeightInput.classList.remove('is-invalid');
        }, 2000);

        // Toast-Benachrichtigung
        showValidationMessage('Die Arbeitsebene muss unter der Montagehöhe liegen!');
    }
}

function showValidationMessage(message) {
    // Einfache Alert-Alternative
    const alertDiv = document.createElement('div');
    alertDiv.className = 'alert alert-warning alert-dismissible fade show position-fixed';
    alertDiv.style.top = '20px';
    alertDiv.style.right = '20px';
    alertDiv.style.zIndex = '9999';
    alertDiv.style.maxWidth = '400px';
    alertDiv.innerHTML = `
        <strong>Achtung:</strong> ${message}
        <button type="button" class="btn-close" onclick="this.parentElement.remove()"></button>
    `;

    document.body.appendChild(alertDiv);

    // Nach 3 Sekunden automatisch entfernen
    setTimeout(() => {
        if (alertDiv.parentElement) {
            alertDiv.remove();
        }
    }, 3000);
}

// PDF-Bibliotheken laden
async function loadPDFLibraries() {
    return new Promise((resolve, reject) => {
        if (typeof window.jspdf !== 'undefined') {
            resolve();
            return;
        }

        // jsPDF laden
        const jsPDFScript = document.createElement('script');
        jsPDFScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
        jsPDFScript.onload = () => {
            console.log('jsPDF Script geladen');
            // Kurz warten damit das window-Objekt aktualisiert wird
            setTimeout(() => {
                console.log('window.jspdf nach laden:', window.jspdf);
                // html2canvas laden
                const html2canvasScript = document.createElement('script');
                html2canvasScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js';
                html2canvasScript.onload = () => {
                    console.log('html2canvas Script geladen');
                    setTimeout(() => resolve(), 100);
                };
                html2canvasScript.onerror = () => reject('html2canvas konnte nicht geladen werden');
                document.head.appendChild(html2canvasScript);
            }, 100);
        };
        jsPDFScript.onerror = () => reject('jsPDF konnte nicht geladen werden');
        document.head.appendChild(jsPDFScript);
    });
}

// PDF Generation
async function generatePDF() {
    try {
        // PDF-Button deaktivieren und Loading-Zustand anzeigen
        const pdfButton = document.getElementById('pdfButton');
        pdfButton.disabled = true;
        pdfButton.innerHTML = '<i class="bi bi-hourglass-split me-2"></i>Lade Bibliotheken...';

        // PDF-Bibliotheken laden falls noch nicht verfügbar
        await loadPDFLibraries();

        pdfButton.innerHTML = '<i class="bi bi-hourglass-split me-2"></i>Generiere PDF...';

    } catch (error) {
        console.error('Fehler beim Laden der PDF-Bibliotheken:', error);
        alert('Fehler beim Laden der PDF-Bibliotheken: ' + error);
        const pdfButton = document.getElementById('pdfButton');
        pdfButton.disabled = false;
        pdfButton.innerHTML = '<i class="bi bi-file-earmark-pdf me-2"></i>PDF Export';
        return;
    }

    // Jetzt PDF generieren
    try {
        console.log('window.jspdf:', window.jspdf);
        console.log('window.jsPDF:', window.jsPDF);
        console.log('typeof window.jspdf:', typeof window.jspdf);

        // Verschiedene mögliche Varianten prüfen
        let jsPDF = null;

        if (window.jspdf && window.jspdf.jsPDF) {
            jsPDF = window.jspdf.jsPDF;
        } else if (window.jsPDF) {
            jsPDF = window.jsPDF;
        } else if (typeof window.jspdf === 'function') {
            jsPDF = window.jspdf;
        }

        console.log('Gefundene jsPDF:', jsPDF);

        if (!jsPDF) {
            throw new Error('jsPDF konnte nicht gefunden werden. Verfügbare Objekte: ' + Object.keys(window).filter(k => k.toLowerCase().includes('pdf')));
        }

        const pdf = new jsPDF('p', 'mm', 'a4');

        // UTF-8 Unterstützung für deutsche Umlaute
        pdf.addFont('helvetica', 'normal');
        pdf.setFont('helvetica', 'normal');

        const pageWidth = pdf.internal.pageSize.getWidth();
        const pageHeight = pdf.internal.pageSize.getHeight();
        const margin = 20;
        const lineHeight = 6;
        const headerHeight = 50;
        const footerHeight = 30;
        const contentAreaHeight = pageHeight - headerHeight - footerHeight;
        let yPosition = headerHeight + 15; // Start nach Header

        // Header-Box mit Hintergrund
        pdf.setFillColor(40, 116, 166);
        pdf.rect(0, 0, pageWidth, 50, 'F');

        // Logo/Titel
        pdf.setFontSize(20);
        pdf.setTextColor(255, 255, 255);
        pdf.setFont(undefined, 'bold');
        pdf.text('Beleuchtungsrechner - Berechnungsbericht', 20, 30);

        // Datum
        pdf.setFontSize(10);
        pdf.text(`Erstellt am: ${new Date().toLocaleDateString('de-DE', {
            year: 'numeric',
            month: 'long',
            day: 'numeric'
        })}`, pageWidth - 80, 45);

        yPosition = headerHeight + 15;

        // Hilfsfunktion für neue Seite
        function checkPageBreak(neededSpace = 30) {
            const maxContentY = pageHeight - footerHeight;
            if (yPosition + neededSpace > maxContentY) {
                pdf.addPage();
                addHeader(); // Header auf neuer Seite hinzufügen
                yPosition = headerHeight + 15;
                return true;
            }
            return false;
        }

        // Hilfsfunktion für Sektion-Header
        function addSectionHeader(title, icon = '') {
            checkPageBreak(25);

            // Sektion-Hintergrund
            pdf.setFillColor(248, 249, 250);
            pdf.rect(margin, yPosition - 5, pageWidth - 2 * margin, 15, 'F');

            // Sektion-Rahmen
            pdf.setDrawColor(200, 200, 200);
            pdf.rect(margin, yPosition - 5, pageWidth - 2 * margin, 15, 'S');

            pdf.setFontSize(14);
            pdf.setFont(undefined, 'bold');
            pdf.setTextColor(40, 116, 166);
            pdf.text(title, margin + 5, yPosition + 5); // Kein Icon mehr
            yPosition += 20;

            pdf.setTextColor(0, 0, 0);
        }

        // Hilfsfunktion für Header auf jeder neuen Seite
        function addHeader() {
            // Header-Box mit Hintergrund
            pdf.setFillColor(40, 116, 166);
            pdf.rect(0, 0, pageWidth, headerHeight, 'F');

            // Titel
            pdf.setFontSize(16);
            pdf.setTextColor(255, 255, 255);
            pdf.setFont(undefined, 'bold');
            pdf.text('Beleuchtungsrechner - Berechnungsbericht', margin, 25);

            // Datum
            pdf.setFontSize(9);
            const headerDate = new Date().toLocaleDateString('de-DE');
            pdf.text(headerDate, pageWidth - 50, 35);

            pdf.setTextColor(0, 0, 0);
        }

        // Eingabeparameter
        addSectionHeader('1. Eingabeparameter', '');

        pdf.setFontSize(11);
        pdf.setFont(undefined, 'normal');

        const selectedLamp = lampDatabase.find(l => l.id == document.getElementById('selectedLamp').value);
        const roomWidth = document.getElementById('roomWidth').value;
        const roomLength = document.getElementById('roomLength').value;
        const roomHeight = document.getElementById('roomHeight').value;
        const mountingHeight = document.getElementById('mountingHeight').value;
        const workPlaneHeight = document.getElementById('workPlaneHeight').value;
        const targetLux = document.getElementById('targetLux').value;
        const maintenanceFactor = document.getElementById('maintenanceFactor').value;
        const reflectionFactor = document.getElementById('reflectionFactor').value;

        // Eingabeparameter als schöne Tabelle
        const inputData = [
            ['Ausgewählte Leuchte:', `${selectedLamp.name}`],
            ['Lichtstrom pro Leuchte:', `${selectedLamp.lumen.toLocaleString()} lm`],
            ['Leistung pro Leuchte:', `${selectedLamp.watt} W`],
            ['Raumabmessungen:', `${roomWidth} × ${roomLength} × ${roomHeight} m`],
            ['Raumfläche:', `${(roomWidth * roomLength).toFixed(1)} m²`],
            ['Montagehöhe der Leuchten:', `${mountingHeight} m`],
            ['Höhe der Arbeitsebene:', `${workPlaneHeight} m`],
            ['Gewünschte Beleuchtungsstärke:', `${targetLux} lx`],
            ['Wartungsfaktor:', `${maintenanceFactor}`],
            ['Reflexionsgrad der Wände:', `${(parseFloat(reflectionFactor) * 100).toFixed(0)}%`]
        ];

        // Tabellen-Header
        pdf.setFillColor(240, 240, 240);
        pdf.rect(margin + 5, yPosition - 3, pageWidth - 2 * margin - 10, 8, 'F');
        pdf.setFont(undefined, 'bold');
        pdf.text('Parameter', margin + 10, yPosition + 2);
        pdf.text('Wert', margin + 100, yPosition + 2);
        yPosition += 12;

        pdf.setFont(undefined, 'normal');
        inputData.forEach(([param, value]) => {
            checkPageBreak();

            // Alternierende Zeilenhintergründe
            if (inputData.indexOf([param, value]) % 2 === 1) {
                pdf.setFillColor(250, 250, 250);
                pdf.rect(margin + 5, yPosition - 3, pageWidth - 2 * margin - 10, 7, 'F');
            }

            pdf.text(param, margin + 10, yPosition + 1);
            pdf.setFont(undefined, 'bold');
            pdf.text(value, margin + 100, yPosition + 1);
            pdf.setFont(undefined, 'normal');
            yPosition += lineHeight + 1;
        });

        yPosition += 10;

        // Berechnungsergebnisse
        addSectionHeader('2. Berechnungsergebnisse', '');

        // Hauptergebnisse hervorheben
        const mainResults = [
            ['Anzahl benötigter Leuchten:', `${document.getElementById('lampCountRounded').textContent} Stück`, 'highlight'],
            ['Tatsächliche Beleuchtungsstärke:', `${document.getElementById('actualLux').textContent} lx`, 'highlight'],
            ['Gesamtleistung:', `${document.getElementById('totalPower').textContent} W`, 'highlight']
        ];

        // Detailergebnisse
        const detailResults = [
            ['Raumfläche (A):', `${document.getElementById('calcRoomArea').textContent} m²`],
            ['Raumindex (k):', `${document.getElementById('calcRoomIndex').textContent}`],
            ['Raumwirkungsgrad (η):', `${document.getElementById('calcUtilizationFactor').textContent}`],
            ['Benötigter Gesamtlichtstrom (Φₘₑₛₐₘₜ):', `${document.getElementById('calcTotalLumen').textContent} lm`],
            ['Exakte Leuchtenzahl (n):', `${document.getElementById('lampCountExact').textContent}`],
            ['Spezifische Leistung:', `${document.getElementById('specificPower').textContent} W/m²`],
            ['Effizienz:', `${document.getElementById('specificPowerPer100lx').textContent} W/m²/100lx`]
        ];

        // Hauptergebnisse Box - größere Höhe für alle Inhalte
        const mainResultsBoxHeight = mainResults.length * 10 + 20; // Mehr Platz
        pdf.setFillColor(232, 245, 233);
        pdf.rect(margin + 5, yPosition - 3, pageWidth - 2 * margin - 10, mainResultsBoxHeight, 'F');
        pdf.setDrawColor(76, 175, 80);
        pdf.rect(margin + 5, yPosition - 3, pageWidth - 2 * margin - 10, mainResultsBoxHeight, 'S');

        pdf.setFont(undefined, 'bold');
        pdf.setFontSize(12);
        pdf.setTextColor(76, 175, 80);
        pdf.text('Hauptergebnisse:', margin + 10, yPosition + 5);
        yPosition += 15;

        pdf.setFontSize(11);
        pdf.setTextColor(0, 0, 0);
        mainResults.forEach(([param, value]) => {
            pdf.text(param, margin + 15, yPosition);
            pdf.setFont(undefined, 'bold');
            pdf.text(value, margin + 120, yPosition);
            pdf.setFont(undefined, 'normal');
            yPosition += 8;
        });

        yPosition += 15;

        // Detailergebnisse
        pdf.setFont(undefined, 'bold');
        pdf.setFontSize(11);
        pdf.text('Detaillierte Berechnungswerte:', margin + 10, yPosition);
        yPosition += 10;

        pdf.setFont(undefined, 'normal');
        detailResults.forEach(([param, value]) => {
            checkPageBreak();
            pdf.text(param, margin + 15, yPosition);
            pdf.text(value, margin + 120, yPosition);
            yPosition += lineHeight + 1;
        });

        yPosition += 10;

        // Schritt-für-Schritt Berechnung
        addSectionHeader('3. Detaillierte Berechnung', '');

        const calculations = [
            {
                step: '1',
                title: 'Raumfläche berechnen',
                formula: 'A = L x B',
                calculation: `A = ${roomWidth} m x ${roomLength} m = ${document.getElementById('stepRoomArea').textContent} m²`
            },
            {
                step: '2',
                title: 'Abstand Leuchte zu Arbeitsebene',
                formula: 'h = h_montage - h_arbeitsebene',
                calculation: `h = ${mountingHeight} m - ${workPlaneHeight} m = ${document.getElementById('stepH').textContent} m`
            },
            {
                step: '3',
                title: 'Raumindex berechnen',
                formula: 'k = (L x B) / (h x (L + B))',
                calculation: `k = (${roomWidth} m x ${roomLength} m) / (${document.getElementById('stepH').textContent} m x (${roomWidth} m + ${roomLength} m)) = ${document.getElementById('stepK').textContent}`
            },
            {
                step: '4',
                title: 'Basis-Raumwirkungsgrad',
                formula: 'eta0 (abhaengig vom Raumindex k)',
                calculation: `eta0 = ${document.getElementById('stepBaseEta').textContent} %`
            },
            {
                step: '5',
                title: 'Korrigierter Raumwirkungsgrad',
                formula: 'eta = eta0 x (0,7 + 0,3 x rho)',
                calculation: `eta = ${document.getElementById('stepBaseEta2').textContent} x (0,7 + 0,3 x ${reflectionFactor}) = ${document.getElementById('stepFinalEta').textContent}`
            },
            {
                step: '6',
                title: 'Benötigter Gesamtlichtstrom',
                formula: 'Phi_gesamt = (E x A) / (eta x W)',
                calculation: `Phi_gesamt = (${targetLux} lx x ${document.getElementById('stepAreaCalc').textContent} m²) / (${document.getElementById('stepEtaCalc').textContent} x ${maintenanceFactor}) = ${document.getElementById('stepTotalLumen').textContent} lm`
            },
            {
                step: '7',
                title: 'Exakte Leuchtenzahl',
                formula: 'n = Phi_gesamt / Phi_leuchte',
                calculation: `n = ${document.getElementById('stepTotalLumen2').textContent} lm / ${document.getElementById('stepLampLumen').textContent} lm = ${document.getElementById('stepExactCount').textContent}`
            },
            {
                step: '8',
                title: 'Aufgerundete Leuchtenzahl',
                formula: 'n = ceil(n_exakt)',
                calculation: `n = ceil(${document.getElementById('stepExactCount').textContent}) = ${document.getElementById('stepRoundedCount').textContent} Stueck`
            },
            {
                step: '9',
                title: 'Tatsächliche Beleuchtungsstärke',
                formula: 'E = (n x Phi_leuchte x eta x W) / A',
                calculation: `E = (${document.getElementById('stepFinalCount').textContent} x ${document.getElementById('stepFinalLampLumen').textContent} lm x ${document.getElementById('stepFinalEta').textContent} x ${document.getElementById('stepFinalMaintenance').textContent}) / ${document.getElementById('stepFinalArea').textContent} m² = ${document.getElementById('stepActualLux').textContent} lx`
            },
            {
                step: '10',
                title: 'Gesamtleistung',
                formula: 'P_gesamt = n x P_leuchte',
                calculation: `P_gesamt = ${document.getElementById('stepFinalCount2').textContent} x ${document.getElementById('stepLampWatt').textContent} W = ${document.getElementById('stepTotalPower').textContent} W`
            }
        ];

        calculations.forEach((calc, index) => {
            checkPageBreak(30); // Mehr Platz für Schritt-Boxen

            // Schritt-Box
            pdf.setFillColor(245, 245, 245);
            pdf.rect(margin + 5, yPosition - 2, pageWidth - 2 * margin - 10, 20, 'F');
            pdf.setDrawColor(220, 220, 220);
            pdf.rect(margin + 5, yPosition - 2, pageWidth - 2 * margin - 10, 20, 'S');

            // Schritt-Nummer
            pdf.setFillColor(40, 116, 166);
            pdf.circle(margin + 15, yPosition + 8, 6, 'F');
            pdf.setTextColor(255, 255, 255);
            pdf.setFont(undefined, 'bold');
            pdf.setFontSize(10);
            pdf.text(calc.step, margin + 12, yPosition + 10);

            // Titel
            pdf.setTextColor(0, 0, 0);
            pdf.setFontSize(11);
            pdf.text(calc.title, margin + 25, yPosition + 5);

            // Formel
            pdf.setFont(undefined, 'italic');
            pdf.setFontSize(9);
            pdf.text(calc.formula, margin + 25, yPosition + 11);

            // Berechnung
            pdf.setFont(undefined, 'normal');
            pdf.setFontSize(10);
            const calcText = pdf.splitTextToSize(calc.calculation, pageWidth - 2 * margin - 40);
            pdf.text(calcText, margin + 25, yPosition + 16);

            yPosition += 25;
        });

        yPosition += 10;

        // Visualisierung hinzufügen - erweiterte Suche
        console.log('=== VISUALISIERUNG DEBUG ===');

        // Alle möglichen Canvas-Elemente suchen
        const canvas = document.querySelector('#canvas-container canvas') ||
                      document.querySelector('canvas') ||
                      document.querySelector('#canvas-container > canvas');

        const room2d = document.getElementById('room2d');

        console.log('Canvas gefunden:', canvas);
        console.log('Canvas-Container Inhalt:', document.getElementById('canvas-container')?.innerHTML?.substring(0, 200));
        console.log('Room2D gefunden:', room2d);
        console.log('Room2D Inhalt:', room2d?.innerHTML?.substring(0, 200));

        // Alle Canvas-Elemente auf der Seite loggen
        const allCanvases = document.querySelectorAll('canvas');
        console.log('Alle Canvas-Elemente:', allCanvases.length);
        allCanvases.forEach((c, i) => {
            console.log(`Canvas ${i}:`, c.id, c.className, c.width + 'x' + c.height);
        });

        if (canvas || room2d) {
            addSectionHeader('4. Raumvisualisierung', '');

            try {
                if (canvas && canvas.width > 0 && canvas.height > 0) {
                    console.log('Canvas gefunden:', canvas.width, 'x', canvas.height);
                    console.log('Canvas-Context:', canvas.getContext('webgl') || canvas.getContext('2d'));

                    // Versuche 3D-Szene nochmal zu rendern falls vorhanden
                    if (typeof renderer !== 'undefined' && renderer && scene && camera) {
                        console.log('Renderer verfügbar, rendere 3D-Szene...');

                        // Szene-Hintergrund auf weiß setzen
                        scene.background = new THREE.Color(0xffffff);

                        // Sicherstellen dass Objekte sichtbar sind
                        scene.traverse(function(child) {
                            if (child instanceof THREE.Mesh) {
                                child.visible = true;
                                console.log('Mesh gefunden:', child.userData);
                            }
                        });

                        // Mehrfach rendern für bessere Ergebnisse
                        for (let i = 0; i < 3; i++) {
                            renderer.render(scene, camera);
                            await new Promise(resolve => setTimeout(resolve, 200));
                        }

                        // Szene nochmal mit weißem Hintergrund clearen und rendern
                        renderer.setClearColor(0xffffff, 1.0);
                        renderer.clear();
                        renderer.render(scene, camera);

                        console.log('3D-Szene gerendert, warte 1 Sekunde...');
                        await new Promise(resolve => setTimeout(resolve, 1000)); // Länger warten
                    }

                    // Separates 2D-Canvas für PDF erstellen
                    let imgData;
                    try {
                        console.log('Erstelle separates 2D-Canvas für PDF...');
                        const pdfCanvas = document.createElement('canvas');
                        pdfCanvas.width = 400;
                        pdfCanvas.height = 300;
                        const pdfCtx = pdfCanvas.getContext('2d');

                        // Weißer Hintergrund
                        pdfCtx.fillStyle = 'white';
                        pdfCtx.fillRect(0, 0, pdfCanvas.width, pdfCanvas.height);

                        // Raum zeichnen
                        const roomWidthNum = parseFloat(roomWidth);
                        const roomLengthNum = parseFloat(roomLength);
                        const lampCount = parseInt(document.getElementById('lampCountRounded')?.textContent || '0');

                        drawRoomToPDFCanvas(pdfCtx, pdfCanvas.width, pdfCanvas.height, roomWidthNum, roomLengthNum, lampCount);

                        imgData = pdfCanvas.toDataURL('image/png', 1.0);
                        console.log('PDF-Canvas erstellt, Daten-Länge:', imgData.length);
                    } catch (e) {
                        console.error('Canvas toDataURL Fehler:', e);
                        throw e;
                    }

                    // Prüfung ob Canvas nicht leer ist
                    if (imgData && imgData !== 'data:,' && imgData.length > 50) {
                        checkPageBreak(110); // Genug Platz für Bild

                        // Rahmen für Visualisierung
                        pdf.setDrawColor(200, 200, 200);
                        pdf.rect(margin + 10, yPosition, 130, 90, 'S');

                        try {
                            pdf.addImage(imgData, 'PNG', margin + 15, yPosition + 5, 120, 80);
                            console.log('Bild erfolgreich zu PDF hinzugefügt');
                        } catch (e) {
                            console.error('Fehler beim Hinzufügen des Bildes zur PDF:', e);
                            throw e;
                        }

                        // Beschriftung
                        pdf.setFontSize(10);
                        pdf.setFont(undefined, 'italic');
                        pdf.text('3D-Raumdarstellung mit Leuchtenpositionen', margin + 15, yPosition + 95);

                        yPosition += 105;
                    } else {
                        console.log('Canvas-Daten sind leer oder ungültig');
                        pdf.setFontSize(11);
                        pdf.text('3D-Canvas ist leer - keine Visualisierung verfügbar.', margin + 15, yPosition);
                        pdf.text('Möglicherweise wurde noch keine Berechnung durchgeführt.', margin + 15, yPosition + 12);
                        yPosition += 25;
                    }
                } else if (room2d && typeof html2canvas !== 'undefined') {
                    console.log('2D-Room gefunden, versuche html2canvas...');
                    console.log('Room2D Größe:', room2d.offsetWidth, 'x', room2d.offsetHeight);

                    try {
                        const canvas2d = await html2canvas(room2d, {
                            backgroundColor: '#ffffff',
                            scale: 2,
                            useCORS: true,
                            logging: true
                        });
                        console.log('html2canvas erfolgreich, Canvas:', canvas2d.width, 'x', canvas2d.height);

                        const imgData2d = canvas2d.toDataURL('image/png', 1.0);
                        console.log('2D-Canvas-Daten extrahiert, Länge:', imgData2d.length);

                        if (imgData2d && imgData2d !== 'data:,' && imgData2d.length > 50) {
                            checkPageBreak(90); // Genug Platz für 2D-Bild

                            // Rahmen für Visualisierung
                            pdf.setDrawColor(200, 200, 200);
                            pdf.rect(margin + 10, yPosition, 110, 70, 'S');

                            pdf.addImage(imgData2d, 'PNG', margin + 15, yPosition + 5, 100, 60);
                            console.log('2D-Bild erfolgreich zu PDF hinzugefügt');

                            // Beschriftung
                            pdf.setFontSize(10);
                            pdf.setFont(undefined, 'italic');
                            pdf.text('2D-Raumdarstellung (Draufsicht)', margin + 15, yPosition + 75);

                            yPosition += 85;
                        } else {
                            pdf.text('2D-Canvas ist leer.', margin + 15, yPosition);
                            yPosition += 20;
                        }
                    } catch (html2canvasError) {
                        console.error('html2canvas Fehler:', html2canvasError);
                        pdf.text('Fehler beim 2D-Screenshot: ' + html2canvasError.message, margin + 15, yPosition);
                        yPosition += 20;
                    }
                } else {
                    // Fallback: Erstelle einfache schematische Darstellung
                    console.log('Keine Visualisierung gefunden, erstelle schematische Darstellung');

                    checkPageBreak(100);

                    // Titel
                    pdf.setFontSize(11);
                    pdf.setFont(undefined, 'bold');
                    pdf.text('Schematische Raumdarstellung', margin + 15, yPosition);
                    yPosition += 15;

                    // Raum-Schema zeichnen
                    const schemaWidth = 120;
                    const schemaHeight = 80;
                    const roomWidthNum = parseFloat(roomWidth);
                    const roomLengthNum = parseFloat(roomLength);
                    const lampCount = parseInt(document.getElementById('lampCountRounded')?.textContent || '0');

                    // Raum-Rechteck
                    pdf.setDrawColor(100, 100, 100);
                    pdf.setLineWidth(1);
                    pdf.rect(margin + 15, yPosition, schemaWidth, schemaHeight, 'S');

                    // Maße beschriften
                    pdf.setFontSize(9);
                    pdf.setFont(undefined, 'normal');
                    pdf.text(`${roomWidthNum}m`, margin + 15 + schemaWidth/2 - 10, yPosition - 5);
                    pdf.text(`${roomLengthNum}m`, margin + 5, yPosition + schemaHeight/2);

                    // Leuchten als Punkte einzeichnen
                    if (lampCount > 0) {
                        // Berechne Anordnung
                        let cols, rows;
                        if (lampCount === 1) {
                            cols = 1; rows = 1;
                        } else if (lampCount === 2) {
                            cols = 2; rows = 1;
                        } else if (lampCount <= 4) {
                            cols = 2; rows = Math.ceil(lampCount / 2);
                        } else {
                            const aspectRatio = roomWidthNum / roomLengthNum;
                            cols = Math.ceil(Math.sqrt(lampCount * aspectRatio));
                            rows = Math.ceil(lampCount / cols);
                            if (cols * (rows - 1) >= lampCount) rows = rows - 1;
                        }

                        const spacingX = schemaWidth / (cols + 1);
                        const spacingY = schemaHeight / (rows + 1);

                        pdf.setFillColor(255, 215, 0); // Gold für Leuchten

                        let lampIndex = 0;
                        for (let row = 0; row < rows && lampIndex < lampCount; row++) {
                            for (let col = 0; col < cols && lampIndex < lampCount; col++) {
                                const x = margin + 15 + spacingX * (col + 1);
                                const y = yPosition + spacingY * (row + 1);
                                pdf.circle(x, y, 3, 'F');
                                lampIndex++;
                            }
                        }
                    }

                    // Legende
                    pdf.setFontSize(8);
                    pdf.text(`${lampCount} Leuchten schematisch dargestellt`, margin + 15, yPosition + schemaHeight + 10);

                    yPosition += schemaHeight + 20;
                }
            } catch (e) {
                console.error('Fehler beim Visualisierung-Export:', e);
                pdf.setFontSize(11);
                pdf.text('Fehler beim Export der Visualisierung: ' + e.message, margin + 15, yPosition);
                yPosition += 20;
            }
        }

        // Gleichmaessigkeits-Bewertung
        checkPageBreak(60);
        addSectionHeader('5. Leuchtverteilung und Gleichmäßigkeit', '');

        const lampCount = parseInt(document.getElementById('lampCountRounded').textContent);
        const roomWidthNum = parseFloat(roomWidth);
        const roomLengthNum = parseFloat(roomLength);

        // Berechne tatsaechliche Verteilung
        let cols, rows;
        if (lampCount === 1) {
            cols = 1; rows = 1;
        } else if (lampCount === 2) {
            cols = 2; rows = 1;
        } else if (lampCount <= 4) {
            cols = 2; rows = Math.ceil(lampCount / 2);
        } else {
            const aspectRatio = roomWidthNum / roomLengthNum;
            cols = Math.ceil(Math.sqrt(lampCount * aspectRatio));
            rows = Math.ceil(lampCount / cols);
            if (cols * (rows - 1) >= lampCount) rows = rows - 1;
        }

        const actualLamps = cols * rows;
        const spacingX = roomWidthNum / (cols + 1);
        const spacingZ = roomLengthNum / (rows + 1);

        pdf.setFontSize(11);
        pdf.setFont(undefined, 'normal');

        const distributionInfo = [
            `Berechnete Leuchtenzahl: ${lampCount} Stück`,
            `Tatsächliche Anordnung: ${cols} x ${rows} = ${actualLamps} Leuchten`,
            `Abstand zwischen Leuchten: ${spacingX.toFixed(2)}m x ${spacingZ.toFixed(2)}m`,
            '',
            'Hinweis zur Gleichmäßigkeit:'
        ];

        distributionInfo.forEach(line => {
            if (line === '') {
                yPosition += 4;
            } else {
                checkPageBreak();
                if (line.includes('Hinweis')) {
                    pdf.setFont(undefined, 'bold');
                }
                pdf.text(line, margin + 15, yPosition);
                pdf.setFont(undefined, 'normal');
                yPosition += lineHeight;
            }
        });

        yPosition += 5;

        // Warnung Box fuer ungleichmaessige Verteilung
        if (actualLamps > lampCount) {
            pdf.setFillColor(255, 243, 205);
            pdf.rect(margin + 5, yPosition - 3, pageWidth - 2 * margin - 10, 25, 'F');
            pdf.setDrawColor(255, 193, 7);
            pdf.rect(margin + 5, yPosition - 3, pageWidth - 2 * margin - 10, 25, 'S');

            pdf.setFont(undefined, 'bold');
            pdf.setTextColor(133, 100, 4);
            pdf.text('ACHTUNG: Ungleichmäßige Verteilung!', margin + 10, yPosition + 5);

            pdf.setFont(undefined, 'normal');
            pdf.setTextColor(0, 0, 0);
            pdf.text(`Es werden ${actualLamps} statt ${lampCount} Leuchten benötigt für`, margin + 10, yPosition + 12);
            pdf.text('eine gleichmäßige Anordnung. Alternative Lösungen prüfen!', margin + 10, yPosition + 18);

            yPosition += 30;
        } else if (lampCount === actualLamps) {
            pdf.setFillColor(212, 237, 218);
            pdf.rect(margin + 5, yPosition - 3, pageWidth - 2 * margin - 10, 15, 'F');
            pdf.setDrawColor(40, 167, 69);
            pdf.rect(margin + 5, yPosition - 3, pageWidth - 2 * margin - 10, 15, 'S');

            pdf.setFont(undefined, 'bold');
            pdf.setTextColor(21, 87, 36);
            pdf.text('Gleichmaessige Verteilung moeglich!', margin + 10, yPosition + 8);

            yPosition += 20;
        }

        pdf.setTextColor(0, 0, 0);

        // Lichtverteilungsdiagramme hinzufügen
        try {
            const distributionCanvas = document.getElementById('distributionCanvas');
            if (distributionCanvas && distributionCanvas.width > 0 && distributionCanvas.height > 0) {
                checkPageBreak(120);

                // Untertitel für Lichtverteilungsdiagramme
                pdf.setFontSize(12);
                pdf.setFont(undefined, 'bold');
                pdf.text('5.1 Lichtverteilungskurven (EULUMDAT)', margin + 15, yPosition);
                yPosition += 15;

                // Canvas als Bild in PDF einbetten
                const imgData = distributionCanvas.toDataURL('image/png', 1.0);
                const canvasAspectRatio = distributionCanvas.width / distributionCanvas.height;

                // Diagramm-Größe berechnen (maximal 160mm breit)
                const maxWidth = 160;
                const maxHeight = 90;
                let imgWidth = maxWidth;
                let imgHeight = maxWidth / canvasAspectRatio;

                if (imgHeight > maxHeight) {
                    imgHeight = maxHeight;
                    imgWidth = imgHeight * canvasAspectRatio;
                }

                // Diagramm zentriert platzieren
                const imgX = (pageWidth - imgWidth) / 2;
                pdf.addImage(imgData, 'PNG', imgX, yPosition, imgWidth, imgHeight);
                yPosition += imgHeight + 15;

                // Beschreibung unter dem Diagramm
                pdf.setFontSize(9);
                pdf.setFont(undefined, 'normal');
                pdf.setTextColor(80, 80, 80);

                const description = [
                    'Photometrische Lichtverteilungskurven der Leuchte basierend auf EULUMDAT-Daten.',
                    'Links: C0-C180 (Längsrichtung), Rechts: C90-C270 (Querrichtung)',
                    'Intensität in cd/1000 lm, Winkel in Grad (0° = nadir, 90° = horizontal)'
                ];

                description.forEach(line => {
                    checkPageBreak();
                    pdf.text(line, margin + 15, yPosition);
                    yPosition += 4;
                });

                yPosition += 10;
                pdf.setTextColor(0, 0, 0);

                console.log('✓ Lichtverteilungsdiagramm in PDF eingefügt');
            } else {
                console.log('⚠ Kein Lichtverteilungsdiagramm gefunden oder Canvas leer');
            }
        } catch (lightDistError) {
            console.error('Fehler beim Export der Lichtverteilungsdiagramme:', lightDistError);
            checkPageBreak(20);
            pdf.setFontSize(9);
            pdf.setTextColor(200, 50, 50);
            pdf.text('Lichtverteilungsdiagramme konnten nicht exportiert werden.', margin + 15, yPosition);
            yPosition += 15;
            pdf.setTextColor(0, 0, 0);
        }

        // Variablenerklärung hinzufügen
        checkPageBreak(50);
        addSectionHeader('6. Verwendete Symbole und Variablen', '');

        const variables = [
            ['A', 'Raumflaeche [m²]'],
            ['L, B', 'Raumlaenge und -breite [m]'],
            ['h', 'Abstand Leuchte zu Arbeitsebene [m]'],
            ['k', 'Raumindex [-]'],
            ['E', 'Beleuchtungsstaerke [lx]'],
            ['eta0', 'Basis-Raumwirkungsgrad [%]'],
            ['eta', 'Korrigierter Raumwirkungsgrad [%]'],
            ['rho', 'Reflexionsgrad [-]'],
            ['W', 'Wartungsfaktor [-]'],
            ['Phi_gesamt', 'Benoetigter Gesamtlichtstrom [lm]'],
            ['Phi_leuchte', 'Lichtstrom einer Leuchte [lm]'],
            ['n', 'Anzahl der Leuchten [Stueck]'],
            ['ceil(x)', 'Aufrundungsfunktion'],
            ['P_gesamt', 'Gesamtleistung [W]'],
            ['P_leuchte', 'Leistung einer Leuchte [W]']
        ];

        pdf.setFontSize(10);
        pdf.setFont(undefined, 'normal');

        variables.forEach(([symbol, description]) => {
            checkPageBreak();
            pdf.setFont(undefined, 'bold');
            pdf.text(symbol, margin + 15, yPosition);
            pdf.setFont(undefined, 'normal');
            pdf.text(description, margin + 50, yPosition);
            yPosition += lineHeight + 1;
        });

        yPosition += 10;

        addSectionHeader('7. Zusätzliche Hinweise', '');

        const notes = [
            'Diese Berechnung basiert auf der Lumen-Methode nach DIN EN 12464-1.',
            'Die Werte sind als Richtwerte zu verstehen und können je nach',
            'spezifischen Anforderungen angepasst werden.',
            '',
            'Für eine detaillierte lichttechnische Planung empfehlen wir die',
            'Konsultation eines Lichtplaners oder Elektroplaners.',
            '',
            'Bei Fragen zur Berechnung stehen Ihnen Fachplaner',
            'gerne zur Verfügung.'
        ];

        pdf.setFontSize(10);
        pdf.setFont(undefined, 'normal');
        notes.forEach(note => {
            if (note === '') {
                yPosition += 4;
            } else {
                checkPageBreak();
                pdf.text(note, margin + 15, yPosition);
                yPosition += lineHeight;
            }
        });

        // Footer für alle Seiten
        const pageCount = pdf.internal.getNumberOfPages();
        for (let i = 1; i <= pageCount; i++) {
            pdf.setPage(i);

            // Footer-Position berechnen
            const footerY = pageHeight - footerHeight;

            // Footer-Linie
            pdf.setDrawColor(200, 200, 200);
            pdf.line(margin, footerY + 5, pageWidth - margin, footerY + 5);

            // Footer-Inhalte
            pdf.setFontSize(9);
            pdf.setTextColor(100, 100, 100);
            pdf.setFont(undefined, 'normal');

            // Links: Tool-Info
            pdf.text('Erstellt mit Beleuchtungsrechner', margin, footerY + 15);

            // Mitte: Datum
            const footerDate = new Date().toLocaleDateString('de-DE');
            pdf.text(footerDate, pageWidth / 2 - 15, footerY + 15);

            // Rechts: Seitenzahl
            pdf.text(`Seite ${i} von ${pageCount}`, pageWidth - 40, footerY + 15);

            // Header für Folgeseiten hinzufügen (außer erste Seite)
            if (i > 1) {
                addHeader();
            }
        }

        // PDF speichern
        const fileName = `Beleuchtungsberechnung_${roomWidth}x${roomLength}m_${new Date().toISOString().split('T')[0]}.pdf`;
        pdf.save(fileName);

    } catch (error) {
        console.error('Fehler beim PDF-Export:', error);
        alert('Fehler beim Erstellen der PDF-Datei!');
    } finally {
        // Button wieder aktivieren
        const pdfButton = document.getElementById('pdfButton');
        pdfButton.disabled = false;
        pdfButton.innerHTML = '<i class="bi bi-file-earmark-pdf me-2"></i>PDF Export';
    }
}

// Umfassende Berechnungsanleitung als PDF generieren
async function generateCalculationGuidePDF() {
    const button = document.querySelector('button[onclick="generateCalculationGuidePDF()"]');

    try {
        // Button-Status anzeigen
        if (button) {
            button.disabled = true;
            button.innerHTML = '<i class="bi bi-hourglass-split me-2"></i>Lade Bibliotheken...';
        }

        // PDF-Bibliotheken laden falls noch nicht verfügbar
        await loadPDFLibraries();

        if (button) {
            button.innerHTML = '<i class="bi bi-hourglass-split me-2"></i>Generiere PDF...';
        }

        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF('p', 'mm', 'a4');

        // ===== MODERNE DESIGN-KONSTANTEN =====
        let yPosition = 25;
        const margin = 25;
        const pageWidth = 210;
        const pageHeight = 297;
        const contentWidth = pageWidth - (2 * margin);
        const lineHeight = 5;
        const sectionSpacing = 15;
        const subSectionSpacing = 10;

        // Moderne Farbpalette
        const colors = {
            primary: [41, 98, 255],        // Modernes Blau
            secondary: [108, 117, 125],     // Elegantes Grau
            success: [40, 167, 69],         // Frisches Grün
            warning: [255, 193, 7],         // Warnung Orange
            danger: [220, 53, 69],          // Rot für Wichtiges
            light: [248, 249, 250],         // Heller Hintergrund
            dark: [33, 37, 41],             // Dunkler Text
            accent: [102, 16, 242]          // Akzentfarbe Lila
        };

        // Moderne Schriftgrößen
        const fonts = {
            title: 28,
            heading1: 20,
            heading2: 16,
            heading3: 14,
            body: 11,
            small: 9,
            caption: 8
        };

        // ===== HELPER FUNCTIONS =====

        // Moderner Seitenumbruch mit Header/Footer
        function checkPageBreak(pdf, yPos, requiredSpace = 40) {
            if (yPos + requiredSpace > pageHeight - margin - 20) {
                addFooter(pdf);
                pdf.addPage();
                addHeader(pdf);
                return 50; // Mehr Platz nach Header
            }
            return yPos;
        }

        // Moderner Header für jede Seite
        function addHeader(pdf) {
            // Header-Linie
            pdf.setDrawColor(...colors.primary);
            pdf.setLineWidth(0.8);
            pdf.line(margin, 15, pageWidth - margin, 15);

            // Logo-Bereich (simuliert)
            pdf.setFillColor(...colors.light);
            pdf.rect(margin, 8, 40, 6, 'F');
            pdf.setFontSize(fonts.small);
            pdf.setTextColor(...colors.primary);
            pdf.setFont('helvetica', 'bold');
            pdf.text('SCHUCH', margin + 2, 12);
        }

        // Moderner Footer für jede Seite
        function addFooter(pdf) {
            const currentPage = pdf.internal.getNumberOfPages();

            // Footer-Linie
            pdf.setDrawColor(...colors.light);
            pdf.setLineWidth(0.5);
            pdf.line(margin, pageHeight - 15, pageWidth - margin, pageHeight - 15);

            // Seitenzahl modern
            pdf.setFontSize(fonts.caption);
            pdf.setTextColor(...colors.secondary);
            pdf.setFont('helvetica', 'normal');
            pdf.text(`Seite ${currentPage}`, pageWidth - margin - 15, pageHeight - 8);

            // Copyright
            pdf.text('© Adolf Schuch GmbH - Beleuchtungsrechner', margin, pageHeight - 8);
        }

        // Moderner Text mit besserer Formatierung
        function addStyledText(pdf, text, x, y, maxWidth, style = {}) {
            const {
                fontSize = fonts.body,
                fontWeight = 'normal',
                color = colors.dark,
                align = 'left',
                lineSpacing = 1.4
            } = style;

            pdf.setFontSize(fontSize);
            pdf.setFont('helvetica', fontWeight);
            pdf.setTextColor(...color);

            // Bessere Textumbrüche
            const lines = pdf.splitTextToSize(text, maxWidth);

            if (align === 'center') {
                lines.forEach((line, index) => {
                    const textWidth = pdf.getTextWidth(line);
                    const centeredX = x + (maxWidth - textWidth) / 2;
                    pdf.text(line, centeredX, y + (index * fontSize * lineSpacing * 0.35));
                });
            } else {
                pdf.text(lines, x, y);
            }

            return y + (lines.length * fontSize * lineSpacing * 0.35);
        }

        // Moderne Section Headers
        function addSectionHeader(pdf, title, level = 1) {
            const fontSize = level === 1 ? fonts.heading1 : level === 2 ? fonts.heading2 : fonts.heading3;
            const color = level === 1 ? colors.primary : colors.dark;

            // Spacing vor Section
            yPosition += level === 1 ? sectionSpacing : subSectionSpacing;
            yPosition = checkPageBreak(pdf, yPosition);

            // Header mit Hintergrund für Level 1
            if (level === 1) {
                pdf.setFillColor(...colors.light);
                pdf.rect(margin, yPosition - 3, contentWidth, fontSize + 4, 'F');

                // Akzent-Linie links
                pdf.setFillColor(...colors.primary);
                pdf.rect(margin, yPosition - 3, 3, fontSize + 4, 'F');
            }

            yPosition = addStyledText(pdf, title, margin + (level === 1 ? 8 : 0), yPosition + fontSize/2, contentWidth, {
                fontSize: fontSize,
                fontWeight: 'bold',
                color: color
            });

            // Linie unter Level 1 Headers
            if (level === 1) {
                pdf.setDrawColor(...colors.light);
                pdf.setLineWidth(0.3);
                pdf.line(margin, yPosition + 2, pageWidth - margin, yPosition + 2);
                yPosition += 5;
            }

            yPosition += 3;
        }

        // Moderne Formel-Box
        function addFormulaBox(pdf, formula, description) {
            yPosition = checkPageBreak(pdf, yPosition, 25);

            // Box mit Schatten-Effekt
            pdf.setFillColor(250, 250, 250);
            pdf.setDrawColor(...colors.secondary);
            pdf.setLineWidth(0.3);
            pdf.rect(margin + 2, yPosition + 2, contentWidth - 4, 20, 'FD');

            // Formel zentriert und größer
            yPosition = addStyledText(pdf, formula, margin + 5, yPosition + 8, contentWidth - 10, {
                fontSize: fonts.heading3,
                fontWeight: 'bold',
                color: colors.accent,
                align: 'center'
            });

            // Beschreibung
            yPosition = addStyledText(pdf, description, margin + 5, yPosition + 3, contentWidth - 10, {
                fontSize: fonts.small,
                color: colors.secondary,
                align: 'center'
            });

            yPosition += 8;
        }

        // ===== MODERNE TITELSEITE =====

        // Erstes Header für erste Seite
        addHeader(pdf);

        // Moderne Titelgestaltung
        yPosition = 60;

        // Haupt-Titel mit modernem Styling
        yPosition = addStyledText(pdf, 'BELEUCHTUNGSBERECHNUNG', margin, yPosition, contentWidth, {
            fontSize: fonts.title,
            fontWeight: 'bold',
            color: colors.primary,
            align: 'center'
        });

        yPosition += 5;

        // Untertitel
        yPosition = addStyledText(pdf, 'Schritt-für-Schritt Anleitung nach EN 13032-2', margin, yPosition, contentWidth, {
            fontSize: fonts.heading2,
            fontWeight: 'normal',
            color: colors.secondary,
            align: 'center'
        });

        yPosition += 25;

        // Moderne Info-Box
        pdf.setFillColor(...colors.light);
        pdf.setDrawColor(...colors.primary);
        pdf.setLineWidth(0.5);
        pdf.rect(margin + 10, yPosition, contentWidth - 20, 40, 'FD');

        // Akzent-Linie
        pdf.setFillColor(...colors.primary);
        pdf.rect(margin + 10, yPosition, 4, 40, 'F');

        yPosition = addStyledText(pdf, 'Professionelle Lichtplanung mit präzisen Berechnungsmethoden', margin + 20, yPosition + 12, contentWidth - 30, {
            fontSize: fonts.heading3,
            fontWeight: 'bold',
            color: colors.dark
        });

        yPosition = addStyledText(pdf, 'Diese Anleitung führt Sie durch alle Schritte der normgerechten Beleuchtungsberechnung und erklärt die physikalischen Grundlagen sowie praktische Anwendung der EN 13032-2.', margin + 20, yPosition + 5, contentWidth - 30, {
            fontSize: fonts.body,
            color: colors.secondary,
            lineSpacing: 1.5
        });

        yPosition += 25;

        // ===== MODERNES INHALTSVERZEICHNIS =====
        addSectionHeader(pdf, 'INHALTSVERZEICHNIS', 1);

        const tocItems = [
            { title: '1. Grundlagen der Beleuchtungsberechnung', page: '3' },
            { title: '2. Geometrische Parameter erfassen', page: '4' },
            { title: '3. Raumindex und Wirkungsgrad bestimmen', page: '5' },
            { title: '4. Lichtstrombedarf berechnen', page: '6' },
            { title: '5. Leuchtenanzahl ermitteln', page: '7' },
            { title: '6. Ergebnis-Kontrolle durchführen', page: '8' },
            { title: '7. Spezielle Korrekturen anwenden', page: '9' },
            { title: '8. EULUMDAT-Integration nutzen', page: '10' },
            { title: '9. Praktische Berechnungsbeispiele', page: '11' }
        ];

        tocItems.forEach((item, index) => {
            // Moderne TOC-Gestaltung
            yPosition = addStyledText(pdf, item.title, margin + 5, yPosition, contentWidth - 25, {
                fontSize: fonts.body,
                color: colors.dark
            });

            // Seitenzahl rechts
            pdf.setFontSize(fonts.body);
            pdf.setTextColor(...colors.secondary);
            pdf.text(item.page, pageWidth - margin - 10, yPosition - 3);

            // Punktlinie
            pdf.setDrawColor(...colors.light);
            pdf.setLineWidth(0.2);
            const dotsStart = margin + 5 + pdf.getTextWidth(item.title) + 5;
            const dotsEnd = pageWidth - margin - 15;
            for (let x = dotsStart; x < dotsEnd; x += 3) {
                pdf.circle(x, yPosition - 5, 0.3, 'F');
            }

            yPosition += 2;
        });

        // ===== KAPITEL 1: GRUNDLAGEN =====
        addSectionHeader(pdf, '1. GRUNDLAGEN DER BELEUCHTUNGSBERECHNUNG', 1);

        addSectionHeader(pdf, '1.1 Grundformel nach EN 13032-2', 2);

        yPosition = addStyledText(pdf,
            'Die Beleuchtungsberechnung basiert auf der fundamentalen Formel der Lichttechnik. Diese normgerechte Berechnung gewährleistet präzise und reproduzierbare Ergebnisse:',
            margin, yPosition, contentWidth, {
                fontSize: fonts.body,
                color: colors.dark,
                lineSpacing: 1.5
            });

        yPosition += 5;

        // Moderne Formel-Darstellung
        addFormulaBox(pdf, 'E = (Φ × η × W) / A', 'Grundformel der Beleuchtungstechnik nach EN 13032-2');

        // Moderne Parameter-Liste
        addSectionHeader(pdf, '1.2 Parameter-Definitionen', 3);

        const parameters = [
            { symbol: 'E', desc: 'Beleuchtungsstärke', unit: '[lx]', detail: 'Gewünschte Helligkeit auf der Arbeitsebene' },
            { symbol: 'Φ', desc: 'Lichtstrom aller Leuchten', unit: '[lm]', detail: 'Gesamtlichtstrom des Beleuchtungssystems' },
            { symbol: 'η', desc: 'Raumwirkungsgrad', unit: '[-]', detail: 'Effizienz der Lichtnutzung im Raum' },
            { symbol: 'W', desc: 'Wartungsfaktor', unit: '[-]', detail: 'Berücksichtigung von Alterung und Verschmutzung' },
            { symbol: 'A', desc: 'Raumfläche', unit: '[m²]', detail: 'Grundfläche des zu beleuchtenden Raumes' }
        ];

        parameters.forEach(param => {
            // Parameter-Box mit modernem Design
            pdf.setFillColor(...colors.light);
            pdf.rect(margin, yPosition, contentWidth, 12, 'F');

            // Symbol hervorgehoben
            yPosition = addStyledText(pdf, param.symbol, margin + 5, yPosition + 4, 15, {
                fontSize: fonts.heading3,
                fontWeight: 'bold',
                color: colors.primary
            });

            // Beschreibung
            addStyledText(pdf, param.desc, margin + 25, yPosition - 4, 80, {
                fontSize: fonts.body,
                fontWeight: 'bold',
                color: colors.dark
            });

            // Einheit
            addStyledText(pdf, param.unit, margin + 110, yPosition - 4, 20, {
                fontSize: fonts.body,
                color: colors.secondary
            });

            // Detail
            addStyledText(pdf, param.detail, margin + 5, yPosition + 2, contentWidth - 10, {
                fontSize: fonts.small,
                color: colors.secondary
            });

            yPosition += 15;
        });
        yPosition += 6;

        addSectionHeader(pdf, '1.3 Formelumstellung für die Praxis', 3);

        yPosition = addStyledText(pdf,
            'Für die praktische Berechnung wird die Grundformel nach dem benötigten Lichtstrom umgestellt:',
            margin, yPosition, contentWidth, {
                fontSize: fonts.body,
                color: colors.dark
            });

        yPosition += 5;

        addFormulaBox(pdf, 'Φ_gesamt = (E_ziel × A) / (η × W)', 'Praktische Berechnungsformel für den Lichtstrombedarf');

        // ===== KAPITEL 2: GEOMETRISCHE PARAMETER =====
        addSectionHeader(pdf, '2. GEOMETRISCHE PARAMETER ERFASSEN', 1);

        yPosition = addStyledText(pdf,
            'Beispiel-Eingaben für einen typischen Büroraum:',
            margin, yPosition, contentWidth, {
                fontSize: fonts.body,
                color: colors.dark
            });
        yPosition += 4;

        const geometryExample = [
            'Raumlänge (L): 12.0 m',
            'Raumbreite (B): 8.0 m',
            'Raumhöhe: 3.5 m',
            'Arbeitsebenenhöhe: 0.8 m',
            'Montagehöhe: 3.0 m'
        ];

        geometryExample.forEach(item => {
            pdf.text('• ' + item, margin + 10, yPosition);
            yPosition += lineHeight;
        });
        yPosition += 6;

        pdf.setFont(undefined, 'bold');
        pdf.text('Berechnete Parameter:', margin, yPosition);
        yPosition += 6;

        pdf.setFont(undefined, 'normal');
        pdf.text('• Raumfläche: A = L × B = 12.0 × 8.0 = 96.0 m²', margin + 10, yPosition);
        yPosition += lineHeight;
        pdf.text('• Lichte Höhe: h = 3.0 - 0.8 = 2.2 m', margin + 10, yPosition);
        yPosition += sectionSpacing;

        // 3. Raumindex und Wirkungsgrad
        yPosition = checkPageBreak(pdf, yPosition);
        pdf.setFontSize(16);
        pdf.setFont(undefined, 'bold');
        pdf.text('3. Raumindex und Wirkungsgrad bestimmen', margin, yPosition);
        yPosition += 8;

        pdf.setFontSize(12);
        pdf.setFont(undefined, 'bold');
        pdf.text('3.1 Raumindex berechnen:', margin, yPosition);
        yPosition += 6;

        pdf.setFont('courier', 'bold');
        pdf.text('k = (L × B) / (h × (L + B))', margin + 20, yPosition);
        yPosition += 6;

        pdf.setFont(undefined, 'normal');
        pdf.text('k = (12.0 × 8.0) / (2.2 × (12.0 + 8.0)) = 96.0 / 44.0 = 2.18', margin + 20, yPosition);
        yPosition += 8;

        pdf.setFont(undefined, 'bold');
        pdf.text('3.2 Basis-Wirkungsgrad aus Tabelle:', margin, yPosition);
        yPosition += 6;

        yPosition = addStyledText(pdf,
            'Für k = 2.18 (Bereich 2.0-2.5): η₀ = 55%',
            margin + 10, yPosition, contentWidth - 10, {
                fontSize: fonts.body,
                color: colors.dark
            });
        yPosition += 6;

        pdf.setFont(undefined, 'bold');
        pdf.text('3.3 Reflexionskorrektur:', margin, yPosition);
        yPosition += 6;

        pdf.setFont(undefined, 'normal');
        pdf.text('Faktor = 0.7 + 0.3 × Reflexionsgrad_mittel', margin + 10, yPosition);
        yPosition += lineHeight;
        pdf.text('Faktor = 0.7 + 0.3 × 0.5 = 0.85', margin + 10, yPosition);
        yPosition += lineHeight;
        pdf.text('η_final = 0.55 × 0.85 = 0.468 (46.8%)', margin + 10, yPosition);
        yPosition += sectionSpacing;

        // 4. Lichtstrombedarf
        yPosition = checkPageBreak(pdf, yPosition);
        pdf.setFontSize(16);
        pdf.setFont(undefined, 'bold');
        pdf.text('4. Lichtstrombedarf berechnen', margin, yPosition);
        yPosition += 8;

        pdf.setFontSize(12);
        pdf.setFont(undefined, 'bold');
        pdf.text('4.1 Wartungsfaktor wählen:', margin, yPosition);
        yPosition += 6;

        yPosition = addStyledText(pdf,
            'Für normale Büroumgebung mit 2-jähriger Wartung: W = 0.8',
            margin + 10, yPosition, contentWidth - 10, {
                fontSize: fonts.body,
                color: colors.dark
            });
        yPosition += 6;

        pdf.setFont(undefined, 'bold');
        pdf.text('4.2 Gesamtlichtstrom berechnen:', margin, yPosition);
        yPosition += 6;

        pdf.setFont('courier', 'normal');
        pdf.text('Φ = (500 lx × 96.0 m²) / (0.468 × 0.8) = 48.000 / 0.374 = 128.342 lm', margin + 10, yPosition);
        yPosition += sectionSpacing;

        // 5. Leuchtenanzahl
        yPosition = checkPageBreak(pdf, yPosition);
        pdf.setFontSize(16);
        pdf.setFont(undefined, 'bold');
        pdf.text('5. Leuchtenanzahl ermitteln', margin, yPosition);
        yPosition += 8;

        yPosition = addStyledText(pdf,
            'Beispiel-Leuchte LUXANO 2: 4.000 lm bei 30 W (133 lm/W)',
            margin, yPosition, contentWidth, {
                fontSize: fonts.body,
                color: colors.dark
            });
        yPosition += 6;

        pdf.setFont('courier', 'normal');
        pdf.text('n_exakt = 128.342 / 4.000 = 32.1 Leuchten', margin + 10, yPosition);
        yPosition += lineHeight;
        pdf.text('n_gerundet = ceil(32.1) = 33 Leuchten', margin + 10, yPosition);
        yPosition += sectionSpacing;

        // 6. Ergebnis-Kontrolle
        yPosition = checkPageBreak(pdf, yPosition);
        pdf.setFontSize(16);
        pdf.setFont(undefined, 'bold');
        pdf.text('6. Ergebnis-Kontrolle durchführen', margin, yPosition);
        yPosition += 8;

        pdf.setFont('courier', 'normal');
        pdf.text('E_tatsächlich = (33 × 4.000 × 0.468 × 0.8) / 96.0 = 513 lx', margin + 10, yPosition);
        yPosition += lineHeight;
        pdf.text('Überschreitung = (513 - 500) / 500 × 100% = 2.6% ✓', margin + 10, yPosition);
        yPosition += lineHeight;
        pdf.text('P_gesamt = 33 × 30 W = 990 W (10.3 W/m²)', margin + 10, yPosition);
        yPosition += sectionSpacing;

        // 7. Spezielle Korrekturen
        yPosition = checkPageBreak(pdf, yPosition);
        pdf.setFontSize(16);
        pdf.setFont(undefined, 'bold');
        pdf.text('7. Spezielle Korrekturen', margin, yPosition);
        yPosition += 8;

        pdf.setFontSize(12);
        pdf.setFont(undefined, 'bold');
        pdf.text('7.1 Überlappungskorrektur:', margin, yPosition);
        yPosition += 6;

        yPosition = addStyledText(pdf,
            'Bei flachen Räumen (h < 4m) und großen Flächen (>50m²) wird eine Überlappungskorrektur angewendet.',
            margin + 10, yPosition, contentWidth - 10, {
                fontSize: fonts.body,
                color: colors.dark
            });
        yPosition += 6;

        pdf.setFont(undefined, 'bold');
        pdf.text('7.2 Geometrie-Warnungen:', margin, yPosition);
        yPosition += 6;

        const warnings = [
            'k > 8.0: Extreme Geometrie, ±30% Genauigkeit',
            'A > 1000m²: Professionelle Software empfohlen',
            'Seitenverhältnis > 3:1: Gleichmäßigkeit problematisch'
        ];

        pdf.setFont(undefined, 'normal');
        warnings.forEach(warning => {
            pdf.text('• ' + warning, margin + 10, yPosition);
            yPosition += lineHeight;
        });
        yPosition += sectionSpacing;

        // 8. EULUMDAT-Integration
        yPosition = checkPageBreak(pdf, yPosition);
        pdf.setFontSize(16);
        pdf.setFont(undefined, 'bold');
        pdf.text('8. EULUMDAT-Integration', margin, yPosition);
        yPosition += 8;

        yPosition = addStyledText(pdf,
            'EULUMDAT-Dateien enthalten präzise photometrische Daten mit 72 C-Ebenen und 161 Gamma-Winkeln. Dies verbessert die Genauigkeit von ±15% auf ±5%.',
            margin, yPosition, contentWidth, {
                fontSize: fonts.body,
                color: colors.dark,
                lineSpacing: 1.5
            });
        yPosition += 8;

        const eulumdatBenefits = [
            'Präzisere Wirkungsgrad-Bestimmung',
            'Berücksichtigung der echten Lichtverteilung',
            'Automatische Abstrahlwinkel-Erkennung',
            'Optimierte Überlappungskorrektur'
        ];

        eulumdatBenefits.forEach(benefit => {
            pdf.text('• ' + benefit, margin + 10, yPosition);
            yPosition += lineHeight;
        });
        yPosition += sectionSpacing;

        // 9. Wirkungsgrad-Tabelle
        yPosition = checkPageBreak(pdf, yPosition, 60);
        pdf.setFontSize(16);
        pdf.setFont(undefined, 'bold');
        pdf.text('9. Wirkungsgrad-Tabelle (EN 13032-2)', margin, yPosition);
        yPosition += 8;

        pdf.setFontSize(9);
        pdf.setFont(undefined, 'bold');
        pdf.text('k-Bereich', margin, yPosition);
        pdf.text('η₀ [%]', margin + 40, yPosition);
        pdf.text('Raumtyp', margin + 70, yPosition);
        yPosition += 6;

        pdf.setFont(undefined, 'normal');
        const efficiencyTable = [
            ['< 0.6', '25', 'Sehr hoch/schmal'],
            ['0.6-0.8', '30', 'Hoch'],
            ['0.8-1.0', '35', 'Normal'],
            ['1.0-1.25', '40', 'Standard'],
            ['1.25-1.5', '45', 'Größer'],
            ['1.5-2.0', '50', 'Mittel'],
            ['2.0-2.5', '55', 'Breit'],
            ['2.5-3.0', '60', 'Große Hallen'],
            ['3.0-4.0', '70', 'Sehr breit'],
            ['4.0-5.0', '79', 'Flache Hallen'],
            ['5.0-6.0', '85', 'Sehr flach'],
            ['6.0-7.0', '89', 'Extrem flach'],
            ['7.0-8.0', '91', 'Maximum']
        ];

        efficiencyTable.forEach(row => {
            pdf.text(row[0], margin, yPosition);
            pdf.text(row[1], margin + 40, yPosition);
            pdf.text(row[2], margin + 70, yPosition);
            yPosition += 5;
        });
        yPosition += sectionSpacing;

        // ===== MODERNER ABSCHLUSS =====

        // Letzter Footer
        addFooter(pdf);

        // Moderne Schluss-Seite
        yPosition = checkPageBreak(pdf, yPosition, 80);

        // Danksagung-Box
        pdf.setFillColor(...colors.primary);
        pdf.rect(margin, yPosition, contentWidth, 50, 'F');

        yPosition = addStyledText(pdf, 'VIELEN DANK', margin, yPosition + 15, contentWidth, {
            fontSize: fonts.heading1,
            fontWeight: 'bold',
            color: [255, 255, 255],
            align: 'center'
        });

        yPosition = addStyledText(pdf, 'für die Nutzung der Adolf Schuch GmbH Beleuchtungsberechnung', margin, yPosition + 5, contentWidth, {
            fontSize: fonts.body,
            color: [255, 255, 255],
            align: 'center'
        });

        yPosition += 30;

        // Moderne Kontakt-Info
        addSectionHeader(pdf, 'KONTAKT & SUPPORT', 2);

        const contactInfo = [
            { label: 'Technischer Support:', value: 'support@schuch.de' },
            { label: 'Telefon:', value: '+49 (0) 2131 2706-0' },
            { label: 'Website:', value: 'www.schuch.de' },
            { label: 'Normgrundlage:', value: 'EN 13032-2, EN 12464-1' }
        ];

        contactInfo.forEach(contact => {
            yPosition = addStyledText(pdf, contact.label, margin, yPosition, 60, {
                fontSize: fonts.body,
                fontWeight: 'bold',
                color: colors.secondary
            });

            addStyledText(pdf, contact.value, margin + 65, yPosition - 3, contentWidth - 65, {
                fontSize: fonts.body,
                color: colors.primary
            });

            yPosition += 8;
        });

        // PDF speichern mit modernem Dateinamen
        const currentDate = new Date().toISOString().split('T')[0];
        const fileName = `Schuch_Beleuchtungsanleitung_${currentDate}.pdf`;
        pdf.save(fileName);

    } catch (error) {
        console.error('Fehler beim Erstellen der Anleitung:', error);
        alert('Fehler beim Erstellen der Berechnungsanleitung!');
    }
}

// Initialization
document.addEventListener('DOMContentLoaded', function() {
    // Einmalig localStorage zurücksetzen für LUXANO 2 Update
    const schuchVersion = localStorage.getItem('schuchLampsVersion');
    if (schuchVersion !== '3.0') {
        localStorage.removeItem('lampDatabase');
        localStorage.setItem('schuchLampsVersion', '3.0');
        console.log('localStorage cleared for LUXANO 2 update v3.0');
    }

    // Schuch Standardlampen mit EULUMDAT-Daten
    const schuchLamps = [
        // LUXANO 2 Serie - Echte Schuch Feuchtraumleuchten (IP65)
        { id: 1, name: 'LUXANO 2 167 12L34G2', lumen: 3850, watt: 28, type: 'Feuchtraumleuchte IP65' },
        { id: 2, name: 'LUXANO 2 167 12L42G2', lumen: 4100, watt: 30, type: 'Feuchtraumleuchte IP65' },
        {
            id: 3,
            name: 'LUXANO 2 167 15L60G2',
            lumen: 6000,
            watt: 43,
            type: 'Feuchtraumleuchte IP65',
            hasEULUMDAT: true,
            eulumdatFile: '167_15L60G2_DIMD_840_1224.LDT',
            colorTemp: '4000K',
            cri: 'Ra80',
            dimensions: '1477×85×88 mm'
        },

        // LUXANO 2 VARIO Serie (einstellbare Leistung)
        { id: 4, name: 'LUXANO 2 VARIO 18/30W', lumen: 2700, watt: 18, type: 'Feuchtraumleuchte VARIO' },
        { id: 5, name: 'LUXANO 2 VARIO 25/43W', lumen: 3800, watt: 25, type: 'Feuchtraumleuchte VARIO' },

        // LUXANO 2 Hochleistung
        { id: 6, name: 'LUXANO 2 15L100', lumen: 11000, watt: 75, type: 'Feuchtraumleuchte Hochleistung' }
    ];

    // Benutzerdefinierte Lampen aus localStorage laden
    const savedLamps = localStorage.getItem('lampDatabase');
    let customLamps = [];
    if (savedLamps) {
        try {
            const parsed = JSON.parse(savedLamps);
            // Nur benutzerdefinierte Lampen (nicht Schuch-Lampen) behalten
            customLamps = parsed.filter(lamp => !lamp.name.includes('LUXANO') && lamp.id < 1000);
        } catch (e) {
            console.error('Error parsing saved lamps:', e);
        }
    }

    // Schuch-Lampen mit benutzerdefinierten Lampen kombinieren
    // Schuch-Lampen bekommen neue IDs, um Konflikte zu vermeiden
    const maxCustomId = customLamps.length > 0 ? Math.max(...customLamps.map(l => l.id)) : 0;
    const adjustedSchuchLamps = schuchLamps.map((lamp, index) => ({
        ...lamp,
        id: maxCustomId + index + 1000 // Große ID-Nummer um Konflikte zu vermeiden
    }));

    lampDatabase = [...adjustedSchuchLamps, ...customLamps];
    console.log('Lamp database initialized with', lampDatabase.length, 'lamps:', lampDatabase);
    updateLampList();
    console.log('updateLampList() called');

    // Initiale Validierung der Höhen
    updateMountingHeightMax();
    updateWorkPlaneHeightMax();

    // Bootstrap Tooltips initialisieren
    initializeTooltips();

    // Three.js laden und initialisieren
    if (typeof THREE === 'undefined') {
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js';
        script.onload = () => {
            setTimeout(init3D, 100);
        };
        script.onerror = () => {
            console.log('Three.js konnte nicht geladen werden, verwende 2D-Fallback');
            init2D();
        };
        document.head.appendChild(script);
    } else {
        setTimeout(init3D, 100);
    }

    // Event Listener für Raumparameter
    ['roomWidth', 'roomLength', 'roomHeight', 'workPlaneHeight', 'mountingHeight'].forEach(id => {
        const element = document.getElementById(id);
        if (element) {
            element.addEventListener('change', () => {
                if (scene) createBasicRoom();
                else if (document.getElementById('room2d')) update2DVisualization(0);
            });
        }
    });

    // Debug-Check nach vollständiger Initialisierung
    setTimeout(() => {
        debugCheckCalculationFunction();
    }, 1000);
});
</script>
{% endblock %}