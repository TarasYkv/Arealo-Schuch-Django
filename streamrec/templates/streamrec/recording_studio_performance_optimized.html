{% extends 'base.html' %}
{% load static %}

{% block title %}StreamRec - Performance Optimized Studio{% endblock %}

{% block page_css %}
<!-- PYTHONANYWHERE OPTIMIZED: Inline CSS for better loading -->
<style>
/* StreamRec Base Styles - Inline for PythonAnywhere */
:root {
    --streamrec-primary: #667eea;
    --streamrec-secondary: #764ba2;
    --streamrec-success: #28a745;
    --streamrec-warning: #ffc107;
    --streamrec-danger: #dc3545;
    --streamrec-info: #17a2b8;
    --streamrec-border-radius: 0.5rem;
    --streamrec-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);
    --streamrec-transition: all 0.2s ease-in-out;
}

.streamrec-btn {
    transition: var(--streamrec-transition);
    border-radius: var(--streamrec-border-radius);
    font-weight: 500;
}

.streamrec-btn:hover {
    transform: translateY(-1px);
    box-shadow: var(--streamrec-shadow);
}

.text-gradient {
    background: linear-gradient(135deg, var(--streamrec-primary) 0%, var(--streamrec-secondary) 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.recording-dot {
    width: 8px;
    height: 8px;
    background: #ffffff;
    border-radius: 50%;
    animation: recordPulse 1.5s ease-in-out infinite;
}

@keyframes recordPulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.3; }
}

/* System Info Grid */
.system-info-item {
    padding: 0.5rem;
    text-align: center;
}

.system-info-item small {
    display: block;
    margin-bottom: 0.25rem;
}
/* Performance Optimized Studio Styles */
.studio-container {
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    min-height: 100vh;
    padding: 2rem 0;
}

.studio-header {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
    color: #ffffff !important;
    padding: 2rem 0;
    margin-bottom: 2rem;
    border-radius: 0 0 2rem 2rem;
    box-shadow: 0 4px 20px rgba(102, 126, 234, 0.15);
}

.studio-header h1, .studio-header p, .studio-header i,
.studio-header .phase-indicator, .studio-header .stat-value,
.studio-header .stat-label {
    color: #ffffff !important;
}

.control-panel {
    background: white;
    border-radius: var(--streamrec-border-radius, 0.5rem);
    box-shadow: var(--streamrec-shadow, 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075));
    padding: 1.5rem;
    margin-bottom: 1.5rem;
    transition: var(--streamrec-transition, all 0.2s);
}

.control-panel:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 30px rgba(102, 126, 234, 0.2);
}

.preview-area {
    background: #1a1a1a;
    border-radius: var(--streamrec-border-radius, 0.5rem);
    padding: 1rem;
    box-shadow: var(--streamrec-shadow, 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075));
    min-height: calc(100vh - 180px);
    position: sticky;
    top: 1rem;
}

.phase-indicator {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    background: rgba(255, 255, 255, 0.2);
    padding: 0.5rem 1rem;
    border-radius: 2rem;
    font-size: 0.875rem;
}

.phase-badge {
    background: #ffffff !important;
    color: #4b3ba8 !important;
    padding: 0.25rem 0.75rem;
    border-radius: 1rem;
    font-weight: 600;
    font-size: 0.75rem;
}

/* Performance Indicator */
.performance-indicator {
    position: fixed;
    top: 10px;
    right: 10px;
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 0.5rem;
    border-radius: 0.5rem;
    font-size: 0.75rem;
    z-index: 1000;
    min-width: 200px;
}

.performance-good { border-left: 4px solid #28a745; }
.performance-warning { border-left: 4px solid #ffc107; }
.performance-critical { border-left: 4px solid #dc3545; }

/* CRITICAL FIX: Visibility */
.control-panel, .control-panel *, 
#recordingControlsContainer, #recordingControlsContainer * {
    color: #212529 !important;
    background-color: transparent !important;
}

.control-panel {
    background-color: #ffffff !important;
    border: 1px solid #dee2e6 !important;
}

/* Button fixes */
.btn-primary { background-color: #0d6efd !important; border-color: #0d6efd !important; color: #ffffff !important; }
.btn-success { background-color: #198754 !important; border-color: #198754 !important; color: #ffffff !important; }
.btn-danger { background-color: #dc3545 !important; border-color: #dc3545 !important; color: #ffffff !important; }
.btn-warning { background-color: #fd7e14 !important; border-color: #fd7e14 !important; color: #ffffff !important; }
.btn-info { background-color: #0dcaf0 !important; border-color: #0dcaf0 !important; color: #000000 !important; }
.btn-secondary { background-color: #6c757d !important; border-color: #6c757d !important; color: #ffffff !important; }

.form-select, .form-control { color: #212529 !important; background-color: #ffffff !important; border-color: #ced4da !important; }
</style>
{% endblock %}

{% block fullscreen_content %}
<div class="studio-container">
    <!-- Performance Indicator -->
    <div id="performanceIndicator" class="performance-indicator performance-good" style="display: none;">
        <div><strong>Performance</strong></div>
        <div>FPS: <span id="fpsCounter">30</span></div>
        <div>Frames: <span id="frameCounter">0</span></div>
        <div>Dropped: <span id="droppedCounter">0</span></div>
        <div>Render: <span id="renderTime">0ms</span></div>
    </div>

    <!-- Enhanced Header -->
    <div class="studio-header">
        <div class="container-fluid">
            <div class="row align-items-center">
                <div class="col-md-8">
                    <h1 class="display-5 fw-bold mb-2">
                        <i class="fas fa-video-camera me-3"></i>
                        StreamRec Studio
                        <span class="badge bg-success ms-2">Performance Optimized</span>
                    </h1>
                    <p class="lead mb-0">Ultra-schnelle Multi-Stream Video Aufnahme</p>
                    <div class="phase-indicator mt-3">
                        <i class="fas fa-rocket"></i>
                        <span>Performance Edition</span>
                        <div class="phase-badge">Anti-Freeze Technology</div>
                    </div>
                </div>
                <div class="col-md-4 text-md-end">
                    <div class="studio-stats">
                        <div class="row text-center">
                            <div class="col-4">
                                <div class="stat-value">3:00</div>
                                <div class="stat-label">Max. Dauer</div>
                            </div>
                            <div class="col-4">
                                <div class="stat-value">9:16</div>
                                <div class="stat-label">Format</div>
                            </div>
                            <div class="col-4">
                                <div class="stat-value" id="activeStreams">0</div>
                                <div class="stat-label">Streams</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="container-fluid">
        <div class="row">
            <!-- Left Column: All Controls -->
            <div class="col-12 col-lg-4 col-xl-3">
                <!-- Stream Controls -->
                <div class="control-panel">
                    <h5 class="mb-4">
                        <i class="fas fa-sliders-h me-2"></i>
                        Stream Kontrolle
                    </h5>
                    
                    <!-- Camera Section -->
                    <div class="mb-4">
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <h6 class="mb-0">
                                <i class="fas fa-camera text-success me-2"></i>Kamera
                            </h6>
                            <div class="status-indicator" id="cameraStatusBadge">
                                <i class="fas fa-circle text-secondary"></i>
                            </div>
                        </div>
                        <div class="d-grid gap-2">
                            <button id="startCameraBtn" class="btn btn-outline-success">
                                <i class="fas fa-play me-2"></i>Kamera starten
                            </button>
                            <button id="stopCameraBtn" class="btn btn-outline-danger" disabled>
                                <i class="fas fa-stop me-2"></i>Kamera stoppen
                            </button>
                        </div>
                        <small id="cameraStatus" class="text-muted d-block mt-2">Status: Nicht aktiv</small>
                    </div>

                    <!-- Screen Section -->
                    <div class="mb-4">
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <h6 class="mb-0">
                                <i class="fas fa-desktop text-info me-2"></i>Bildschirm
                            </h6>
                            <div class="status-indicator" id="screenStatusBadge">
                                <i class="fas fa-circle text-secondary"></i>
                            </div>
                        </div>
                        <div class="d-grid gap-2">
                            <button id="startScreenBtn" class="btn btn-outline-info">
                                <i class="fas fa-desktop me-2"></i>Bildschirm teilen
                            </button>
                            <button id="stopScreenBtn" class="btn btn-outline-danger" disabled>
                                <i class="fas fa-stop me-2"></i>Bildschirm stoppen
                            </button>
                        </div>
                        <small id="screenStatus" class="text-muted d-block mt-2">Status: Nicht aktiv</small>
                    </div>

                    <!-- Composition Controls -->
                    <div class="mb-4">
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <h6 class="mb-0">
                                <i class="fas fa-palette text-warning me-2"></i>Komposition
                            </h6>
                            <div class="status-indicator" id="compositionStatusBadge">
                                <i class="fas fa-circle text-secondary"></i>
                            </div>
                        </div>
                        <div class="d-grid gap-2">
                            <button id="startCompositionBtn" class="btn btn-outline-warning" disabled>
                                <i class="fas fa-layer-group me-2"></i>Komposition starten
                            </button>
                            <button id="stopCompositionBtn" class="btn btn-outline-danger" disabled>
                                <i class="fas fa-stop me-2"></i>Komposition stoppen
                            </button>
                        </div>
                        <small id="compositionStatus" class="text-muted d-block mt-2">Status: Nicht aktiv</small>

                        <!-- Layout-Schnellwahl -->
                        <div class="mt-3">
                            <div class="d-flex align-items-center justify-content-between mb-2">
                                <h6 class="mb-0">Layout-Schnellwahl</h6>
                                <small class="text-muted" id="layoutStreamCount">0 Streams</small>
                            </div>
                            <div id="layoutChips" class="d-flex flex-wrap gap-1"></div>
                        </div>
                    </div>
                </div>

                <!-- Phase 2: Layout Manager -->
                <div class="control-panel" id="layoutControls">
                    <h5 class="mb-4">
                        <i class="fas fa-th-large me-2"></i>
                        Layout Manager
                        <span class="badge bg-primary ms-2">Phase 2</span>
                    </h5>
                    <div id="layoutControlsContent">
                        <div class="alert alert-info" id="layoutManagerPlaceholder">
                            <i class="fas fa-info-circle me-2"></i>
                            Starten Sie Kamera oder Bildschirm-Sharing, um verf√ºgbare Layouts zu sehen
                        </div>
                    </div>
                </div>

                <!-- System Information -->
                <div class="control-panel">
                    <h5 class="mb-4">
                        <i class="fas fa-info-circle me-2"></i>
                        System Information
                    </h5>
                    <div class="row">
                        <div class="col-6">
                            <div class="system-info-item">
                                <small class="text-muted">Browser:</small>
                                <div id="browserInfo" class="fw-bold">-</div>
                            </div>
                        </div>
                        <div class="col-6">
                            <div class="system-info-item">
                                <small class="text-muted">WebRTC:</small>
                                <div id="webrtcSupport" class="fw-bold">-</div>
                            </div>
                        </div>
                        <div class="col-6">
                            <div class="system-info-item">
                                <small class="text-muted">Canvas:</small>
                                <div id="canvasSupport" class="fw-bold">-</div>
                            </div>
                        </div>
                        <div class="col-6">
                            <div class="system-info-item">
                                <small class="text-muted">Recording:</small>
                                <div id="mediaRecorderSupport" class="fw-bold">-</div>
                            </div>
                        </div>
                    </div>
                    <div id="performanceMetrics" class="mt-3 text-center">
                        <small class="text-muted">Performance wird √ºberwacht...</small>
                    </div>
                </div>

                <!-- Quick Actions -->
                <div class="control-panel">
                    <h5 class="mb-4">
                        <i class="fas fa-bolt me-2"></i>
                        Schnellaktionen
                    </h5>
                    <div class="d-grid gap-2">
                        <button class="btn btn-outline-primary" onclick="window.location.reload()">
                            <i class="fas fa-redo me-2"></i>Neu laden
                        </button>
                        <button class="btn btn-outline-secondary" data-bs-toggle="modal" data-bs-target="#settingsModal">
                            <i class="fas fa-cog me-2"></i>Einstellungen
                        </button>
                        <a href="{% url 'streamrec:dashboard' %}" class="btn btn-outline-info">
                            <i class="fas fa-arrow-left me-2"></i>Dashboard
                        </a>
                    </div>
                </div>

                <!-- Recording Controls -->
                <div class="control-panel" id="recordingControlsContainer">
                    <h5 class="mb-4">
                        <i class="fas fa-record-vinyl me-2 text-danger"></i>
                        Aufnahme Kontrolle
                    </h5>
                    
                    <div class="d-grid gap-2 mb-3">
                        <button id="recordBtn" class="btn btn-danger">
                            <i class="fas fa-circle me-2"></i>Aufnahme starten
                        </button>
                        <div class="d-flex gap-2">
                            <button id="pauseBtn" class="btn btn-warning flex-fill" disabled>
                                <i class="fas fa-pause me-2"></i>Pausieren
                            </button>
                            <button id="stopRecordBtn" class="btn btn-outline-danger flex-fill" disabled>
                                <i class="fas fa-stop me-2"></i>Stoppen
                            </button>
                        </div>
                    </div>
                    
                    <div class="text-center">
                        <div id="recordingStatus" class="small mb-2">Status: Bereit f√ºr Aufnahme</div>
                        <div class="progress mb-2" style="height: 8px;">
                            <div id="recordingProgress" class="progress-bar bg-danger" style="width: 0%"></div>
                        </div>
                        <div class="d-flex justify-content-between small text-muted">
                            <span id="recordingTime">00:00</span>
                            <span>03:00</span>
                        </div>
                        <div class="mt-2">
                            <span class="badge bg-secondary" id="recordingStateIndicator">
                                <i class="fas fa-stop me-1"></i>Gestoppt
                            </span>
                        </div>
                    </div>
                </div>

                <!-- Performance Settings -->
                <div class="control-panel">
                    <h5 class="mb-4">
                        <i class="fas fa-tachometer-alt me-2"></i>
                        Performance Einstellungen
                    </h5>
                    <div class="mb-3">
                        <label class="form-label">Target FPS:</label>
                        <select class="form-select" id="fpsSelect">
                            <option value="30" selected>30 FPS (Empfohlen)</option>
                            <option value="25">25 FPS (Sparsam)</option>
                            <option value="20">20 FPS (Langsame PCs)</option>
                            <option value="15">15 FPS (Minimum)</option>
                        </select>
                    </div>
                    <div class="mb-3">
                        <label class="form-label">Qualit√§t:</label>
                        <select class="form-select" id="qualitySelect">
                            <option value="high">Hoch (beste Qualit√§t)</option>
                            <option value="medium" selected>Mittel (ausgewogen)</option>
                            <option value="low">Niedrig (beste Performance)</option>
                        </select>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="showPerformance">
                        <label class="form-check-label" for="showPerformance">
                            Performance Monitor anzeigen
                        </label>
                    </div>
                </div>
            </div>

            <!-- Right Column: Preview Area and Recording -->
            <div class="col-12 col-lg-8 col-xl-9">
                <div class="preview-area">
                    <!-- Preview Header -->
                    <div class="d-flex justify-content-between align-items-center mb-3">
                        <h5 class="text-white mb-0">
                            <i class="fas fa-eye me-2"></i>
                            Live Vorschau (Performance Optimized)
                        </h5>
                        <div class="preview-controls">
                            <button class="btn btn-sm btn-outline-light me-2" id="fullscreenBtn">
                                <i class="fas fa-expand"></i>
                            </button>
                            <div class="btn-group" role="group">
                                <button class="btn btn-sm btn-outline-light" id="gridToggle">
                                    <i class="fas fa-th"></i>
                                </button>
                                <button class="btn btn-sm btn-outline-light" id="zoomFit">
                                    <i class="fas fa-compress-arrows-alt"></i>
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Canvas Container -->
                    <div id="previewContainer" class="position-relative d-flex align-items-center justify-content-center" 
                         style="height: 600px; border-radius: 0.5rem; overflow: hidden;">
                        
                        <canvas id="compositionCanvas" 
                                width="360" 
                                height="640" 
                                class="border border-secondary"
                                style="max-width: 100%; max-height: 100%; object-fit: contain;">
                        </canvas>
                        
                        <!-- No Content Overlay -->
                        <div id="noContentOverlay" class="position-absolute top-50 start-50 translate-middle text-center text-white">
                            <div class="mb-4">
                                <i class="fas fa-video fa-4x mb-3 opacity-25"></i>
                                <h4>Keine Streams aktiv</h4>
                                <p class="text-muted">Starten Sie Kamera oder Bildschirm-Sharing um zu beginnen</p>
                            </div>
                            <div class="d-grid gap-2 d-md-flex justify-content-md-center">
                                <button class="btn btn-success" onclick="document.getElementById('startCameraBtn').click()">
                                    <i class="fas fa-camera me-2"></i>Kamera starten
                                </button>
                                <button class="btn btn-info" onclick="document.getElementById('startScreenBtn').click()">
                                    <i class="fas fa-desktop me-2"></i>Bildschirm teilen
                                </button>
                            </div>
                        </div>

                        <!-- Recording Indicator -->
                        <div id="recordingIndicator" class="position-absolute top-0 start-0 m-3" style="display: none;">
                            <div class="d-flex align-items-center bg-danger text-white px-3 py-2 rounded-pill">
                                <div class="recording-dot me-2"></div>
                                <span class="fw-bold">REC</span>
                                <span class="ms-2" id="recordingTimeIndicator">00:00</span>
                            </div>
                        </div>

                        <!-- Countdown Overlay -->
                        <div id="countdownOverlay" class="position-absolute top-50 start-50 translate-middle" style="display:none;">
                            <div class="bg-dark bg-opacity-75 text-white rounded px-5 py-4">
                                <div id="countdownNumber" class="display-3 fw-bold text-center">3</div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Stream Thumbnails -->
                    <div class="mt-4">
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <h6 class="text-white mb-0">Aktive Streams:</h6>
                            <div class="stream-controls-mini">
                                <button class="btn btn-sm btn-outline-light" id="syncStreams" title="Streams synchronisieren">
                                    <i class="fas fa-sync-alt"></i>
                                </button>
                                <button class="btn btn-sm btn-outline-light" data-bs-toggle="modal" data-bs-target="#settingsModal" title="Einstellungen">
                                    <i class="fas fa-cog"></i>
                                </button>
                            </div>
                        </div>
                        <div id="streamThumbnails" class="d-flex gap-3 flex-wrap">
                            <div id="noStreamsMessage" class="text-muted text-center flex-grow-1 py-4">
                                <i class="fas fa-info-circle me-2"></i>
                                Noch keine Streams erfasst
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Settings Modal -->
<div class="modal fade" id="settingsModal" tabindex="-1" aria-labelledby="settingsModalLabel">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header bg-primary text-white">
                <h5 class="modal-title" id="settingsModalLabel">
                    <i class="fas fa-cog me-2"></i>Performance Einstellungen
                </h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <div class="row">
                    <div class="col-md-6">
                        <h6>Video-Einstellungen</h6>
                        <div class="mb-3">
                            <label class="form-label">Aufl√∂sung:</label>
                            <select class="form-select" id="resolutionSetting">
                                <option value="720p" selected>720p (HD) - Empfohlen</option>
                                <option value="1080p">1080p (Full HD) - High-End PCs</option>
                                <option value="480p">480p (SD) - Langsame PCs</option>
                            </select>
                        </div>
                        <div class="mb-3">
                            <label class="form-label">Bitrate:</label>
                            <select class="form-select" id="bitrateSetting">
                                <option value="2000000" selected>2 Mbps (Ausgewogen)</option>
                                <option value="4000000">4 Mbps (Hohe Qualit√§t)</option>
                                <option value="1000000">1 Mbps (Sparsam)</option>
                                <option value="500000">0.5 Mbps (Minimum)</option>
                            </select>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <h6>Performance-Einstellungen</h6>
                        <div class="form-check mb-3">
                            <input class="form-check-input" type="checkbox" id="enableFrameSkipping" checked>
                            <label class="form-check-label" for="enableFrameSkipping">
                                Frame Skipping aktivieren (Anti-Freeze)
                            </label>
                        </div>
                        <div class="form-check mb-3">
                            <input class="form-check-input" type="checkbox" id="enablePerformanceMonitor">
                            <label class="form-check-label" for="enablePerformanceMonitor">
                                Performance Monitor anzeigen
                            </label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="enableErrorRecovery" checked>
                            <label class="form-check-label" for="enableErrorRecovery">
                                Automatische Fehlerkorrektur
                            </label>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Abbrechen</button>
                <button type="button" class="btn btn-primary" id="saveSettings">
                    <i class="fas fa-save me-2"></i>Speichern
                </button>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block page_js %}
<script>
console.log('üöÄ StreamRec Performance Optimized Version (PythonAnywhere Ready) wird geladen...');

/**
 * üöÄ PERFORMANCE OPTIMIZED StreamRec - PYTHONANYWHERE EDITION
 * Anti-Freeze Technology mit intelligenter Frame-Rate Kontrolle
 * Optimiert f√ºr Server-Deployment mit minimalen Abh√§ngigkeiten
 */
class StreamRecorderOptimized {
    constructor() {
        // Basic properties
        this.streams = new Map();
        this.canvas = null;
        this.ctx = null;
        this.isComposing = false;
        this.animationFrame = null;
        this.currentLayout = 'pip';
        this.mediaRecorder = null;
        this.recordedChunks = [];
        this.isRecording = false;
        this.recordingStartTime = null;
        this.recordingTimer = null;
        this.maxDuration = 180000; // 3 minutes
        
        // üöÄ PERFORMANCE OPTIMIZATIONS
        this.videoElements = new Map(); // Video Element Pool
        this.lastRenderTime = 0;
        this.targetFPS = 30;
        this.frameInterval = 1000 / this.targetFPS;
        this.skipFrameCount = 0;
        this.maxSkipFrames = 2;
        this.performanceMetrics = {
            droppedFrames: 0,
            totalFrames: 0,
            averageRenderTime: 0,
            lastFPS: 0
        };
        this.performanceBuffer = [];
        this.lastFPSUpdate = 0;
        this.enableFrameSkipping = true;
        this.enableErrorRecovery = true;
        this.renderTimeBuffer = [];
        
        this.init();
    }

    init() {
        this.canvas = document.getElementById('compositionCanvas');
        if (!this.canvas) {
            console.error('‚ùå Canvas nicht gefunden');
            return;
        }
        
        this.ctx = this.canvas.getContext('2d');
        this.setupEventListeners();
        this.checkBrowserSupport();
        this.initPerformanceMonitoring();
        this.loadSettings();
        this.refreshLayoutChips();
        
        console.log('‚úÖ StreamRec Performance Optimized initialisiert');
    }

    setupEventListeners() {
        // Camera controls
        document.getElementById('startCameraBtn')?.addEventListener('click', () => this.startCamera());
        document.getElementById('stopCameraBtn')?.addEventListener('click', () => this.stopCamera());
        
        // Screen controls
        document.getElementById('startScreenBtn')?.addEventListener('click', () => this.startScreen());
        document.getElementById('stopScreenBtn')?.addEventListener('click', () => this.stopScreen());
        
        // Composition controls
        document.getElementById('startCompositionBtn')?.addEventListener('click', () => this.startComposition());
        document.getElementById('stopCompositionBtn')?.addEventListener('click', () => this.stopComposition());

        // Recording controls
        document.getElementById('recordBtn')?.addEventListener('click', () => this.startRecordingWithCountdown());
        document.getElementById('stopRecordBtn')?.addEventListener('click', () => this.stopRecording());
        document.getElementById('pauseBtn')?.addEventListener('click', () => this.togglePauseRecording());

        // Performance controls
        document.getElementById('fpsSelect')?.addEventListener('change', (e) => {
            this.targetFPS = parseInt(e.target.value);
            this.frameInterval = 1000 / this.targetFPS;
        });

        document.getElementById('qualitySelect')?.addEventListener('change', (e) => {
            this.applyQualitySettings(e.target.value);
        });

        document.getElementById('showPerformance')?.addEventListener('change', (e) => {
            this.togglePerformanceMonitor(e.target.checked);
        });

        // Settings
        document.getElementById('saveSettings')?.addEventListener('click', () => this.saveSettings());

        // Fullscreen
        document.getElementById('fullscreenBtn')?.addEventListener('click', () => {
            if (this.canvas.requestFullscreen) {
                this.canvas.requestFullscreen();
            }
        });

        // Layout Controls (delegierte Events f√ºr beide Bereiche)
        this.setupLayoutEventHandlers();
    }

    setupLayoutEventHandlers() {
        // Event Handler f√ºr Layout-Chips (kleine Buttons)
        document.getElementById('layoutChips')?.addEventListener('click', (e) => {
            const btn = e.target.closest('[data-layout]');
            if (!btn) return;
            
            const layout = btn.getAttribute('data-layout');
            this.selectLayout(layout);
        });

        // Event Handler f√ºr Layout Manager (gro√üe Cards)
        document.getElementById('layoutControlsContent')?.addEventListener('click', (e) => {
            const btn = e.target.closest('[data-layout]');
            if (!btn) return;
            
            const layout = btn.getAttribute('data-layout');
            this.selectLayout(layout);
        });
    }

    selectLayout(layout) {
        console.log(`üéØ Layout ausgew√§hlt: ${layout}`);
        
        // Layout anwenden
        this.applyLayout(layout);
        
        // Komposition starten falls nicht aktiv
        if (!this.isComposing) {
            this.startComposition();
        }
        
        // UI aktualisieren
        this.updateLayoutUI(layout);
    }

    updateLayoutUI(layout) {
        // Update Layout-Chips (kleine Buttons)
        document.querySelectorAll('#layoutChips [data-layout]').forEach(el => {
            if (el.getAttribute('data-layout') === layout) {
                el.classList.remove('btn-outline-primary');
                el.classList.add('btn-primary');
            } else {
                el.classList.remove('btn-primary');
                el.classList.add('btn-outline-primary');
            }
        });

        // Update Layout Manager (gro√üe Cards)
        document.querySelectorAll('#layoutControlsContent [data-layout]').forEach(el => {
            const card = el.closest('.layout-preset-card');
            if (card) {
                if (el.getAttribute('data-layout') === layout) {
                    card.classList.add('border-primary', 'bg-primary', 'bg-opacity-10');
                    el.textContent = 'Aktiv';
                    el.classList.remove('btn-outline-primary');
                    el.classList.add('btn-primary');
                } else {
                    card.classList.remove('border-primary', 'bg-primary', 'bg-opacity-10');
                    el.textContent = 'Aktivieren';
                    el.classList.remove('btn-primary');
                    el.classList.add('btn-outline-primary');
                }
            }
        });
    }

    checkBrowserSupport() {
        const support = {
            getUserMedia: !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia),
            getDisplayMedia: !!(navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia),
            canvas: !!(this.canvas && this.ctx),
            mediaRecorder: !!(window.MediaRecorder)
        };
        
        console.log('üîç Browser Support:', support);
        return support;
    }

    getBrowserInfo() {
        const ua = navigator.userAgent;
        if (ua.includes('Chrome')) return 'Chrome';
        if (ua.includes('Firefox')) return 'Firefox';
        if (ua.includes('Safari')) return 'Safari';
        if (ua.includes('Edge')) return 'Edge';
        return 'Unbekannt';
    }

    async startCamera() {
        try {
            this.updateStatus('camera', 'Kamera wird gestartet...', 'info');
            
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { 
                    width: { ideal: 1280 },
                    height: { ideal: 720 },
                    frameRate: { ideal: this.targetFPS }
                },
                audio: true
            });

            this.streams.set('camera', stream);
            this.updateStatus('camera', 'Aktiv', 'success');
            this.updateButtons('camera', true);
            this.updateStatusBadge('camera', 'success');
            this.addStreamThumbnail('camera', stream);
            this.checkCompositionReady();
            this.updateActiveStreamsCount();
            this.refreshLayoutChips();

            console.log('‚úÖ Kamera-Stream erfolgreich gestartet');
        } catch (error) {
            console.error('‚ùå Kamera-Zugriff fehlgeschlagen:', error);
            this.updateStatus('camera', `Fehler: ${error.message}`, 'danger');
            this.updateStatusBadge('camera', 'danger');
        }
    }

    async startScreen() {
        try {
            this.updateStatus('screen', 'Bildschirm-Sharing wird gestartet...', 'info');
            
            const stream = await navigator.mediaDevices.getDisplayMedia({
                video: {
                    width: { ideal: 1920 },
                    height: { ideal: 1080 },
                    frameRate: { ideal: this.targetFPS },
                    cursor: 'always'
                },
                audio: true
            });

            this.streams.set('screen', stream);
            this.updateStatus('screen', 'Aktiv', 'success');
            this.updateButtons('screen', true);
            this.updateStatusBadge('screen', 'success');
            this.addStreamThumbnail('screen', stream);
            this.checkCompositionReady();
            this.updateActiveStreamsCount();
            this.refreshLayoutChips();

            // Handle screen sharing end event
            stream.getVideoTracks()[0].addEventListener('ended', () => {
                this.stopScreen();
            });

            console.log('‚úÖ Bildschirm-Stream erfolgreich gestartet');
        } catch (error) {
            console.error('‚ùå Bildschirm-Capture fehlgeschlagen:', error);
            this.updateStatus('screen', `Fehler: ${error.message}`, 'danger');
            this.updateStatusBadge('screen', 'danger');
        }
    }

    stopCamera() {
        const stream = this.streams.get('camera');
        if (stream) {
            stream.getTracks().forEach(track => track.stop());
            this.streams.delete('camera');
            this.cleanupVideoElement('camera');
            this.updateStatus('camera', 'Nicht aktiv', 'secondary');
            this.updateButtons('camera', false);
            this.updateStatusBadge('camera', 'secondary');
            this.removeStreamThumbnail('camera');
            this.updateActiveStreamsCount();
            this.refreshLayoutChips();
            this.checkCompositionReady();
        }
    }

    stopScreen() {
        const stream = this.streams.get('screen');
        if (stream) {
            stream.getTracks().forEach(track => track.stop());
            this.streams.delete('screen');
            this.cleanupVideoElement('screen');
            this.updateStatus('screen', 'Nicht aktiv', 'secondary');
            this.updateButtons('screen', false);
            this.updateStatusBadge('screen', 'secondary');
            this.removeStreamThumbnail('screen');
            this.updateActiveStreamsCount();
            this.refreshLayoutChips();
            this.checkCompositionReady();
        }
    }

    startComposition() {
        if (this.streams.size === 0) {
            alert('Bitte starten Sie zuerst Kamera oder Bildschirm-Sharing');
            return;
        }
        
        this.isComposing = true;
        this.updateStatus('composition', 'Aktiv', 'success');
        this.updateButtons('composition', true);
        this.updateStatusBadge('composition', 'warning');
        this.renderComposition();
        console.log('‚úÖ Live Composition gestartet');
    }

    stopComposition() {
        this.isComposing = false;
        this.updateStatus('composition', 'Nicht aktiv', 'secondary');
        this.updateButtons('composition', false);
        this.updateStatusBadge('composition', 'secondary');
        
        if (this.animationFrame) {
            cancelAnimationFrame(this.animationFrame);
        }
        
        this.clearCanvas();
        console.log('üõë Live Composition gestoppt');
    }

    // üöÄ OPTIMIZED RENDERING ENGINE
    renderComposition() {
        if (!this.isComposing) return;

        const now = performance.now();
        const elapsed = now - this.lastRenderTime;
        
        // üéØ FRAME-RATE KONTROLLE: Nur rendern wenn Frame-Intervall erreicht
        if (elapsed >= this.frameInterval) {
            const renderStart = performance.now();
            
            // Frame Skip Logic bei Performance-Problemen
            if (!this.enableFrameSkipping || this.skipFrameCount < this.maxSkipFrames || elapsed >= this.frameInterval * 2) {
                this.clearCanvas();
                const hasValidStreams = this.renderCurrentLayout();
                
                // Nur rendern wenn g√ºltige Streams vorhanden
                if (hasValidStreams) {
                    this.updateRecordingIndicator();
                    this.skipFrameCount = 0;
                } else if (this.enableFrameSkipping) {
                    this.skipFrameCount++;
                }
                
                this.lastRenderTime = now;
                this.updatePerformanceMetrics(performance.now() - renderStart);
            } else if (this.enableFrameSkipping) {
                this.skipFrameCount++;
                this.performanceMetrics.droppedFrames++;
            }
        }
        
        this.animationFrame = requestAnimationFrame(() => this.renderComposition());
    }

    renderCurrentLayout() {
        const streams = Array.from(this.streams.entries());
        let hasValidStreams = false;
        
        // üîç Vorab-Check: Mindestens ein Stream bereit?
        for (const [type, stream] of streams) {
            const video = this.getVideoElementOptimized(type, stream);
            if (video && video.readyState >= 2 && !video.paused) {
                hasValidStreams = true;
                break;
            }
        }
        
        if (!hasValidStreams) {
            return false; // Kein g√ºltiger Stream
        }
        
        try {
            switch (this.currentLayout) {
                case 'fullscreen':
                    this.renderFullscreen(streams);
                    break;
                case 'pip':
                    this.renderPictureInPicture(streams);
                    break;
                case 'side':
                    this.renderSideBySide(streams);
                    break;
                case 'stack':
                    this.renderStacked(streams);
                    break;
                case 'threeCols':
                    this.renderThreeColumns(streams);
                    break;
                case 'leftBigRight2':
                    this.renderLeftBigRightTwo(streams);
                    break;
                case 'grid2x2':
                    this.renderGrid2x2(streams);
                    break;
                default:
                    // Default: Intelligente Auswahl basierend auf Stream-Anzahl
                    this.renderSmartDefault(streams);
            }
            return true;
        } catch (error) {
            console.warn('‚ö†Ô∏è Render error:', error);
            if (this.enableErrorRecovery) {
                this.handleRenderError(error);
            }
            return false;
        }
    }

    renderPictureInPicture(streams) {
        const map = new Map(streams);
        
        // Background: prefer screen, fallback to first stream
        let bgEntry = map.has('screen') ? ['screen', map.get('screen')] : streams[0];
        if (bgEntry) {
            const [bgType, bgStream] = bgEntry;
            const bgVideo = this.getVideoElementOptimized(bgType, bgStream);
            if (bgVideo && bgVideo.readyState >= 2) {
                this.drawVideoCover(bgVideo, 0, 0, this.canvas.width, this.canvas.height);
            }
        }

        // Overlay: Camera if available
        if (map.has('camera')) {
            const camVideo = this.getVideoElementOptimized('camera', map.get('camera'));
            if (camVideo && camVideo.readyState >= 2) {
                const size = 120;
                const x = this.canvas.width - size - 20;
                const y = 20;
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = 3;
                this.ctx.strokeRect(x - 3, y - 3, size + 6, size + 6);
                this.drawVideoContain(camVideo, x, y, size, size);
            }
        }
    }

    renderSideBySide(streams) {
        const streamArray = Array.from(streams).slice(0, 2); // Nur 2 Streams
        const halfWidth = this.canvas.width / 2;
        
        streamArray.forEach(([type, stream], index) => {
            const video = this.getVideoElementOptimized(type, stream);
            if (!video || video.readyState < 2) return;
            
            const x = index * halfWidth;
            this.drawVideoContain(video, x, 0, halfWidth, this.canvas.height);
            
            // Draw separator
            if (index === 0 && streamArray.length > 1) {
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(halfWidth, 0);
                this.ctx.lineTo(halfWidth, this.canvas.height);
                this.ctx.stroke();
            }
        });
    }

    renderFullscreen(streams) {
        // Vollbild: Ersten verf√ºgbaren Stream verwenden
        const streamArray = Array.from(streams);
        if (streamArray.length === 0) return;
        
        const [type, stream] = streamArray[0];
        const video = this.getVideoElementOptimized(type, stream);
        if (video && video.readyState >= 2) {
            this.drawVideoCover(video, 0, 0, this.canvas.width, this.canvas.height);
        }
    }

    renderStacked(streams) {
        // Gestapelt: Streams √ºbereinander
        const streamArray = Array.from(streams).slice(0, 2);
        const halfHeight = this.canvas.height / 2;
        
        streamArray.forEach(([type, stream], index) => {
            const video = this.getVideoElementOptimized(type, stream);
            if (!video || video.readyState < 2) return;
            
            const y = index * halfHeight;
            this.drawVideoContain(video, 0, y, this.canvas.width, halfHeight);
            
            // Draw separator
            if (index === 0 && streamArray.length > 1) {
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(0, halfHeight);
                this.ctx.lineTo(this.canvas.width, halfHeight);
                this.ctx.stroke();
            }
        });
    }

    renderThreeColumns(streams) {
        // 3 Spalten Layout
        const streamArray = Array.from(streams).slice(0, 3);
        const colWidth = this.canvas.width / 3;
        
        streamArray.forEach(([type, stream], index) => {
            const video = this.getVideoElementOptimized(type, stream);
            if (!video || video.readyState < 2) return;
            
            const x = index * colWidth;
            this.drawVideoContain(video, x, 0, colWidth, this.canvas.height);
            
            // Draw separators
            if (index < streamArray.length - 1) {
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(x + colWidth, 0);
                this.ctx.lineTo(x + colWidth, this.canvas.height);
                this.ctx.stroke();
            }
        });
    }

    renderLeftBigRightTwo(streams) {
        // Links gro√ü, rechts zwei kleine
        const streamArray = Array.from(streams).slice(0, 3);
        if (streamArray.length === 0) return;
        
        const leftWidth = this.canvas.width * 0.6;
        const rightWidth = this.canvas.width * 0.4;
        const rightHalfHeight = this.canvas.height / 2;
        
        // Linker gro√üer Stream
        const [mainType, mainStream] = streamArray[0];
        const mainVideo = this.getVideoElementOptimized(mainType, mainStream);
        if (mainVideo && mainVideo.readyState >= 2) {
            this.drawVideoContain(mainVideo, 0, 0, leftWidth, this.canvas.height);
        }
        
        // Rechte zwei kleinere Streams
        streamArray.slice(1, 3).forEach(([type, stream], index) => {
            const video = this.getVideoElementOptimized(type, stream);
            if (!video || video.readyState < 2) return;
            
            const y = index * rightHalfHeight;
            this.drawVideoContain(video, leftWidth, y, rightWidth, rightHalfHeight);
        });
        
        // Separators
        this.ctx.strokeStyle = '#fff';
        this.ctx.lineWidth = 2;
        // Vertical separator
        this.ctx.beginPath();
        this.ctx.moveTo(leftWidth, 0);
        this.ctx.lineTo(leftWidth, this.canvas.height);
        this.ctx.stroke();
        // Horizontal separator (rechts)
        if (streamArray.length > 2) {
            this.ctx.beginPath();
            this.ctx.moveTo(leftWidth, rightHalfHeight);
            this.ctx.lineTo(this.canvas.width, rightHalfHeight);
            this.ctx.stroke();
        }
    }

    renderGrid2x2(streams) {
        // 2x2 Raster Layout
        const streamArray = Array.from(streams).slice(0, 4);
        const halfWidth = this.canvas.width / 2;
        const halfHeight = this.canvas.height / 2;
        
        const positions = [
            { x: 0, y: 0 },                    // Top-left
            { x: halfWidth, y: 0 },             // Top-right
            { x: 0, y: halfHeight },            // Bottom-left
            { x: halfWidth, y: halfHeight }     // Bottom-right
        ];
        
        streamArray.forEach(([type, stream], index) => {
            const video = this.getVideoElementOptimized(type, stream);
            if (!video || video.readyState < 2) return;
            
            const pos = positions[index];
            this.drawVideoContain(video, pos.x, pos.y, halfWidth, halfHeight);
        });
        
        // Draw grid separators
        this.ctx.strokeStyle = '#fff';
        this.ctx.lineWidth = 2;
        // Vertical separator
        this.ctx.beginPath();
        this.ctx.moveTo(halfWidth, 0);
        this.ctx.lineTo(halfWidth, this.canvas.height);
        this.ctx.stroke();
        // Horizontal separator
        this.ctx.beginPath();
        this.ctx.moveTo(0, halfHeight);
        this.ctx.lineTo(this.canvas.width, halfHeight);
        this.ctx.stroke();
    }

    renderSmartDefault(streams) {
        // Intelligente Standard-Auswahl basierend auf Stream-Anzahl
        const count = streams.length;
        
        if (count === 1) {
            this.renderFullscreen(streams);
        } else if (count === 2) {
            this.renderPictureInPicture(streams);
        } else if (count === 3) {
            this.renderLeftBigRightTwo(streams);
        } else if (count >= 4) {
            this.renderGrid2x2(streams);
        }
    }

    // üöÄ OPTIMIZED: Video Element Pool Management
    getVideoElementOptimized(type, stream) {
        // 1. Check pool first (Performance)
        if (this.videoElements.has(type)) {
            const video = this.videoElements.get(type);
            if (video.srcObject === stream && video.readyState >= 2) {
                return video;
            }
        }
        
        // 2. Check existing video element
        let video = document.getElementById(`video-${type}`);
        if (video && video.srcObject === stream) {
            if (video.readyState >= 2) {
                this.videoElements.set(type, video);
                return video;
            }
            return null; // Video not ready yet
        }
        
        // 3. Create new video element (last resort)
        if (!video) {
            video = document.createElement('video');
            video.id = `video-${type}`;
            video.autoplay = true;
            video.muted = true;
            video.playsInline = true;
            video.style.display = 'none';
            video.style.position = 'absolute';
            video.style.top = '-9999px';
            document.body.appendChild(video);
            
            // üéØ PERFORMANCE: Only set if necessary
            if (video.srcObject !== stream) {
                video.srcObject = stream;
            }
            
            // Optimized playback start
            const initVideo = async () => {
                try {
                    if (video.readyState >= 2) {
                        await video.play();
                        this.videoElements.set(type, video);
                    } else {
                        video.addEventListener('loadedmetadata', async () => {
                            try {
                                await video.play();
                                this.videoElements.set(type, video);
                            } catch (err) {
                                console.warn('Video play failed:', err);
                            }
                        }, { once: true });
                    }
                } catch (err) {
                    console.warn('Video init failed:', err);
                }
            };
            
            initVideo();
            return null; // Not ready immediately
        }
        
        return video.readyState >= 2 ? video : null;
    }

    cleanupVideoElement(type) {
        if (this.videoElements.has(type)) {
            this.videoElements.delete(type);
        }
        
        const video = document.getElementById(`video-${type}`);
        if (video) {
            video.srcObject = null;
            video.remove();
        }
    }

    // Helper: draw video preserving aspect ratio (contain)
    drawVideoContain(video, dx, dy, dw, dh) {
        const vw = video.videoWidth || 16;
        const vh = video.videoHeight || 9;
        const videoAspect = vw / vh;
        const targetAspect = dw / dh;
        
        let renderW, renderH, x, y;
        if (videoAspect > targetAspect) {
            renderW = dw;
            renderH = dw / videoAspect;
            x = dx;
            y = dy + (dh - renderH) / 2;
        } else {
            renderH = dh;
            renderW = dh * videoAspect;
            x = dx + (dw - renderW) / 2;
            y = dy;
        }
        
        this.ctx.drawImage(video, x, y, renderW, renderH);
    }

    // Helper: draw video covering target rect (cover) with cropping
    drawVideoCover(video, dx, dy, dw, dh) {
        const vw = video.videoWidth || 16;
        const vh = video.videoHeight || 9;
        const videoAspect = vw / vh;
        const targetAspect = dw / dh;
        
        let sx = 0, sy = 0, sw = vw, sh = vh;
        if (videoAspect > targetAspect) {
            sw = vh * targetAspect;
            sx = (vw - sw) / 2;
        } else {
            sh = vw / targetAspect;
            sy = (vh - sh) / 2;
        }
        
        this.ctx.drawImage(video, sx, sy, sw, sh, dx, dy, dw, dh);
    }

    clearCanvas() {
        // üöÄ PERFORMANCE: Only clear when necessary
        this.ctx.fillStyle = '#000000';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Show/hide no content overlay
        const hasStreams = this.streams.size > 0;
        document.getElementById('noContentOverlay').style.display = hasStreams ? 'none' : 'block';
    }

    // Recording Methods
    startRecordingWithCountdown() {
        if (!this.isComposing) {
            alert('Bitte starten Sie zuerst die Live-Komposition');
            return;
        }
        
        const overlay = document.getElementById('countdownOverlay');
        const num = document.getElementById('countdownNumber');
        if (!overlay || !num) return this.startRecording();
        
        let n = 3;
        num.textContent = n;
        overlay.style.display = 'block';
        
        const interval = setInterval(() => {
            n -= 1;
            if (n === 0) {
                clearInterval(interval);
                overlay.style.display = 'none';
                this.startRecording();
            } else {
                num.textContent = n;
            }
        }, 700);
    }

    startRecording() {
        if (!this.isComposing) {
            alert('Bitte starten Sie zuerst die Live-Komposition');
            return;
        }

        try {
            // üéØ OPTIMIZED: Adaptive frame rate based on browser
            const targetFPS = this.getBrowserOptimalFPS();
            const stream = this.canvas.captureStream(targetFPS);
            
            // üöÄ IMPROVED MediaRecorder configuration
            const options = this.getOptimalRecorderOptions();
            this.mediaRecorder = new MediaRecorder(stream, options);
            
            this.recordedChunks = [];
            this.pausedAccum = 0;
            this.pauseStart = null;

            console.log(`üìπ MediaRecorder gestartet: ${targetFPS}fps, ${options.videoBitsPerSecond}bps`);

            this.mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    this.recordedChunks.push(event.data);
                }
            };

            this.mediaRecorder.onstop = () => {
                const blob = new Blob(this.recordedChunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                this.showPreviewModal(url);
                this.resetRecordingUI();
            };

            this.mediaRecorder.start();
            this.isRecording = true;
            this.recordingStartTime = Date.now();
            
            document.getElementById('recordBtn').disabled = true;
            document.getElementById('stopRecordBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = false;
            document.getElementById('recordingStatus').textContent = 'Status: Aufnahme l√§uft';
            document.getElementById('recordingIndicator').style.display = 'block';
            
            this.startRecordingTimer();
            console.log('üìπ Recording gestartet');

        } catch (error) {
            console.error('‚ùå Recording Fehler:', error);
            alert('Aufnahme-Fehler: ' + error.message);
        }
    }

    stopRecording() {
        if (this.mediaRecorder && this.mediaRecorder.state === 'recording') {
            this.mediaRecorder.stop();
            this.isRecording = false;
            this.stopRecordingTimer();
            console.log('üìπ Recording gestoppt');
        }
    }

    togglePauseRecording() {
        if (!this.mediaRecorder) return;
        
        const btn = document.getElementById('pauseBtn');
        if (this.mediaRecorder.state === 'recording') {
            this.mediaRecorder.pause();
            this.pauseStart = Date.now();
            this.stopRecordingTimer();
            btn.innerHTML = '<i class="fas fa-play me-2"></i>Fortsetzen';
            document.getElementById('recordingStatus').textContent = 'Status: Aufnahme pausiert';
        } else if (this.mediaRecorder.state === 'paused') {
            this.mediaRecorder.resume();
            if (this.pauseStart) {
                this.pausedAccum += Date.now() - this.pauseStart;
                this.pauseStart = null;
            }
            this.startRecordingTimer();
            btn.innerHTML = '<i class="fas fa-pause me-2"></i>Pausieren';
            document.getElementById('recordingStatus').textContent = 'Status: Aufnahme l√§uft';
        }
    }

    startRecordingTimer() {
        this.recordingTimer = setInterval(() => {
            const elapsed = Date.now() - this.recordingStartTime - (this.pausedAccum || 0);
            const minutes = Math.floor(elapsed / 60000);
            const seconds = Math.floor((elapsed % 60000) / 1000);
            
            const timeStr = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('recordingTime').textContent = timeStr;
            document.getElementById('recordingTimeIndicator').textContent = timeStr;
            
            const progress = (elapsed / this.maxDuration) * 100;
            document.getElementById('recordingProgress').style.width = `${Math.min(progress, 100)}%`;
            
            // Auto-stop at max duration
            if (elapsed >= this.maxDuration) {
                this.stopRecording();
                alert('Aufnahme beendet - Maximale Aufnahmedauer erreicht (3 Minuten)');
            }
        }, 1000);
    }

    stopRecordingTimer() {
        if (this.recordingTimer) {
            clearInterval(this.recordingTimer);
            this.recordingTimer = null;
        }
    }

    resetRecordingUI() {
        const recordBtn = document.getElementById('recordBtn');
        const stopBtn = document.getElementById('stopRecordBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const status = document.getElementById('recordingStatus');
        const indicator = document.getElementById('recordingIndicator');
        const progress = document.getElementById('recordingProgress');
        const time = document.getElementById('recordingTime');
        
        if (recordBtn) recordBtn.disabled = false;
        if (stopBtn) stopBtn.disabled = true;
        if (pauseBtn) {
            pauseBtn.disabled = true;
            pauseBtn.innerHTML = '<i class="fas fa-pause me-2"></i>Pausieren';
        }
        if (status) status.textContent = 'Status: Bereit f√ºr Aufnahme';
        if (indicator) indicator.style.display = 'none';
        if (progress) progress.style.width = '0%';
        if (time) time.textContent = '00:00';
        
        document.getElementById('recordingStateIndicator').innerHTML = '<i class="fas fa-stop me-1"></i>Gestoppt';
    }

    updateRecordingIndicator() {
        const indicator = document.getElementById('recordingIndicator');
        if (indicator) {
            indicator.style.display = this.isRecording ? 'block' : 'none';
        }
    }

    // Preview Modal
    showPreviewModal(videoUrl) {
        const existing = document.getElementById('recordPreviewModal');
        if (existing) existing.remove();
        
        const html = `
            <div class="modal fade" id="recordPreviewModal" tabindex="-1">
                <div class="modal-dialog modal-lg">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title"><i class="fas fa-play me-2"></i>Aufnahme Vorschau</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                        </div>
                        <div class="modal-body text-center">
                            <video id="previewVideo" controls style="max-width:100%;max-height:400px;">
                                <source src="${videoUrl}" type="video/webm">
                                Ihr Browser unterst√ºtzt das Video-Element nicht.
                            </video>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Schlie√üen</button>
                            <button type="button" class="btn btn-success" id="downloadFromPreview">
                                <i class="fas fa-download me-2"></i>Herunterladen
                            </button>
                        </div>
                    </div>
                </div>
            </div>`;
        
        document.body.insertAdjacentHTML('beforeend', html);
        
        document.getElementById('downloadFromPreview')?.addEventListener('click', () => {
            const a = document.createElement('a');
            a.href = videoUrl;
            a.download = `streamrec-optimized-${Date.now()}.webm`;
            a.click();
        });
        
        if (window.bootstrap) {
            const modal = new bootstrap.Modal(document.getElementById('recordPreviewModal'));
            modal.show();
        }
    }

    // üöÄ PERFORMANCE OPTIMIZATION METHODS
    getBrowserOptimalFPS() {
        const ua = navigator.userAgent;
        
        // üöÄ PYTHONANYWHERE OPTIMIZED: Konservativere FPS f√ºr Server-Umgebung
        if (ua.includes('Chrome')) return Math.min(this.targetFPS, 25); // Reduziert von 30
        if (ua.includes('Firefox')) return Math.min(this.targetFPS, 20); // Reduziert von 25  
        if (ua.includes('Safari')) return Math.min(this.targetFPS, 15); // Reduziert von 20
        if (ua.includes('Edge')) return Math.min(this.targetFPS, 20);
        
        // Default f√ºr Server-Umgebung: Konservativ
        return Math.min(this.targetFPS, 20);
    }

    getOptimalRecorderOptions() {
        const quality = document.getElementById('qualitySelect')?.value || 'medium';
        const bitrate = document.getElementById('bitrateSetting')?.value || '1500000'; // Reduziert f√ºr Server
        
        // üöÄ PYTHONANYWHERE OPTIMIZED: Konservativere Bitrates
        let serverOptimizedBitrate = parseInt(bitrate);
        switch (quality) {
            case 'high':
                serverOptimizedBitrate = Math.min(serverOptimizedBitrate, 2000000); // Max 2 Mbps
                break;
            case 'medium':
                serverOptimizedBitrate = Math.min(serverOptimizedBitrate, 1500000); // Max 1.5 Mbps
                break;
            case 'low':
                serverOptimizedBitrate = Math.min(serverOptimizedBitrate, 800000);  // Max 0.8 Mbps
                break;
        }
        
        let options = {
            mimeType: 'video/webm;codecs=vp8',
            videoBitsPerSecond: serverOptimizedBitrate
        };
        
        // üõ°Ô∏è ROBUST FALLBACK f√ºr verschiedene Server-Umgebungen
        const supportedTypes = [
            'video/webm;codecs=vp8,opus',
            'video/webm;codecs=vp8',
            'video/webm',
            'video/mp4'
        ];
        
        for (const type of supportedTypes) {
            if (MediaRecorder.isTypeSupported(type)) {
                options.mimeType = type;
                break;
            }
        }
        
        console.log('üìπ Server-optimierte MediaRecorder Options:', options);
        return options;
    }

    applyQualitySettings(quality) {
        switch (quality) {
            case 'high':
                this.targetFPS = 30;
                this.maxSkipFrames = 1;
                break;
            case 'medium':
                this.targetFPS = 25;
                this.maxSkipFrames = 2;
                break;
            case 'low':
                this.targetFPS = 20;
                this.maxSkipFrames = 3;
                break;
        }
        this.frameInterval = 1000 / this.targetFPS;
    }

    handleRenderError(error) {
        console.warn('üîß Auto-recovery from render error:', error);
        
        // Reset problematic states
        this.skipFrameCount = 0;
        
        // Clear video element pool if corrupted
        if (error.message.includes('video') || error.message.includes('canvas')) {
            this.videoElements.clear();
        }
    }

    // Performance Monitoring
    initPerformanceMonitoring() {
        setInterval(() => {
            this.calculateFPS();
        }, 1000);
    }

    updatePerformanceMetrics(renderTime) {
        this.performanceMetrics.totalFrames++;
        this.renderTimeBuffer.push(renderTime);
        
        // Keep buffer size manageable
        if (this.renderTimeBuffer.length > 60) {
            this.renderTimeBuffer.shift();
        }
        
        // Calculate average render time
        const avgRenderTime = this.renderTimeBuffer.reduce((a, b) => a + b, 0) / this.renderTimeBuffer.length;
        this.performanceMetrics.averageRenderTime = avgRenderTime;
    }

    calculateFPS() {
        const now = performance.now();
        const elapsed = now - this.lastFPSUpdate;
        
        if (elapsed >= 1000) {
            const fps = Math.round(this.performanceBuffer.length * 1000 / elapsed);
            this.performanceMetrics.lastFPS = fps;
            this.performanceBuffer = [];
            this.lastFPSUpdate = now;
            
            this.updatePerformanceDisplay();
        }
        
        this.performanceBuffer.push(now);
    }

    updatePerformanceDisplay() {
        const indicator = document.getElementById('performanceIndicator');
        if (!indicator || indicator.style.display === 'none') return;
        
        const fps = this.performanceMetrics.lastFPS;
        const dropped = this.performanceMetrics.droppedFrames;
        const renderTime = Math.round(this.performanceMetrics.averageRenderTime);
        
        document.getElementById('fpsCounter').textContent = fps;
        document.getElementById('frameCounter').textContent = this.performanceMetrics.totalFrames;
        document.getElementById('droppedCounter').textContent = dropped;
        document.getElementById('renderTime').textContent = renderTime + 'ms';
        
        // Color coding
        indicator.className = 'performance-indicator ';
        if (fps >= this.targetFPS * 0.8 && renderTime < 16) {
            indicator.className += 'performance-good';
        } else if (fps >= this.targetFPS * 0.6 && renderTime < 25) {
            indicator.className += 'performance-warning';
        } else {
            indicator.className += 'performance-critical';
        }
    }

    togglePerformanceMonitor(show) {
        const indicator = document.getElementById('performanceIndicator');
        if (indicator) {
            indicator.style.display = show ? 'block' : 'none';
        }
    }

    // Utility Methods
    updateStatus(type, message, variant) {
        const statusElement = document.getElementById(`${type}Status`);
        if (statusElement) {
            statusElement.textContent = `Status: ${message}`;
            statusElement.className = `text-${variant} d-block mt-2`;
        }
    }

    updateButtons(type, active) {
        const startBtn = document.getElementById(`start${type.charAt(0).toUpperCase() + type.slice(1)}Btn`);
        const stopBtn = document.getElementById(`stop${type.charAt(0).toUpperCase() + type.slice(1)}Btn`);
        
        if (startBtn) startBtn.disabled = active;
        if (stopBtn) stopBtn.disabled = !active;
        
        if (type === 'composition') {
            document.getElementById('recordBtn').disabled = !active;
        }
    }

    updateStatusBadge(type, variant) {
        const badge = document.getElementById(`${type}StatusBadge`);
        if (badge) {
            const icon = badge.querySelector('i');
            if (icon) {
                icon.className = `fas fa-circle text-${variant}`;
            }
        }
    }

    updateActiveStreamsCount() {
        const counter = document.getElementById('activeStreams');
        if (counter) {
            counter.textContent = this.streams.size;
        }
    }

    checkCompositionReady() {
        const hasStreams = this.streams.size > 0;
        document.getElementById('startCompositionBtn').disabled = !hasStreams;
        
        if (hasStreams && !this.isComposing) {
            this.startComposition();
        } else if (!hasStreams && this.isComposing) {
            this.stopComposition();
        }
    }

    // Settings Management
    loadSettings() {
        try {
            const stored = localStorage.getItem('streamrec-optimized-settings');
            if (stored) {
                const settings = JSON.parse(stored);
                if (settings.targetFPS) {
                    this.targetFPS = settings.targetFPS;
                    document.getElementById('fpsSelect').value = settings.targetFPS;
                }
                if (settings.enableFrameSkipping !== undefined) {
                    this.enableFrameSkipping = settings.enableFrameSkipping;
                    document.getElementById('enableFrameSkipping').checked = settings.enableFrameSkipping;
                }
                if (settings.enableErrorRecovery !== undefined) {
                    this.enableErrorRecovery = settings.enableErrorRecovery;
                    document.getElementById('enableErrorRecovery').checked = settings.enableErrorRecovery;
                }
                if (settings.showPerformance !== undefined) {
                    this.togglePerformanceMonitor(settings.showPerformance);
                    document.getElementById('enablePerformanceMonitor').checked = settings.showPerformance;
                }
            }
        } catch (e) {
            console.warn('Settings load error:', e);
        }
    }

    saveSettings() {
        try {
            const settings = {
                targetFPS: this.targetFPS,
                enableFrameSkipping: document.getElementById('enableFrameSkipping')?.checked ?? true,
                enableErrorRecovery: document.getElementById('enableErrorRecovery')?.checked ?? true,
                showPerformance: document.getElementById('enablePerformanceMonitor')?.checked ?? false,
                resolution: document.getElementById('resolutionSetting')?.value ?? '720p',
                bitrate: document.getElementById('bitrateSetting')?.value ?? '2000000'
            };
            
            localStorage.setItem('streamrec-optimized-settings', JSON.stringify(settings));
            
            // Apply settings
            this.enableFrameSkipping = settings.enableFrameSkipping;
            this.enableErrorRecovery = settings.enableErrorRecovery;
            this.togglePerformanceMonitor(settings.showPerformance);
            
            alert('Einstellungen gespeichert!');
            
            // Close modal
            const modalEl = document.getElementById('settingsModal');
            if (modalEl && window.bootstrap) {
                const modal = bootstrap.Modal.getInstance(modalEl) || new bootstrap.Modal(modalEl);
                modal.hide();
            }
        } catch (e) {
            console.error('Settings save error:', e);
            alert('Speichern fehlgeschlagen: ' + e.message);
        }
    }

    // üìê LAYOUT MANAGEMENT METHODS
    renderStacked(streams) {
        const streamArray = Array.from(streams);
        const height = this.canvas.height / streamArray.length;
        
        streamArray.forEach(([type, stream], index) => {
            const video = this.getVideoElementOptimized(type, stream);
            if (!video || video.readyState < 2) return;
            
            const y = index * height;
            this.drawVideoContain(video, 0, y, this.canvas.width, height);
            
            // Draw separator
            if (index > 0) {
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(0, y);
                this.ctx.lineTo(this.canvas.width, y);
                this.ctx.stroke();
            }
        });
    }

    renderGrid2x2(streams) {
        const items = Array.from(streams).slice(0, 4);
        const cols = 2, rows = 2;
        const cellW = Math.floor(this.canvas.width / cols);
        const cellH = Math.floor(this.canvas.height / rows);
        
        items.forEach(([type, stream], idx) => {
            const video = this.getVideoElementOptimized(type, stream);
            if (!video || video.readyState < 2) return;
            
            const col = idx % cols;
            const row = Math.floor(idx / cols);
            const dx = col * cellW;
            const dy = row * cellH;
            
            this.drawVideoContain(video, dx, dy, cellW, cellH);
            
            // Draw grid lines
            this.ctx.strokeStyle = '#fff';
            this.ctx.lineWidth = 2;
            if (col === 0) {
                this.ctx.beginPath();
                this.ctx.moveTo(cellW, 0);
                this.ctx.lineTo(cellW, this.canvas.height);
                this.ctx.stroke();
            }
            if (row === 0) {
                this.ctx.beginPath();
                this.ctx.moveTo(0, cellH);
                this.ctx.lineTo(this.canvas.width, cellH);
                this.ctx.stroke();
            }
        });
    }

    renderThreeColumns(streams) {
        const items = Array.from(streams).slice(0, 3);
        const colW = Math.floor(this.canvas.width / 3);
        
        items.forEach(([type, stream], idx) => {
            const video = this.getVideoElementOptimized(type, stream);
            if (!video || video.readyState < 2) return;
            
            const dx = idx * colW;
            this.drawVideoContain(video, dx, 0, colW, this.canvas.height);
            
            // Draw separators
            if (idx > 0) {
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(dx, 0);
                this.ctx.lineTo(dx, this.canvas.height);
                this.ctx.stroke();
            }
        });
    }

    renderLeftBigRightTwo(streams) {
        const streamArray = Array.from(streams);
        if (streamArray.length < 3) return this.renderStacked(streamArray);
        
        const left = streamArray[0];
        const right = streamArray.slice(1, 3);
        const leftW = Math.floor(this.canvas.width * 0.66);
        const rightW = this.canvas.width - leftW;
        const rightH = Math.floor(this.canvas.height / 2);
        
        // Left big
        const [lt, ls] = left;
        const lv = this.getVideoElementOptimized(lt, ls);
        if (lv && lv.readyState >= 2) {
            this.drawVideoContain(lv, 0, 0, leftW, this.canvas.height);
        }
        
        // Right stacked two
        right.forEach(([t, s], i) => {
            const v = this.getVideoElementOptimized(t, s);
            if (v && v.readyState >= 2) {
                const dx = leftW;
                const dy = i * rightH;
                this.drawVideoContain(v, dx, dy, rightW, rightH);
            }
        });
        
        // Separators
        this.ctx.strokeStyle = '#fff';
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.moveTo(leftW, 0);
        this.ctx.lineTo(leftW, this.canvas.height);
        this.ctx.moveTo(leftW, rightH);
        this.ctx.lineTo(this.canvas.width, rightH);
        this.ctx.stroke();
    }

    renderFullscreen(streams) {
        // Show first stream fullscreen
        const firstStream = Array.from(streams)[0];
        if (firstStream) {
            const [type, stream] = firstStream;
            const video = this.getVideoElementOptimized(type, stream);
            if (video && video.readyState >= 2) {
                this.drawVideoCover(video, 0, 0, this.canvas.width, this.canvas.height);
            }
        }
    }

    applyLayout(layout) {
        this.currentLayout = layout;
        console.log(`üìê Layout angewendet: ${layout}`);
        
        // Sofortige Aktualisierung der Komposition wenn aktiv
        if (this.isComposing) {
            this.renderCurrentLayout();
        }
    }

    // üéØ LAYOUT MANAGEMENT
    refreshLayoutChips() {
        const container = document.getElementById('layoutChips');
        const streamCountElement = document.getElementById('layoutStreamCount');
        
        if (!container) return;
        
        const count = this.streams.size;
        const layouts = this.getAvailableLayouts(count);
        
        // Update stream count display
        if (streamCountElement) {
            streamCountElement.textContent = `${count} Stream${count !== 1 ? 's' : ''}`;
        }
        
        if (layouts.length === 0) {
            container.innerHTML = '<small class="text-muted">Starte Streams f√ºr Layouts</small>';
            this.updateLayoutManager([]); // Clear layout manager too
            return;
        }
        
        // Create layout chips (small buttons)
        container.innerHTML = layouts.map(l => 
            `<button type="button" class="btn btn-sm ${this.currentLayout === l.id ? 'btn-primary' : 'btn-outline-primary'}" data-layout="${l.id}" title="${l.description}">${l.name}</button>`
        ).join('');
        
        // Update Layout Manager (large cards)
        this.updateLayoutManager(layouts);
        
        console.log(`üìê Layouts aktualisiert: ${count} Streams, ${layouts.length} Layouts verf√ºgbar`);
    }

    getAvailableLayouts(streamCount) {
        const layouts = [];
        
        if (streamCount >= 1) {
            layouts.push({ 
                id: 'fullscreen', 
                name: 'Vollbild', 
                description: 'Ein Stream im Vollbild',
                icon: 'fas fa-expand-arrows-alt'
            });
        }
        if (streamCount >= 2) {
            layouts.push({ 
                id: 'pip', 
                name: 'PiP', 
                description: 'Picture-in-Picture (Bildschirm + Kamera)',
                icon: 'fas fa-square'
            });
            layouts.push({ 
                id: 'side', 
                name: 'Nebeneinander', 
                description: 'Streams nebeneinander angeordnet',
                icon: 'fas fa-columns'
            });
            layouts.push({ 
                id: 'stack', 
                name: 'Gestapelt', 
                description: 'Streams √ºbereinander angeordnet',
                icon: 'fas fa-stream'
            });
        }
        if (streamCount >= 3) {
            layouts.push({ 
                id: 'threeCols', 
                name: '3 Spalten', 
                description: 'Drei gleichm√§√üige Spalten',
                icon: 'fas fa-grip-vertical'
            });
            layouts.push({ 
                id: 'leftBigRight2', 
                name: 'Links Gro√ü', 
                description: 'Links gro√ü, rechts zwei kleine',
                icon: 'fas fa-th-large'
            });
        }
        if (streamCount >= 4) {
            layouts.push({ 
                id: 'grid2x2', 
                name: '2x2 Grid', 
                description: '2x2 Raster Layout f√ºr 4 Streams',
                icon: 'fas fa-th'
            });
        }
        
        return layouts;
    }

    updateLayoutManager(layouts) {
        const container = document.getElementById('layoutControlsContent');
        const placeholder = document.getElementById('layoutManagerPlaceholder');
        
        if (!container) return;
        
        if (layouts.length === 0) {
            // Show placeholder message
            if (placeholder) {
                placeholder.style.display = 'block';
            } else {
                container.innerHTML = `
                    <div class="alert alert-info" id="layoutManagerPlaceholder">
                        <i class="fas fa-info-circle me-2"></i>
                        Starten Sie Kamera oder Bildschirm-Sharing, um verf√ºgbare Layouts zu sehen
                    </div>`;
            }
            return;
        }
        
        // Hide placeholder
        if (placeholder) {
            placeholder.style.display = 'none';
        }
        
        // Create layout cards with new icons
        const layoutCards = layouts.map(layout => `
            <div class="col-md-6 mb-3">
                <div class="layout-preset-card p-3 border rounded ${this.currentLayout === layout.id ? 'border-primary bg-primary bg-opacity-10' : 'border-light'}" style="cursor: pointer; transition: all 0.2s ease;" data-layout="${layout.id}">
                    <div class="d-flex align-items-center mb-2">
                        <div class="layout-icon me-2" style="width: 30px; height: 30px; background: ${this.currentLayout === layout.id ? '#0d6efd' : '#6c757d'}; border-radius: 6px; display: flex; align-items: center; justify-content: center;">
                            <i class="${layout.icon} text-white" style="font-size: 14px;"></i>
                        </div>
                        <h6 class="mb-0 flex-grow-1">${layout.name}</h6>
                        ${this.currentLayout === layout.id ? '<span class="badge bg-success">Aktiv</span>' : ''}
                    </div>
                    <p class="small text-muted mb-3">${layout.description}</p>
                    <button class="btn btn-sm w-100 ${this.currentLayout === layout.id ? 'btn-primary' : 'btn-outline-primary'}" data-layout="${layout.id}">
                        <i class="fas fa-${this.currentLayout === layout.id ? 'check' : 'play'} me-1"></i>
                        ${this.currentLayout === layout.id ? 'Aktiv' : 'Aktivieren'}
                    </button>
                </div>
            </div>
        `).join('');
        
        container.innerHTML = `<div class="row">${layoutCards}</div>`;
        
        console.log(`üé® Layout Manager aktualisiert: ${layouts.length} Layouts`);
    }

    // Layout Icon Mapping (not needed anymore, using layout.icon directly)
    getLayoutIcon(layoutId) {
        // Legacy fallback, now using layout.icon from getAvailableLayouts
        const icons = {
            'fullscreen': 'expand-arrows-alt',
            'pip': 'square',
            'side': 'columns',
            'stack': 'stream',
            'threeCols': 'grip-vertical',
            'leftBigRight2': 'th-large',
            'grid2x2': 'th'
        };
        return icons[layoutId] || 'square';
    }

    // üñºÔ∏è STREAM THUMBNAIL MANAGEMENT
    addStreamThumbnail(type, stream) {
        const container = document.getElementById('streamThumbnails');
        if (!container) return;
        
        // Remove no streams message
        const noStreamsMsg = document.getElementById('noStreamsMessage');
        if (noStreamsMsg) noStreamsMsg.style.display = 'none';
        
        // Create thumbnail
        const thumbnail = document.createElement('div');
        thumbnail.id = `thumbnail-${type}`;
        thumbnail.className = 'stream-thumbnail position-relative';
        thumbnail.style.cssText = 'width: 120px; height: 90px; border-radius: 0.5rem; overflow: hidden; border: 2px solid #dee2e6;';
        
        const video = document.createElement('video');
        video.srcObject = stream;
        video.autoplay = true;
        video.muted = true;
        video.playsInline = true;
        video.style.cssText = 'width: 100%; height: 100%; object-fit: cover;';
        
        const label = document.createElement('div');
        label.className = 'position-absolute bottom-0 start-0 end-0 bg-dark bg-opacity-75 text-white text-center py-1';
        label.style.fontSize = '0.75rem';
        label.textContent = type === 'camera' ? 'Kamera' : type === 'screen' ? 'Bildschirm' : type;
        
        thumbnail.appendChild(video);
        thumbnail.appendChild(label);
        container.appendChild(thumbnail);
    }

    removeStreamThumbnail(type) {
        const thumbnail = document.getElementById(`thumbnail-${type}`);
        if (thumbnail) {
            thumbnail.remove();
        }
        
        // Show no streams message if no thumbnails left
        const container = document.getElementById('streamThumbnails');
        if (container && container.children.length === 1) { // Only noStreamsMessage left
            const noStreamsMsg = document.getElementById('noStreamsMessage');
            if (noStreamsMsg) noStreamsMsg.style.display = 'block';
        }
    }
}

// Initialize when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        window.streamRecorder = new StreamRecorderOptimized();
    });
} else {
    window.streamRecorder = new StreamRecorderOptimized();
}

console.log('‚úÖ Performance Optimized StreamRec loaded');
</script>
{% endblock %}