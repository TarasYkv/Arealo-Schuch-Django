{% extends 'base.html' %}
{% load static %}
{% load loomads_tags %}

{% block title %}StreamRec - Studio{% endblock %}

{% block page_css %}
<!-- PYTHONANYWHERE OPTIMIZED: Inline CSS for better loading -->
<style>
/* StreamRec Base Styles - Inline for PythonAnywhere */
:root {
    --streamrec-primary: #667eea;
    --streamrec-secondary: #764ba2;
    --streamrec-success: #28a745;
    --streamrec-warning: #ffc107;
    --streamrec-danger: #dc3545;
    --streamrec-info: #17a2b8;
    --streamrec-border-radius: 0.5rem;
    --streamrec-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);
    --streamrec-transition: all 0.2s ease-in-out;
}

.streamrec-btn {
    transition: var(--streamrec-transition);
    border-radius: var(--streamrec-border-radius);
    font-weight: 500;
}

.streamrec-btn:hover {
    transform: translateY(-1px);
    box-shadow: var(--streamrec-shadow);
}

.text-gradient {
    background: linear-gradient(135deg, var(--streamrec-primary) 0%, var(--streamrec-secondary) 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.recording-dot {
    width: 8px;
    height: 8px;
    background: #ffffff;
    border-radius: 50%;
    animation: recordPulse 1.5s ease-in-out infinite;
}

@keyframes recordPulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.3; }
}

@keyframes slideInFromTop {
    0% {
        transform: translateX(-50%) translateY(-100%);
        opacity: 0;
    }
    100% {
        transform: translateX(-50%) translateY(0);
        opacity: 1;
    }
}

@keyframes slideOutToTop {
    0% {
        transform: translateX(-50%) translateY(0);
        opacity: 1;
    }
    100% {
        transform: translateX(-50%) translateY(-100%);
        opacity: 0;
    }
}

@keyframes notificationBounce {
    0% { transform: translateX(-50%) scale(1); }
    15% { transform: translateX(-50%) scale(1.05); }
    30% { transform: translateX(-50%) scale(0.98); }
    50% { transform: translateX(-50%) scale(1.02); }
    100% { transform: translateX(-50%) scale(1); }
}

/* System Info Grid */
.system-info-item {
    padding: 0.5rem;
    text-align: center;
}

.system-info-item small {
    display: block;
    margin-bottom: 0.25rem;
}
/* Performance Optimized Studio Styles */
.studio-container {
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    min-height: 100vh;
    padding: 2rem 0;
}

.studio-header {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
    color: #ffffff !important;
    padding: 2rem 0;
    margin-bottom: 2rem;
    border-radius: 0 0 2rem 2rem;
    box-shadow: 0 4px 20px rgba(102, 126, 234, 0.15);
}

.studio-header h1, .studio-header p, .studio-header i,
.studio-header .phase-indicator, .studio-header .stat-value,
.studio-header .stat-label {
    color: #ffffff !important;
}

.control-panel {
    background: white;
    border-radius: var(--streamrec-border-radius, 0.5rem);
    box-shadow: var(--streamrec-shadow, 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075));
    padding: 1.5rem;
    margin-bottom: 1.5rem;
    transition: var(--streamrec-transition, all 0.2s);
}

.control-panel:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 30px rgba(102, 126, 234, 0.2);
}

.preview-area {
    background: #1a1a1a;
    border-radius: var(--streamrec-border-radius, 0.5rem);
    padding: 1rem;
    box-shadow: var(--streamrec-shadow, 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075));
    min-height: calc(100vh - 180px);
    position: sticky;
    top: 1rem;
}

.phase-indicator {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    background: rgba(255, 255, 255, 0.2);
    padding: 0.5rem 1rem;
    border-radius: 2rem;
    font-size: 0.875rem;
}

.phase-badge {
    background: #ffffff !important;
    color: #4b3ba8 !important;
    padding: 0.25rem 0.75rem;
    border-radius: 1rem;
    font-weight: 600;
    font-size: 0.75rem;
}

/* Performance Indicator */
.performance-indicator {
    position: fixed;
    top: 80px;
    right: 10px;
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 0.5rem;
    border-radius: 0.5rem;
    font-size: 0.75rem;
    z-index: 9999;
    min-width: 200px;
}

.performance-good { border-left: 4px solid #28a745; }
.performance-warning { border-left: 4px solid #ffc107; }
.performance-critical { border-left: 4px solid #dc3545; }

/* CRITICAL FIX: Visibility */
.control-panel, .control-panel *, 
#recordingControlsContainer, #recordingControlsContainer * {
    color: #212529 !important;
    background-color: transparent !important;
}

.control-panel {
    background-color: #ffffff !important;
    border: 1px solid #dee2e6 !important;
}

/* Button fixes */
.btn-primary { background-color: #0d6efd !important; border-color: #0d6efd !important; color: #ffffff !important; }
.btn-success { background-color: #198754 !important; border-color: #198754 !important; color: #ffffff !important; }
.btn-danger { background-color: #dc3545 !important; border-color: #dc3545 !important; color: #ffffff !important; }
.btn-warning { background-color: #fd7e14 !important; border-color: #fd7e14 !important; color: #ffffff !important; }
.btn-info { background-color: #0dcaf0 !important; border-color: #0dcaf0 !important; color: #000000 !important; }
.btn-secondary { background-color: #6c757d !important; border-color: #6c757d !important; color: #ffffff !important; }

.form-select, .form-control { color: #212529 !important; background-color: #ffffff !important; border-color: #ced4da !important; }

/* Left sidebar matches right column height - no height restriction */

/* Fix dropdown overflow in sidebar */
.control-panel .form-select {
    max-width: 100%;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* Compact screen stream items */
.d-flex.justify-content-between.align-items-center.small {
    flex-wrap: nowrap !important;
}

.d-flex.justify-content-between.align-items-center.small .form-select {
    min-width: 80px !important;
    max-width: 100px !important;
}

/* Keep stream thumbnails section responsive but no height restrictions on sidebar */
@media (max-width: 768px) {
    /* Only apply mobile optimizations on actual small screens */
    .control-panel {
        padding: 1rem !important;
        margin-bottom: 1rem !important;
    }
}

/* Audio Level Meter */
.audio-level-meter {
    height: 8px;
    background: #e9ecef;
    border-radius: 4px;
    overflow: hidden;
    position: relative;
}

.audio-level-fill {
    height: 100%;
    background: linear-gradient(90deg, #28a745 0%, #ffc107 70%, #dc3545 100%);
    width: 0%;
    transition: width 0.1s ease;
    border-radius: 4px;
}

/* Audio Status Indicator */
#audioStatusBadge .fas.fa-circle {
    font-size: 0.7rem;
}

#audioStatusBadge .fas.fa-circle.text-success {
    color: #28a745 !important;
}

#audioStatusBadge .fas.fa-circle.text-danger {
    color: #dc3545 !important;
}

#audioStatusBadge .fas.fa-circle.text-warning {
    color: #ffc107 !important;
}

#audioStatusBadge .fas.fa-circle.text-secondary {
    color: #6c757d !important;
}

.audio-level-meter {
    margin: 0.25rem 0;
}

/* Improved Checkbox Visibility */
.form-check-input {
    width: 1.2em !important;
    height: 1.2em !important;
    border: 2px solid #667eea !important;
    background-color: #ffffff !important;
    border-radius: 0.25em !important;
    position: relative !important;
}

.form-check-input:checked {
    background-color: #667eea !important;
    border-color: #667eea !important;
}

.form-check-input:checked::before {
    content: "‚úì" !important;
    position: absolute !important;
    top: 50% !important;
    left: 50% !important;
    transform: translate(-50%, -50%) !important;
    color: white !important;
    font-weight: bold !important;
    font-size: 0.9em !important;
}

.form-check-input:focus {
    border-color: #667eea !important;
    box-shadow: 0 0 0 0.2rem rgba(102, 126, 234, 0.25) !important;
}

.form-check-label {
    cursor: pointer !important;
    user-select: none !important;
}

/* Volume Slider */
.volume-slider {
    width: 100% !important;
    height: 6px !important;
    border-radius: 3px !important;
    background: #e9ecef !important;
    outline: none !important;
    -webkit-appearance: none !important;
    appearance: none !important;
}

.volume-slider::-webkit-slider-thumb {
    -webkit-appearance: none !important;
    appearance: none !important;
    width: 18px !important;
    height: 18px !important;
    border-radius: 50% !important;
    background: #667eea !important;
    cursor: pointer !important;
    box-shadow: 0 2px 6px rgba(0,0,0,0.2) !important;
    border: 2px solid #ffffff !important;
}

.volume-slider::-moz-range-thumb {
    width: 18px !important;
    height: 18px !important;
    border-radius: 50% !important;
    background: #667eea !important;
    cursor: pointer !important;
    border: 2px solid #ffffff !important;
    box-shadow: 0 2px 6px rgba(0,0,0,0.2) !important;
}

.volume-slider::-webkit-slider-track {
    width: 100% !important;
    height: 6px !important;
    cursor: pointer !important;
    background: #e9ecef !important;
    border-radius: 3px !important;
}

.volume-slider::-moz-range-track {
    width: 100% !important;
    height: 6px !important;
    cursor: pointer !important;
    background: #e9ecef !important;
    border-radius: 3px !important;
    border: none !important;
}

/* Drag & Drop Styles for Thumbnails */
.stream-thumbnail {
    transition: all 0.2s ease;
}

.stream-thumbnail.drag-over {
    border: 3px solid #0d6efd !important;
    box-shadow: 0 0 15px rgba(13, 110, 253, 0.5);
    transform: scale(1.05);
}

.stream-thumbnail:active {
    cursor: grabbing !important;
}

/* Layer badge styling */
.stream-thumbnail .badge {
    font-size: 0.65rem;
    padding: 0.2rem 0.4rem;
    pointer-events: none;
}

/* Upload Progress Styles */
.upload-stage {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 10px 15px;
    border-radius: 10px;
    color: #6c757d;
    transition: all 0.3s;
}
.upload-stage i {
    font-size: 1.5rem;
    margin-bottom: 5px;
}
.upload-stage.active {
    background: #e7f1ff;
    color: #0d6efd;
}
.upload-stage.done {
    background: #d1e7dd;
    color: #198754;
}
.upload-stage.error {
    background: #f8d7da;
    color: #dc3545;
}

/* LoomAds Integration */
{% loomads_css %}
</style>
{% endblock %}

{% block fullscreen_content %}
<div class="studio-container">
    <!-- Performance Indicator -->
    <div id="performanceIndicator" class="performance-indicator performance-good" style="display: none;">
        <div><strong>Performance</strong></div>
        <div>FPS: <span id="fpsCounter">30</span></div>
        <div>Frames: <span id="frameCounter">0</span></div>
        <div>Dropped: <span id="droppedCounter">0</span></div>
        <div>Render: <span id="renderTime">0ms</span></div>
    </div>

    <!-- Enhanced Header -->
    <div class="studio-header">
        <div class="container-fluid">
            <div class="row align-items-center">
                <div class="col-md-8">
                    <h1 class="display-5 fw-bold mb-2">
                        <i class="fas fa-video-camera me-3"></i>
                        StreamRec Studio
                    </h1>
                    <p class="lead mb-0">Ultra-schnelle Multi-Stream Video Aufnahme</p>
                    <div class="phase-indicator mt-3">
                        <i class="fas fa-rocket"></i>
                        <span>Performance Edition</span>
                        <div class="phase-badge">Anti-Freeze Technology</div>
                    </div>
                </div>
                <div class="col-md-4 text-md-end">
                    <div class="studio-stats">
                        <div class="row text-center">
                            <div class="col-4">
                                <div class="stat-value">3:00</div>
                                <div class="stat-label">Max. Dauer</div>
                            </div>
                            <div class="col-4">
                                <div class="stat-value" id="currentFormatDisplay">9:16</div>
                                <div class="stat-label">Format</div>
                            </div>
                            <div class="col-4">
                                <div class="stat-value" id="activeStreams">0</div>
                                <div class="stat-label">Streams</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Header Banner Ad -->
    <div class="container-fluid mb-3">
        <div class="row">
            <div class="col-12">
                {% show_ad_zone 'streamrec_recording_header' %}
            </div>
        </div>
    </div>

    <div class="container-fluid">
        <div class="row">
            <!-- Left Column: All Controls -->
            <div class="col-12 col-lg-4 col-xl-3">
                <!-- Output Settings -->
                <div class="control-panel">
                    <h5 class="mb-4">
                        <i class="fas fa-cog me-2 text-primary"></i>
                        Ausgabe-Einstellungen
                    </h5>
                    
                    <!-- Stream Merge Option -->
                    <div class="mb-4">
                        <h6 class="mb-3">
                            <i class="fas fa-layer-group text-info me-2"></i>Video-Ausgabe
                        </h6>
                        
                        <div class="btn-group btn-group-sm w-100 mb-3" role="group" aria-label="Output Mode">
                            <input type="radio" class="btn-check" name="outputMode" id="outputMerged" value="merged" checked>
                            <label class="btn btn-outline-primary" for="outputMerged">
                                <i class="fas fa-compress-alt me-2"></i>Zusammengef√ºgt
                            </label>
                            
                            <input type="radio" class="btn-check" name="outputMode" id="outputSeparate" value="separate">
                            <label class="btn btn-outline-secondary" for="outputSeparate">
                                <i class="fas fa-copy me-2"></i>Einzelne Dateien
                            </label>
                        </div>
                        
                        <!-- Output Mode Info -->
                        <div id="outputModeInfo" class="bg-light border rounded py-2 px-3 small text-muted">
                            <i class="fas fa-info-circle me-2"></i>
                            <strong>Zusammengef√ºgt:</strong> Ein kombiniertes Video mit allen Streams
                        </div>
                    </div>
                </div>

                <!-- Stream Controls -->
                <div class="control-panel">
                    <h5 class="mb-4">
                        <i class="fas fa-sliders-h me-2"></i>
                        Stream Kontrolle
                    </h5>
                    
                    <!-- Camera Section -->
                    <div class="mb-4">
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <h6 class="mb-0">
                                <i class="fas fa-camera text-success me-2"></i>Kamera
                            </h6>
                            <div class="status-indicator" id="cameraStatusBadge">
                                <i class="fas fa-circle text-secondary"></i>
                            </div>
                        </div>
                        
                        <!-- Camera Selection -->
                        <div class="mb-2">
                            <select class="form-select form-select-sm" id="cameraSelect">
                                <option value="">Lade Kameras...</option>
                            </select>
                        </div>
                        
                        <div class="d-grid gap-2">
                            <button id="startCameraBtn" class="btn btn-outline-success">
                                <i class="fas fa-play me-2"></i>Kamera starten
                            </button>
                            <button id="stopCameraBtn" class="btn btn-outline-danger" disabled>
                                <i class="fas fa-stop me-2"></i>Kamera stoppen
                            </button>
                        </div>
                        <small id="cameraStatus" class="text-muted d-block mt-2">Status: Nicht aktiv</small>

                        <!-- Camera Display Mode & Mirror -->
                        <div id="cameraOptionsPanel" style="display: none;" class="mt-3 p-2 bg-light rounded">
                            <div class="mb-2">
                                <label class="form-label mb-1 text-muted" style="font-size: 0.8rem;">Anzeigemodus:</label>
                                <select class="form-select form-select-sm" id="cameraDisplayMode"
                                        onchange="streamrecApp.setStreamDisplayMode('camera', this.value)">
                                    <option value="cover">F√ºllen</option>
                                    <option value="contain">Anpassen</option>
                                    <option value="fill">Schneiden</option>
                                    <option value="crop">Zentriert</option>
                                </select>
                            </div>
                            <div class="form-check">
                                <input class="form-check-input" type="checkbox" id="cameraMirrorToggle"
                                       onchange="streamrecApp.toggleCameraMirror(this.checked)">
                                <label class="form-check-label" for="cameraMirrorToggle" style="font-size: 0.85rem;">
                                    <i class="fas fa-exchange-alt me-1"></i>Kamera spiegeln
                                </label>
                            </div>

                            <!-- Green Screen / Background Removal -->
                            <div class="mt-3 pt-3 border-top">
                                <div class="form-check form-switch">
                                    <input class="form-check-input" type="checkbox" id="greenScreenToggle">
                                    <label class="form-check-label" for="greenScreenToggle" style="font-size: 0.85rem;">
                                        <i class="fas fa-magic me-1"></i>
                                        <strong>Hintergrund entfernen</strong>
                                    </label>
                                </div>
                                <small class="text-muted d-block mt-1" style="font-size: 0.75rem;">
                                    <i class="fas fa-info-circle me-1"></i>Entfernt den Hintergrund (Green Screen Effekt)
                                </small>
                                <!-- Status Badge -->
                                <div id="greenScreenStatus" class="mt-2" style="display: none;">
                                    <span class="badge bg-success">
                                        <i class="fas fa-check-circle me-1"></i>
                                        Green Screen aktiv
                                        <span id="greenScreenFPS" class="ms-1"></span>
                                    </span>
                                </div>
                                <div class="mt-2">
                                    <button class="btn btn-sm btn-outline-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#backgroundAdvancedSettings" aria-expanded="false" aria-controls="backgroundAdvancedSettings">
                                        <i class="fas fa-sliders-h me-1"></i>Feinjustierung
                                    </button>
                                </div>
                                <div class="collapse mt-2" id="backgroundAdvancedSettings">
                                    <div class="bg-light border rounded p-2">
                                        <label for="maskSmoothing" class="form-label" style="font-size: 0.75rem;">
                                            Masken-Gl√§ttung
                                            <span class="ms-1 text-muted" id="maskSmoothingValue">0.65</span>
                                        </label>
                                        <input type="range" class="form-range" id="maskSmoothing" min="0" max="0.95" step="0.05">

                                        <label for="maskConfidence" class="form-label mt-2" style="font-size: 0.75rem;">
                                            Erkennungsgrenze
                                            <span class="ms-1 text-muted" id="maskConfidenceValue">0.60</span>
                                        </label>
                                        <input type="range" class="form-range" id="maskConfidence" min="0.30" max="0.95" step="0.01">

                                        <label for="maskFeather" class="form-label mt-2" style="font-size: 0.75rem;">
                                            Randweichheit
                                            <span class="ms-1 text-muted" id="maskFeatherValue">0.12</span>
                                        </label>
                                        <input type="range" class="form-range" id="maskFeather" min="0" max="0.30" step="0.01">

                                        <label for="maskBlurRadius" class="form-label mt-2" style="font-size: 0.75rem;">
                                            Masken-Blur
                                            <span class="ms-1 text-muted" id="maskBlurRadiusValue">4</span>
                                        </label>
                                        <input type="range" class="form-range" id="maskBlurRadius" min="0" max="10" step="1">
                                        <small class="text-muted d-block mt-2" style="font-size: 0.7rem;">
                                            √Ñnderungen wirken ab dem n√§chsten Frame. Aktuelle Werte werden in der Konsole protokolliert.
                                        </small>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Screen Section -->
                    <div class="mb-4">
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <h6 class="mb-0">
                                <i class="fas fa-desktop text-info me-2"></i>Bildschirm
                            </h6>
                            <div class="status-indicator" id="screenStatusBadge">
                                <i class="fas fa-circle text-secondary"></i>
                            </div>
                        </div>
                        <div class="d-grid gap-2">
                            <button id="startScreenBtn" class="btn btn-outline-info">
                                <i class="fas fa-desktop me-2"></i>Bildschirm teilen
                            </button>
                            <button id="addScreenBtn" class="btn btn-outline-success" disabled>
                                <i class="fas fa-plus me-2"></i>Weiteren Bildschirm hinzuf√ºgen
                            </button>
                            <button id="stopAllScreensBtn" class="btn btn-outline-danger" disabled>
                                <i class="fas fa-stop me-2"></i>Alle Bildschirme stoppen
                            </button>
                        </div>
                        
                        <!-- Active Screen Streams List -->
                        <div id="activeScreens" class="mt-3" style="display: none;">
                            <h6 class="small text-muted mb-2">Aktive Bildschirme:</h6>
                            <div id="screenStreamsList" class="d-flex flex-column gap-1"></div>
                        </div>
                        <small id="screenStatus" class="text-muted d-block mt-2">Status: Nicht aktiv</small>
                    </div>

                    <!-- Audio Section -->
                    <div class="mb-4">
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <h6 class="mb-0">
                                <i class="fas fa-microphone text-danger me-2"></i>Audio
                            </h6>
                            <div class="status-indicator" id="audioStatusBadge">
                                <i class="fas fa-circle text-secondary"></i>
                            </div>
                        </div>
                        <div class="row g-1 mb-2">
                            <div class="col-12">
                                <div class="form-check form-check-sm">
                                    <input class="form-check-input" type="checkbox" id="audioEnabled" checked>
                                    <label class="form-check-label small" for="audioEnabled">
                                        Audio-Aufnahme aktiv
                                    </label>
                                </div>
                            </div>
                            <div class="col-12">
                                <div class="form-check form-check-sm">
                                    <input class="form-check-input" type="checkbox" id="systemAudio" checked>
                                    <label class="form-check-label small" for="systemAudio">
                                        System-Audio einbeziehen
                                    </label>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Microphone Selection -->
                        <div class="mb-3">
                            <label for="microphoneSelect" class="form-label small">Mikrofon ausw√§hlen:</label>
                            <select class="form-select form-select-sm" id="microphoneSelect">
                                <option value="">Lade Mikrofone...</option>
                            </select>
                        </div>
                        
                        <!-- Microphone Volume Control -->
                        <div class="mb-3">
                            <label for="microphoneVolume" class="form-label small">Mikrofonlautst√§rke:</label>
                            <div class="d-flex align-items-center gap-2">
                                <i class="fas fa-volume-down text-muted" style="font-size: 0.8rem;"></i>
                                <input type="range" class="volume-slider" id="microphoneVolume" 
                                       min="0" max="100" value="80" step="5">
                                <i class="fas fa-volume-up text-muted" style="font-size: 0.8rem;"></i>
                                <span class="small text-muted ms-1" id="volumeDisplay">80%</span>
                            </div>
                        </div>

                        <!-- Audio Sync Offset Control -->
                        <div class="mb-3">
                            <label for="audioSyncOffset" class="form-label small">Audio-Synchronisation:</label>
                            <div class="d-flex align-items-center gap-2">
                                <i class="fas fa-backward text-muted" style="font-size: 0.8rem;" title="Audio fr√ºher"></i>
                                <input type="range" class="volume-slider" id="audioSyncOffset"
                                       min="-500" max="500" value="0" step="10">
                                <i class="fas fa-forward text-muted" style="font-size: 0.8rem;" title="Audio sp√§ter"></i>
                                <span class="small text-muted ms-1" id="audioSyncDisplay">0 ms</span>
                            </div>
                            <small class="text-muted" style="font-size: 0.7rem;">Negativ = Audio fr√ºher, Positiv = Audio sp√§ter</small>
                        </div>

                        <!-- Audio Level Meter -->
                        <div class="mb-2">
                            <label class="form-label small">Eingangspegel:</label>
                            <div class="audio-level-meter">
                                <div class="audio-level-fill" id="audioLevelFill"></div>
                            </div>
                        </div>
                        
                        <small id="audioStatus" class="text-muted d-block mt-2">Status: Aktiv</small>
                    </div>

                    <!-- Layout-Schnellwahl -->
                    <div class="mt-4">
                        <div class="d-flex align-items-center justify-content-between mb-2">
                            <h6 class="mb-0">
                                <i class="fas fa-th-large text-info me-2"></i>Layout-Schnellwahl
                            </h6>
                            <small class="text-muted" id="layoutStreamCount">0 Streams</small>
                        </div>
                        <div id="layoutChips" class="d-flex flex-wrap gap-1"></div>
                    </div>
                    
                    <!-- PIP Controls (Picture-in-Picture) -->
                    <div class="mt-4" id="pipControls" style="display: none;">
                        <div class="d-flex align-items-center justify-content-between mb-2">
                            <h6 class="mb-0">
                                <i class="fas fa-square text-primary me-2"></i>PiP Einstellungen
                            </h6>
                        </div>
                        
                        <!-- PIP Size Control -->
                        <div class="mb-3">
                            <label for="pipSize" class="form-label small">Kamera-Gr√∂√üe:</label>
                            <div class="d-flex align-items-center gap-2">
                                <small>Klein</small>
                                <input type="range" class="form-range" id="pipSize" 
                                       min="10" max="40" value="20" step="5">
                                <small>Gro√ü</small>
                                <span class="badge bg-secondary ms-2" id="pipSizeValue">20%</span>
                            </div>
                        </div>
                        
                        <!-- PIP Shape Toggle -->
                        <div class="mb-3">
                            <label class="form-label small">Kamera-Form:</label>
                            <div class="btn-group btn-group-sm w-100" role="group">
                                <input type="radio" class="btn-check" name="pipShape" id="pipShapeSquare" value="square" checked>
                                <label class="btn btn-outline-primary" for="pipShapeSquare">
                                    <i class="fas fa-square me-1"></i>Eckig
                                </label>
                                
                                <input type="radio" class="btn-check" name="pipShape" id="pipShapeCircle" value="circle">
                                <label class="btn btn-outline-primary" for="pipShapeCircle">
                                    <i class="fas fa-circle me-1"></i>Rund
                                </label>
                            </div>
                        </div>
                        
                        <!-- PIP Position -->
                        <div class="mb-3">
                            <label class="form-label small">Position:</label>
                            <div class="alert alert-info p-2">
                                <i class="fas fa-info-circle me-2"></i>
                                <small>Ziehen Sie die Kamera im Preview-Bereich um sie zu positionieren</small>
                            </div>
                        </div>
                    </div>

                </div>


                <!-- Video Storage Status -->
                <div class="control-panel">
                    <h5 class="mb-4">
                        <i class="fas fa-cloud-upload-alt me-2"></i>
                        Video Speicher
                    </h5>
                    <div id="storageStatus" class="text-center">
                        <div class="d-flex justify-content-between align-items-center mb-2">
                            <small class="text-muted">Verwendet:</small>
                            <small id="storageUsed" class="fw-bold">-</small>
                        </div>
                        <div class="progress mb-2" style="height: 8px;">
                            <div id="storageProgress" class="progress-bar bg-info" role="progressbar" style="width: 0%"></div>
                        </div>
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <small class="text-muted">Tarif:</small>
                            <small id="storageTier" class="fw-bold">-</small>
                        </div>
                        <div class="d-grid gap-2">
                            <button id="refreshStorageBtn" class="btn btn-outline-info btn-sm">
                                <i class="fas fa-sync me-1"></i>Aktualisieren
                            </button>
                            <a href="/videos/storage/" target="_blank" class="btn btn-outline-primary btn-sm">
                                <i class="fas fa-cog me-1"></i>Verwalten
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Quick Actions -->
                <div class="control-panel">
                    <h5 class="mb-4">
                        <i class="fas fa-bolt me-2"></i>
                        Schnellaktionen
                    </h5>
                    <div class="d-grid gap-2">
                        <button class="btn btn-outline-primary" onclick="window.location.reload()">
                            <i class="fas fa-redo me-2"></i>Neu laden
                        </button>
                        <button class="btn btn-outline-secondary" data-bs-toggle="modal" data-bs-target="#settingsModal">
                            <i class="fas fa-cog me-2"></i>Einstellungen
                        </button>
                        <a href="{% url 'streamrec:dashboard' %}" class="btn btn-outline-info">
                            <i class="fas fa-arrow-left me-2"></i>Dashboard
                        </a>
                    </div>
                </div>

                <!-- Recording Controls -->
                <div class="control-panel" id="recordingControlsContainer">
                    <h5 class="mb-4">
                        <i class="fas fa-record-vinyl me-2 text-danger"></i>
                        Aufnahme Kontrolle
                    </h5>
                    
                    <div class="d-grid gap-2 mb-3">
                        <button id="recordBtn" class="btn btn-danger">
                            <i class="fas fa-circle me-2"></i>Aufnahme starten
                        </button>
                        <div class="d-flex gap-2">
                            <button id="pauseBtn" class="btn btn-warning flex-fill" disabled>
                                <i class="fas fa-pause me-2"></i>Pausieren
                            </button>
                            <button id="stopRecordBtn" class="btn btn-outline-danger flex-fill" disabled>
                                <i class="fas fa-stop me-2"></i>Stoppen
                            </button>
                        </div>
                    </div>
                    
                    <div class="text-center">
                        <div id="recordingStatus" class="small mb-2">Status: Bereit f√ºr Aufnahme</div>
                        <div class="progress mb-2" style="height: 8px;">
                            <div id="recordingProgress" class="progress-bar bg-danger" style="width: 0%"></div>
                        </div>
                        <div class="d-flex justify-content-between small text-muted">
                            <span id="recordingTime">00:00</span>
                            <span>03:00</span>
                        </div>
                        <div class="mt-2">
                            <span class="badge bg-secondary" id="recordingStateIndicator">
                                <i class="fas fa-stop me-1"></i>Gestoppt
                            </span>
                        </div>
                    </div>
                </div>

                <!-- Sidebar Ad -->
                <div class="mt-4">
                    {% show_ad_zone 'streamrec_recording_sidebar' %}
                </div>

            </div>

            <!-- Right Column: Preview Area and Recording -->
            <div class="col-12 col-lg-8 col-xl-9">
                <div class="preview-area">
                    <!-- Preview Header -->
                    <div class="d-flex justify-content-between align-items-center mb-3">
                        <h5 class="text-white mb-0">
                            <i class="fas fa-eye me-2"></i>
                            Live Vorschau (Performance Optimized)
                        </h5>
                        <div class="preview-controls">
                            <button class="btn btn-sm btn-outline-light me-2" id="fullscreenBtn">
                                <i class="fas fa-expand"></i>
                            </button>
                            <div class="btn-group" role="group">
                                <button class="btn btn-sm btn-outline-light" id="gridToggle">
                                    <i class="fas fa-th"></i>
                                </button>
                                <button class="btn btn-sm btn-outline-light" id="zoomFit">
                                    <i class="fas fa-compress-arrows-alt"></i>
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Canvas Container -->
                    <div id="previewContainer" class="position-relative d-flex align-items-center justify-content-center" 
                         style="height: 600px; border-radius: 0.5rem; overflow: hidden;">
                        
                        <canvas id="compositionCanvas"
                                width="720"
                                height="1280"
                                class="border border-secondary"
                                style="max-width: 100%; max-height: 100%; object-fit: contain;">
                        </canvas>
                        
                        <!-- No Content Overlay -->
                        <div id="noContentOverlay" class="position-absolute top-50 start-50 translate-middle text-center text-white">
                            <div class="mb-4">
                                <i class="fas fa-video fa-4x mb-3 opacity-25"></i>
                                <h4>Keine Streams aktiv</h4>
                                <p class="text-muted">Starten Sie Kamera oder Bildschirm-Sharing um zu beginnen</p>
                            </div>
                            <div class="d-grid gap-2 d-md-flex justify-content-md-center">
                                <button class="btn btn-success" onclick="document.getElementById('startCameraBtn').click()">
                                    <i class="fas fa-camera me-2"></i>Kamera starten
                                </button>
                                <button class="btn btn-info" onclick="document.getElementById('startScreenBtn').click()">
                                    <i class="fas fa-desktop me-2"></i>Bildschirm teilen
                                </button>
                            </div>
                        </div>

                        <!-- Recording Indicator -->
                        <div id="recordingIndicator" class="position-absolute top-0 start-0 m-3" style="display: none;">
                            <div class="d-flex align-items-center bg-danger text-white px-3 py-2 rounded-pill">
                                <div class="recording-dot me-2"></div>
                                <span class="fw-bold">REC</span>
                                <span class="ms-2" id="recordingTimeIndicator">00:00</span>
                            </div>
                        </div>

                        <!-- Countdown Overlay -->
                        <div id="countdownOverlay" class="position-absolute top-50 start-50 translate-middle" style="display:none;">
                            <div class="bg-dark bg-opacity-75 text-white rounded px-5 py-4">
                                <div id="countdownNumber" class="display-3 fw-bold text-center">3</div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Stream Thumbnails -->
                    <div class="mt-4">
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <h6 class="text-white mb-0">Aktive Streams:</h6>
                            <div class="stream-controls-mini">
                                <button class="btn btn-sm btn-outline-light" id="syncStreams" title="Streams synchronisieren">
                                    <i class="fas fa-sync-alt"></i>
                                </button>
                                <button class="btn btn-sm btn-outline-light" data-bs-toggle="modal" data-bs-target="#settingsModal" title="Einstellungen">
                                    <i class="fas fa-cog"></i>
                                </button>
                            </div>
                        </div>
                        <div id="streamThumbnails" class="d-flex gap-3 flex-wrap">
                            <div id="noStreamsMessage" class="text-muted text-center flex-grow-1 py-4">
                                <i class="fas fa-info-circle me-2"></i>
                                Noch keine Streams erfasst
                            </div>
                        </div>
                        <div id="dragDropHint" class="alert alert-info mt-2" style="display: none; font-size: 0.85rem;">
                            <i class="fas fa-hand-paper me-1"></i>
                            <strong>Tipp:</strong> Verschieben Sie Thumbnails per Drag & Drop, um die Ebenen-Reihenfolge zu √§ndern (links=hinten, rechts=vorne). Die Zahlen zeigen die aktuelle Ebene an.
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Settings Modal -->
<div class="modal fade" id="settingsModal" tabindex="-1" aria-labelledby="settingsModalLabel">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header bg-primary text-white">
                <h5 class="modal-title" id="settingsModalLabel">
                    <i class="fas fa-cog me-2"></i>Performance Einstellungen
                </h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <div class="row">
                    <div class="col-md-6">
                        <h6>Video-Einstellungen</h6>
                        <div class="mb-3">
                            <label class="form-label">Bitrate:</label>
                            <select class="form-select" id="bitrateSetting">
                                <option value="8000000">8 Mbps (Ultra HD Qualit√§t) - Nur 1 Stream</option>
                                <option value="6000000">6 Mbps (Sehr hohe Qualit√§t) - Bis 2 Streams</option>
                                <option value="4000000" selected>4 Mbps (Hohe Qualit√§t) - Bis 3 Streams</option>
                                <option value="2500000">2.5 Mbps (Gute Qualit√§t) - Bis 4 Streams</option>
                                <option value="1500000">1.5 Mbps (Grundqualit√§t) - Viele Streams</option>
                            </select>
                            <small class="form-text text-muted">üí° Bitrate wird automatisch an Stream-Anzahl angepasst</small>
                        </div>
                        <div class="mb-3">
                            <label class="form-label">
                                <i class="fas fa-expand-alt me-1"></i>Seitenverh√§ltnis:
                            </label>
                            <select class="form-select" id="aspectRatioSetting">
                                <option value="9:16" selected>9:16 (Vertikal - Social Media)</option>
                                <option value="16:9">16:9 (Horizontal - Standard)</option>
                                <option value="4:3">4:3 (Klassisch - TV Format)</option>
                                <option value="1:1">1:1 (Quadratisch - Instagram)</option>
                                <option value="21:9">21:9 (Ultrawide - Kino)</option>
                                <option value="3:2">3:2 (Foto-Format)</option>
                            </select>
                            <div class="form-text">
                                <i class="fas fa-info-circle me-1"></i>
                                Bestimmt das Format der Aufnahme und Canvas-Anzeige
                            </div>
                            <div class="mt-2" id="aspectRatioPreview">
                                <small class="text-muted">Vorschau:</small>
                                <div class="d-flex align-items-center justify-content-center mt-1" style="height: 60px;">
                                    <div id="previewBox" class="border border-primary bg-primary bg-opacity-10" 
                                         style="width: 45px; height: 25px; transition: all 0.3s ease; display: flex; align-items: center; justify-content: center; border-radius: 4px;">
                                         <i class="fas fa-desktop text-primary" style="font-size: 12px; opacity: 0.6;"></i>
                                    </div>
                                </div>
                                <div class="text-center">
                                    <small class="text-muted" id="previewDimensions">360 √ó 640px (9:16)</small>
                                </div>
                            </div>
                        </div>
                        <div class="mb-3">
                            <label class="form-label">
                                <i class="fas fa-file-video me-1"></i>Ausgabeformat:
                            </label>
                            <select class="form-select" id="outputFormatSetting">
                                <option value="webm">WebM (Alle Browser, VP8/Opus)</option>
                                <option value="mp4" selected>MP4 (Chrome/Edge/Safari, H.264/AAC)</option>
                            </select>
                            <div class="form-text">
                                <i class="fas fa-info-circle me-1"></i>
                                MP4 ben√∂tigt AAC-Audio (H.264+AAC in Chrome/Edge/Safari). Fallback zu WebM wenn AAC nicht verf√ºgbar.
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <h6>Audio-Einstellungen</h6>
                        <div class="mb-3">
                            <label class="form-label">Audio-Qualit√§t:</label>
                            <select class="form-select" id="settingsAudioQuality">
                                <option value="192000">Hoch (192 kbps)</option>
                                <option value="128000" selected>Mittel (128 kbps)</option>
                                <option value="96000">Niedrig (96 kbps)</option>
                            </select>
                        </div>
                        <div class="form-check mb-3">
                            <input class="form-check-input" type="checkbox" id="settingsAGC" checked>
                            <label class="form-check-label" for="settingsAGC">
                                AGC (Automatische Verst√§rkungsregelung)
                            </label>
                        </div>
                        <div class="form-check mb-3">
                            <input class="form-check-input" type="checkbox" id="settingsNoiseSuppression" checked>
                            <label class="form-check-label" for="settingsNoiseSuppression">
                                Rauschunterdr√ºckung
                            </label>
                        </div>
                        <div class="form-check mb-3">
                            <input class="form-check-input" type="checkbox" id="settingsEchoCancellation" checked>
                            <label class="form-check-label" for="settingsEchoCancellation">
                                Echo-Unterdr√ºckung
                            </label>
                        </div>
                    </div>
                </div>
                <div class="row mt-4">
                    <div class="col-md-6">
                        <h6>Performance-Einstellungen</h6>
                        <div class="form-check mb-3">
                            <input class="form-check-input" type="checkbox" id="enableFrameSkipping" checked>
                            <label class="form-check-label" for="enableFrameSkipping">
                                Frame Skipping aktivieren (Anti-Freeze)
                            </label>
                        </div>
                        <div class="form-check mb-3">
                            <input class="form-check-input" type="checkbox" id="enablePerformanceMonitor">
                            <label class="form-check-label" for="enablePerformanceMonitor">
                                Performance Monitor anzeigen
                            </label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="enableErrorRecovery" checked>
                            <label class="form-check-label" for="enableErrorRecovery">
                                Automatische Fehlerkorrektur
                            </label>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Abbrechen</button>
                <button type="button" class="btn btn-primary" id="saveSettings">
                    <i class="fas fa-save me-2"></i>Speichern
                </button>
            </div>
        </div>
    </div>
    
    <!-- Footer Ad Section -->
    <div class="container-fluid mt-4">
        <div class="row">
            <div class="col-12">
                {% show_ad_zone 'streamrec_recording_footer' %}
            </div>
        </div>
    </div>
</div>

<!-- Upload Progress Modal -->
<div class="modal fade" id="uploadProgressModal" data-bs-backdrop="static" data-bs-keyboard="false" tabindex="-1">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-body text-center py-5">
                <div id="uploadIcon" class="mb-4">
                    <i class="fas fa-cloud-upload-alt fa-4x text-primary"></i>
                </div>

                <h4 id="uploadStatus" class="mb-3">Video wird hochgeladen...</h4>

                <div class="progress mb-3" style="height: 25px;">
                    <div class="progress-bar progress-bar-striped progress-bar-animated bg-primary"
                         id="uploadProgressBar" role="progressbar" style="width: 0%">
                        <span id="uploadProgressText">0%</span>
                    </div>
                </div>

                <p id="uploadDetails" class="text-muted mb-0">
                    <span id="uploadedSize">0 MB</span> von <span id="totalSize">0 MB</span>
                </p>

                <p id="uploadSpeed" class="text-muted small mt-2">
                    Geschwindigkeit: <span id="speedValue">-- MB/s</span>
                </p>

                <div id="uploadStage" class="mt-4">
                    <div class="d-flex justify-content-center align-items-center gap-3">
                        <div class="upload-stage active" id="uploadStage1">
                            <i class="fas fa-upload"></i>
                            <small>Hochladen</small>
                        </div>
                        <i class="fas fa-chevron-right text-muted"></i>
                        <div class="upload-stage" id="uploadStage2">
                            <i class="fas fa-cog"></i>
                            <small>Verarbeiten</small>
                        </div>
                        <i class="fas fa-chevron-right text-muted"></i>
                        <div class="upload-stage" id="uploadStage3">
                            <i class="fas fa-check"></i>
                            <small>Fertig</small>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block page_js %}
<!-- MediaPipe Selfie Segmentation Library -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js" crossorigin="anonymous"></script>

<!-- GPU-Beschleunigung: Camera Utils f√ºr optimierte Frame-√úbergabe -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>

<!-- No external conversion library needed - using browser-native MP4 recording -->

<script>
console.log('üöÄ StreamRec Performance Optimized Version (PythonAnywhere Ready) wird geladen...');

/**
 * üöÄ PERFORMANCE OPTIMIZED StreamRec - PYTHONANYWHERE EDITION
 * Anti-Freeze Technology mit intelligenter Frame-Rate Kontrolle
 * Optimiert f√ºr Server-Deployment mit minimalen Abh√§ngigkeiten
 */
class StreamRecorderOptimized {
    constructor() {
        // Basic properties
        this.streams = new Map();
        this.activeStreams = new Set(); // Tracks which streams are currently active for rendering
        this.streamOrder = []; // Tracks order of streams for z-index (left=back, right=front)
        this.streamPositions = new Map(); // Stores position/size for each stream in free layout
        this.draggedThumbnail = null; // For drag & drop functionality
        this.streamMirror = new Map(); // Tracks mirror state for each stream (true/false)
        this.canvas = null;
        this.ctx = null;
        this.isComposing = false;
        this.animationFrame = null;
        this.currentLayout = 'pip';
        this.mediaRecorder = null;
        this.recordedChunks = [];
        this.isRecording = false;
        this.outputMode = 'merged'; // 'merged' or 'separate'
        this.outputFormat = 'mp4'; // 'webm' or 'mp4' - format for browser-native recording
        this.separateFiles = null; // Store separate file data for bulk download
        this.separateRecorders = new Map(); // Store individual MediaRecorders for each stream
        this.separateChunks = new Map(); // Store recorded chunks for each stream
        this.processingRecordings = false; // Flag to prevent duplicate processing
        this.stoppedRecorderCount = 0; // Count of stopped recorders
        
        // PIP Settings
        this.pipSettings = {
            size: 20, // percentage of canvas width/height
            shape: 'square', // 'square' or 'circle'
            x: 0, // x coordinate (will be calculated on first render)
            y: 0, // y coordinate (will be calculated on first render)
            padding: 20 // padding from edges
        };
        
        // PIP Drag & Drop state
        this.pipDragState = {
            isDragging: false,
            startX: 0,
            startY: 0,
            offsetX: 0,
            offsetY: 0
        };
        this.recordingStartTime = null;
        
        // Background Effects Properties
        this.backgroundEffects = {
            enabled: false,
            mode: 'none', // 'none', 'remove', 'blur', 'image'
            blurStrength: 15,
            backgroundImage: null,
            segmentationCanvas: null,
            segmentationCtx: null,
            processedStream: null,
            previousMaskData: null,
            maskInitialized: false,
            maskSmoothing: 0.65,
            confidenceThreshold: 0.6,
            edgeFeather: 0.12,
            maskBlurRadius: 4,
            lastSegmentationResults: null
        };
        
        // MediaPipe Selfie Segmentation
        this.selfieSegmentation = null;
        this.segmentationReady = false;
        this.segmentationFPS = 0;
        this.lastSegmentationTime = performance.now();

        // üöÄ PERFORMANCE OPTIMIERUNGEN f√ºr Segmentation
        this.segmentationOptimization = {
            // Niedrigere Aufl√∂sung f√ºr Masken-Berechnung (Performance!)
            inputWidth: 320,   // Niedrig f√ºr schnelle Masken-Berechnung
            inputHeight: 180,  // 16:9 Verh√§ltnis
            // Downscale Canvas f√ºr Segmentation
            downscaleCanvas: null,
            downscaleCtx: null,
            // GPU-beschleunigter OffscreenCanvas (wenn verf√ºgbar)
            useOffscreenCanvas: typeof OffscreenCanvas !== 'undefined',
            offscreenCanvas: null,
            // MediaPipe Camera f√ºr optimierte Frame-√úbergabe
            mediaCamera: null,
            // Frame-Skipping: Maske seltener berechnen, aber Video immer live
            processEveryNthFrame: 1,  // Jeden Frame verarbeiten
            frameCounter: 0,
            // üöÄ NEU: Gecachte Maske f√ºr kontinuierliches Live-Rendering
            cachedMaskCanvas: null,
            cachedMaskCtx: null,
            lastMaskTime: 0,
            // üöÄ NEU: Live-Rendering Loop (Video immer aktuell!)
            liveRenderActive: false,
            liveRenderFrame: null,
            useLiveVideo: true,  // WICHTIG: Immer aktuelles Video nutzen, nicht MediaPipe-Bild
            // üöÄ NEU: Busy-Flag um MediaPipe nicht zu √ºberlasten
            isProcessing: false
        };
        this.recordingTimer = null;
        this.maxDuration = 180000; // 3 minutes
        this.nextScreenId = 1; // Screen counter for multiple screens
        this.streamDisplayModes = new Map(); // Individual display modes for streams
        this.freeLayoutStreams = new Map(); // Free layout stream positions and sizes
        this.isDragging = false;
        this.isResizing = false;
        this.draggedStream = null;
        this.aspectRatio = '9:16'; // Current aspect ratio - 9:16 f√ºr Social Media
        this.aspectRatioDimensions = { width: 360, height: 640 }; // Canvas dimensions f√ºr 9:16
        this.resizeStream = null;
        this.dragOffset = { x: 0, y: 0 };
        this.resizeHandle = null;
        
        // üöÄ PERFORMANCE OPTIMIZATIONS
        this.videoElements = new Map(); // Video Element Pool
        this.lastRenderTime = 0;
        this.targetFPS = 30;
        this.frameInterval = 1000 / this.targetFPS;
        this.skipFrameCount = 0;
        this.maxSkipFrames = 2;
        this.performanceMetrics = {
            droppedFrames: 0,
            totalFrames: 0,
            averageRenderTime: 0,
            lastFPS: 0
        };

        // üéµ AUDIO SYNC
        this.audioSyncOffset = 0; // Audio offset in milliseconds
        this.audioContext = null; // Web Audio API context
        this.audioDelayNode = null; // Delay node for audio sync
        this.audioSourceNodes = new Map(); // Source nodes for each stream
        this.audioDestination = null; // Destination for combined audio
        this.performanceBuffer = [];
        this.lastFPSUpdate = 0;
        this.enableFrameSkipping = true;
        this.enableErrorRecovery = true;
        this.renderTimeBuffer = [];

        // üöÄ NEW: Fullscreen & UI Features
        this.showGrid = false;
        this.canvasZoom = 1.0;
        this.canvasOffsetX = 0;
        this.canvasOffsetY = 0;
        this.originalCanvasSize = null;

        // Logging control (set true for verbose console output)
        this.debugLogging = false;

        // Recording audio mixing state
        this.recordingAudioContext = null;
        this.recordingAudioDestination = null;
        this.recordingAudioSources = [];

        // Bound event handlers for global pointer tracking
        this.boundGlobalMouseMove = (event) => this.handleMouseMove(event);
        this.boundGlobalMouseUp = (event) => this.handleMouseUp(event);

        this.init();
    }

    setDebugLogging(enabled) {
        this.debugLogging = Boolean(enabled);
    }

    logDebug(...args) {
        if (this.debugLogging) {
            console.log(...args);
        }
    }

    resetMaskCache(reason = 'manual') {
        this.backgroundEffects.previousMaskData = null;
        this.backgroundEffects.maskInitialized = false;
        this.backgroundEffects.maskDimensions = null;
        if (this.backgroundEffects._maskProcessingCanvas && this.backgroundEffects._maskProcessingCtx) {
            const procCanvas = this.backgroundEffects._maskProcessingCanvas;
            this.backgroundEffects._maskProcessingCtx.clearRect(0, 0, procCanvas.width || 0, procCanvas.height || 0);
        }
        delete this.backgroundEffects._lastMaskLog;
        this.backgroundEffects._maskImmediateFrame = true;
        this.logDebug('‚ôªÔ∏è Mask cache reset:', reason);
    }

    init() {
        this.canvas = document.getElementById('compositionCanvas');
        if (!this.canvas) {
            console.error('‚ùå Canvas nicht gefunden');
            return;
        }
        
        this.ctx = this.canvas.getContext('2d');
        this.setupEventListeners();
        this.setupCanvasInteraction();
        this.checkBrowserSupport();
        
        // Initialize status badges
        this.initializeStatusBadges();
        
        // üöÄ Setup fullscreen change listener
        this.setupFullscreenListener();
        this.checkMobileCompatibility(); // Check mobile device limitations
        this.initPerformanceMonitoring();
        this.initStorageStatus(); // Initialize video storage status
        this.loadSettings();
        this.refreshLayoutChips();
        this.updateScreenButtons(); // Initialize button states
        
        // Load available media devices
        this.loadMediaDevices();
        
        // Initialize PIP controls visibility based on default layout
        this.updateLayoutUI(this.currentLayout);
        
        // Initialize aspect ratio preview
        setTimeout(() => {
            const currentRatio = document.getElementById('aspectRatioSetting')?.value || '16:9';
            this.updateAspectRatio(currentRatio);
        }, 100);
        
        console.log('‚úÖ StreamRec Performance Optimized initialisiert');
    }

    initializeStatusBadges() {
        // Initialize both camera and screen status badges to secondary (gray) state
        this.updateStatusBadge('camera', 'secondary');
        this.updateStatusBadge('screen', 'secondary');
        
        // Initialize audio status badge
        this.checkAudioStream();
        
        console.log('üîß Status-Badges initialisiert');
    }

    async loadMediaDevices() {
        try {
            // Request permissions first to get device labels
            let devices = await navigator.mediaDevices.enumerateDevices();
            
            // Check if we need to request permissions to see device labels
            const needsPermission = devices.some(device => 
                (device.kind === 'audioinput' || device.kind === 'videoinput') && !device.label
            );
            
            if (needsPermission) {
                try {
                    // Request permissions temporarily to get device labels
                    const tempStream = await navigator.mediaDevices.getUserMedia({ 
                        audio: true, 
                        video: true 
                    });
                    // Stop tracks immediately
                    tempStream.getTracks().forEach(track => track.stop());
                    // Re-enumerate devices with labels
                    devices = await navigator.mediaDevices.enumerateDevices();
                } catch (err) {
                    console.warn('Permission request for device enumeration failed:', err);
                }
            }
            
            // Load audio input devices (microphones)
            const audioInputs = devices.filter(device => device.kind === 'audioinput');
            const microphoneSelect = document.getElementById('microphoneSelect');
            if (microphoneSelect) {
                microphoneSelect.innerHTML = '<option value="">Standard-Mikrofon</option>';
                
                audioInputs.forEach((device, index) => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.textContent = device.label || `Mikrofon ${index + 1}`;
                    microphoneSelect.appendChild(option);
                });
                
                console.log(`üì¢ ${audioInputs.length} Mikrofon(e) gefunden`);
            }
            
            // Load video input devices (cameras)
            const videoInputs = devices.filter(device => device.kind === 'videoinput');
            const cameraSelect = document.getElementById('cameraSelect');
            if (cameraSelect) {
                cameraSelect.innerHTML = '<option value="">Standard-Kamera</option>';
                
                videoInputs.forEach((device, index) => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.textContent = device.label || `Kamera ${index + 1}`;
                    cameraSelect.appendChild(option);
                });
                
                console.log(`üì∑ ${videoInputs.length} Kamera(s) gefunden`);
            }
            
        } catch (error) {
            console.error('Error loading media devices:', error);
        }
    }

    checkMobileCompatibility() {
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        if (isMobile) {
            // Disable screen sharing buttons on mobile
            const startScreenBtn = document.getElementById('startScreenBtn');
            const addScreenBtn = document.getElementById('addScreenBtn');
            
            if (startScreenBtn) {
                startScreenBtn.disabled = true;
                startScreenBtn.title = 'Bildschirm-Sharing ist auf Mobilger√§ten nicht verf√ºgbar';
                startScreenBtn.innerHTML = '<i class="fas fa-mobile-alt me-2"></i>Nicht verf√ºgbar auf Mobilger√§ten';
            }
            
            if (addScreenBtn) {
                addScreenBtn.disabled = true;
                addScreenBtn.title = 'Bildschirm-Sharing ist auf Mobilger√§ten nicht verf√ºgbar';
            }
            
            console.log('üì± Mobile Kompatibilit√§tspr√ºfung: Bildschirm-Sharing deaktiviert');
        }
    }

    initStorageStatus() {
        // Load storage status on initialization
        this.updateStorageStatus();
        
        // Add refresh button event listener
        const refreshBtn = document.getElementById('refreshStorageBtn');
        if (refreshBtn) {
            refreshBtn.addEventListener('click', () => this.updateStorageStatus());
        }
        
        // Auto-refresh every 5 minutes
        setInterval(() => {
            this.updateStorageStatus();
        }, 5 * 60 * 1000);
    }

    async updateStorageStatus() {
        const usedElement = document.getElementById('storageUsed');
        const tierElement = document.getElementById('storageTier');
        const progressElement = document.getElementById('storageProgress');
        const refreshBtn = document.getElementById('refreshStorageBtn');
        
        try {
            if (refreshBtn) {
                refreshBtn.disabled = true;
                refreshBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i>L√§dt...';
            }
            
            const response = await fetch('/videos/api/storage-status/', {
                method: 'GET',
                headers: {
                    'X-CSRFToken': this.getCSRFToken(),
                    'Content-Type': 'application/json'
                }
            });
            
            if (!response.ok) {
                throw new Error('Fehler beim Laden des Speicherstatus');
            }
            
            const data = await response.json();
            
            if (data.success) {
                const storage = data.storage;
                
                // Update used storage display
                if (usedElement) {
                    usedElement.textContent = `${storage.used_mb.toFixed(1)} / ${storage.max_mb.toFixed(0)} MB`;
                }
                
                // Update tier display
                if (tierElement) {
                    tierElement.textContent = `${storage.tier_name} (${storage.current_price}‚Ç¨/Monat)`;
                }
                
                // Update progress bar
                if (progressElement) {
                    const percentage = storage.used_percentage;
                    progressElement.style.width = `${Math.min(percentage, 100)}%`;
                    
                    // Color coding based on usage
                    progressElement.className = 'progress-bar ' + 
                        (percentage >= 95 ? 'bg-danger' : 
                         percentage >= 80 ? 'bg-warning' : 
                         'bg-info');
                }
                
                // Show restriction warning if applicable
                if (!storage.can_upload && storage.restriction_message) {
                    this.showStorageWarning(storage.restriction_message);
                }
                
            } else {
                throw new Error(data.error || 'Unbekannter Fehler');
            }
            
        } catch (error) {
            console.error('‚ùå Storage Status Fehler:', error);
            
            if (usedElement) usedElement.textContent = 'Fehler';
            if (tierElement) tierElement.textContent = 'Nicht verf√ºgbar';
            if (progressElement) progressElement.style.width = '0%';
            
        } finally {
            if (refreshBtn) {
                refreshBtn.disabled = false;
                refreshBtn.innerHTML = '<i class="fas fa-sync me-1"></i>Aktualisieren';
            }
        }
    }

    showStorageWarning(message) {
        // Check if warning already exists
        if (document.querySelector('.storage-warning')) {
            return;
        }
        
        const warningHtml = `
            <div class="alert alert-warning alert-dismissible fade show storage-warning mb-3" role="alert">
                <h6><i class="fas fa-exclamation-triangle me-2"></i>Speicherplatz-Warnung</h6>
                <p class="mb-2">${message}</p>
                <div class="btn-group btn-group-sm">
                    <a href="/videos/storage/" target="_blank" class="btn btn-outline-primary btn-sm">
                        <i class="fas fa-cog me-1"></i>Speicher verwalten
                    </a>
                    <a href="/videos/" target="_blank" class="btn btn-outline-secondary btn-sm">
                        <i class="fas fa-trash me-1"></i>Videos l√∂schen
                    </a>
                </div>
                <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
            </div>
        `;
        
        // Add warning after the storage status panel
        const storagePanel = document.querySelector('#storageStatus').parentNode;
        storagePanel.insertAdjacentHTML('afterend', warningHtml);
    }

    setupEventListeners() {
        // Camera controls
        document.getElementById('startCameraBtn')?.addEventListener('click', () => this.startCamera());
        document.getElementById('stopCameraBtn')?.addEventListener('click', () => this.stopCamera());

        // Green Screen Toggle
        document.getElementById('greenScreenToggle')?.addEventListener('change', (e) => {
            this.toggleGreenScreen(e.target.checked);
        });

        // Screen controls
        document.getElementById('startScreenBtn')?.addEventListener('click', () => this.startScreen());
        document.getElementById('addScreenBtn')?.addEventListener('click', () => this.addScreen());
        document.getElementById('stopAllScreensBtn')?.addEventListener('click', () => this.stopAllScreens());
        
        // Device change listeners
        navigator.mediaDevices?.addEventListener('devicechange', () => {
            console.log('üì± Ger√§te wurden ge√§ndert - lade neu...');
            this.loadMediaDevices();
        });
        
        // PIP Controls
        this.setupPIPControls();
        
        
        // Recording controls
        document.getElementById('recordBtn')?.addEventListener('click', () => this.startRecordingWithCountdown());
        document.getElementById('stopRecordBtn')?.addEventListener('click', () => this.stopRecording());
        document.getElementById('pauseBtn')?.addEventListener('click', () => this.togglePauseRecording());

        // Output mode controls
        document.querySelectorAll('input[name="outputMode"]').forEach(radio => {
            radio.addEventListener('change', (e) => this.updateOutputMode(e.target.value));
        });

        // Performance controls
        document.getElementById('fpsSelect')?.addEventListener('change', (e) => {
            this.targetFPS = parseInt(e.target.value);
            this.frameInterval = 1000 / this.targetFPS;
        });

        document.getElementById('qualitySelect')?.addEventListener('change', (e) => {
            this.applyQualitySettings(e.target.value);
        });

        document.getElementById('showPerformance')?.addEventListener('change', (e) => {
            this.togglePerformanceMonitor(e.target.checked);
        });

        document.getElementById('aspectRatioSetting')?.addEventListener('change', (e) => {
            this.updateAspectRatio(e.target.value);
            console.log(`üñºÔ∏è Aspect ratio live preview: ${e.target.value}`);
        });

        // Settings
        document.getElementById('saveSettings')?.addEventListener('click', () => this.saveSettings());
        
        // Audio controls
        document.getElementById('audioEnabled')?.addEventListener('change', () => this.checkAudioStream());
        document.getElementById('systemAudio')?.addEventListener('change', () => this.checkAudioStream());

        // Audio Sync Offset
        document.getElementById('audioSyncOffset')?.addEventListener('input', (e) => {
            this.audioSyncOffset = parseInt(e.target.value);
            const display = document.getElementById('audioSyncDisplay');
            if (display) {
                display.textContent = `${this.audioSyncOffset} ms`;
            }
            console.log(`üéµ Audio-Sync-Offset: ${this.audioSyncOffset}ms`);
        });

        // Fullscreen
        document.getElementById('fullscreenBtn')?.addEventListener('click', () => {
            this.toggleCanvasFullscreen();
        });

        // Grid Toggle
        document.getElementById('gridToggle')?.addEventListener('click', () => {
            this.toggleGrid();
        });

        // Zoom Fit
        document.getElementById('zoomFit')?.addEventListener('click', () => {
            this.zoomToFit();
        });

        // Layout Controls (delegierte Events f√ºr beide Bereiche)
        this.setupLayoutEventHandlers();
    }

    setupLayoutEventHandlers() {
        // Event Handler f√ºr Layout-Chips (kleine Buttons)
        document.getElementById('layoutChips')?.addEventListener('click', (e) => {
            const btn = e.target.closest('button[data-layout]');
            if (!btn) return;
            
            e.preventDefault();
            e.stopPropagation();
            const layout = btn.getAttribute('data-layout');
            this.selectLayout(layout);
        });

        // Layout Manager event handler removed - section no longer exists
    }

    updateOutputMode(mode) {
        this.outputMode = mode;
        console.log('üé¨ Output mode changed to:', mode);
        
        // Update the info text
        const infoElement = document.getElementById('outputModeInfo');
        if (infoElement) {
            if (mode === 'merged') {
                infoElement.innerHTML = `
                    <i class="fas fa-info-circle me-2 text-info"></i>
                    <strong>Zusammengef√ºgt:</strong> Ein kombiniertes Video mit allen Streams
                `;
                infoElement.className = 'bg-light border rounded py-2 px-3 small text-muted';
            } else {
                infoElement.innerHTML = `
                    <i class="fas fa-info-circle me-2 text-success"></i>
                    <strong>Einzelne Dateien:</strong> Separate Datei f√ºr jeden Stream (Kamera, Bildschirm, etc.)
                `;
                infoElement.className = 'bg-light border rounded py-2 px-3 small text-muted';
            }
        }
    }

    startSeparateStreamRecording() {
        console.log('üé¨ Starting separate stream recordings...');
        console.log('üìä Available streams:', Array.from(this.streams.keys()));
        console.log('‚úÖ Active streams:', Array.from(this.activeStreams));
        
        try {
            this.processingRecordings = false; // Reset flag before starting
            this.stoppedRecorderCount = 0; // Reset counter
            this.separateRecorders.clear();
            this.separateChunks.clear();
            
            const targetFPS = this.getBrowserOptimalFPS();
            let recordersStarted = 0;
            
            // Debug: Check streams and activeStreams state
            if (this.streams.size === 0) {
                alert('Keine Streams verf√ºgbar. Bitte starten Sie zuerst Ihre Kamera oder Bildschirmfreigabe.');
                return;
            }
            
            // Create separate MediaRecorder for each available stream
            for (const [streamType, stream] of this.streams.entries()) {
                console.log(`üîç Checking stream: ${streamType}, stream exists: ${!!stream}`);
                
                if (stream) {
                    try {
                        console.log(`üìπ Setting up recorder for ${streamType}`);
                        
                        // Get optimal recording options
                        const options = this.getOptimalRecorderOptions();
                        
                        // Fallback for unsupported codecs
                        if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                            options.mimeType = 'video/webm';
                        }
                        
                        const recorder = new MediaRecorder(stream, options);
                        const chunks = [];
                        
                        recorder.ondataavailable = (event) => {
                            if (event.data.size > 0) {
                                chunks.push(event.data);
                            }
                        };
                        
                        recorder.onstop = () => {
                            console.log(`üìπ ${streamType} recording stopped`);
                            const blob = new Blob(chunks, { type: 'video/webm' });
                            this.separateChunks.set(streamType, blob);
                            
                            this.stoppedRecorderCount++;
                            console.log(`üìä Stopped recorders: ${this.stoppedRecorderCount}/${this.separateRecorders.size}`);
                            
                            // Check if all recorders are done
                            if (this.stoppedRecorderCount >= this.separateRecorders.size && !this.processingRecordings) {
                                this.processingRecordings = true;
                                this.processSeparateRecordings();
                            }
                        };
                        
                        this.separateRecorders.set(streamType, recorder);
                        this.separateChunks.set(streamType, chunks);
                        
                        recorder.start();
                        recordersStarted++;
                        console.log(`‚úÖ Started recording for ${streamType}`);
                        
                    } catch (error) {
                        console.error(`‚ùå Failed to start recorder for ${streamType}:`, error);
                    }
                }
            }
            
            if (recordersStarted === 0) {
                console.error('‚ùå No recorders started');
                console.log('üîç Debug Info:');
                console.log('  - Available streams:', this.streams.size);
                console.log('  - Stream types:', Array.from(this.streams.keys()));
                
                let errorMessage = 'Keine Streams zum Aufzeichnen gefunden.\n\n';
                errorMessage += `Verf√ºgbare Streams: ${Array.from(this.streams.keys()).join(', ') || 'Keine'}\n\n`;
                errorMessage += 'M√∂gliche L√∂sungen:\n1. Starten Sie Kamera oder Bildschirmfreigabe\n2. √úberpr√ºfen Sie Browser-Berechtigungen\n3. Versuchen Sie es erneut';
                
                alert(errorMessage);
                return;
            }
            
            // Update UI
            this.isRecording = true;
            this.recordingStartTime = Date.now();
            
            document.getElementById('recordBtn').disabled = true;
            document.getElementById('stopRecordBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = false;
            document.getElementById('recordingStatus').textContent = `Status: ${recordersStarted} Streams werden aufgezeichnet`;
            document.getElementById('recordingIndicator').style.display = 'block';
            
            this.startRecordingTimer();
            console.log(`üé¨ Started recording ${recordersStarted} separate streams`);
            
        } catch (error) {
            console.error('‚ùå Failed to start separate stream recording:', error);
            alert('Fehler beim Starten der getrennten Aufnahme: ' + error.message);
        }
    }
    
    checkAllSeparateRecordingsComplete() {
        // Prevent multiple calls
        if (this.processingRecordings) {
            return;
        }
        
        // Check if all recorders have finished
        let allComplete = true;
        let inactiveCount = 0;
        const totalRecorders = this.separateRecorders.size;
        
        for (const [streamType, recorder] of this.separateRecorders.entries()) {
            if (recorder.state === 'inactive') {
                inactiveCount++;
            } else {
                allComplete = false;
            }
        }
        
        console.log(`üìä Recorder status: ${inactiveCount}/${totalRecorders} inactive`);
        
        if (allComplete && totalRecorders > 0) {
            this.processingRecordings = true;
            this.processSeparateRecordings();
        }
    }
    
    processSeparateRecordings() {
        console.log('üé¨ Processing separate recordings...');

        const separateFiles = [];
        const timestamp = Date.now();

        // Process recorded files (already in correct format from MediaRecorder)
        for (const [streamType, blob] of this.separateChunks.entries()) {
            if (blob instanceof Blob && blob.size > 0) {
                // Determine file extension from blob type
                const blobType = blob.type;
                const fileExtension = blobType.includes('mp4') ? 'mp4' : 'webm';

                const url = URL.createObjectURL(blob);
                separateFiles.push({
                    type: streamType,
                    url: url,
                    blob: blob,
                    filename: `${streamType}-${timestamp}.${fileExtension}`,
                    videoType: blobType
                });
            }
        }

        if (separateFiles.length > 0) {
            this.showSeparateFilesModal(separateFiles);
        } else {
            alert('Keine Aufnahmen erstellt.');
        }

        this.resetRecordingUI();
        this.processingRecordings = false; // Reset flag
    }

    showSeparateFilesModal(files) {
        console.log('üìÅ Showing separate files modal with', files.length, 'files');
        
        const modalHtml = `
            <div class="modal fade" id="separateFilesModal" tabindex="-1" style="z-index: 9999;">
                <div class="modal-dialog modal-lg">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title">
                                <i class="fas fa-copy me-2"></i>Einzelne Stream-Dateien
                            </h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                        </div>
                        <div class="modal-body">
                            <p class="mb-3">
                                <i class="fas fa-info-circle text-info me-2"></i>
                                Es wurden ${files.length} separate Dateien f√ºr Ihre Streams erstellt.
                            </p>
                            
                            <div class="row">
                                ${files.map(file => `
                                    <div class="col-md-6 mb-3">
                                        <div class="card">
                                            <div class="card-body text-center">
                                                <i class="fas fa-video fs-1 text-success mb-2"></i>
                                                <h6 class="card-title">${this.getStreamDisplayName(file.type)}</h6>
                                                <p class="text-muted small">${file.filename}</p>
                                                <a href="${file.url}" download="${file.filename}" class="btn btn-primary btn-sm">
                                                    <i class="fas fa-download me-1"></i>Download
                                                </a>
                                            </div>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Schlie√üen</button>
                            <button type="button" class="btn btn-success" onclick="window.streamRecorder.downloadAllSeparateFiles()">
                                <i class="fas fa-download me-2"></i>Alle herunterladen
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        // Remove existing modal
        const existingModal = document.getElementById('separateFilesModal');
        if (existingModal) existingModal.remove();
        
        // Add to DOM and show
        document.body.insertAdjacentHTML('beforeend', modalHtml);
        const modal = new bootstrap.Modal(document.getElementById('separateFilesModal'));
        modal.show();
        
        // Store files for bulk download
        this.separateFiles = files;
    }

    getStreamDisplayName(streamType) {
        const names = {
            'camera': 'Kamera',
            'screen': 'Bildschirm',
            'screen_1': 'Bildschirm 1',
            'screen_2': 'Bildschirm 2',
            'audio': 'Audio'
        };
        return names[streamType] || streamType.charAt(0).toUpperCase() + streamType.slice(1);
    }

    downloadAllSeparateFiles() {
        if (!this.separateFiles) return;
        
        this.separateFiles.forEach(file => {
            const a = document.createElement('a');
            a.href = file.url;
            a.download = file.filename;
            a.style.display = 'none';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        });
        
        // Close modal
        const modal = bootstrap.Modal.getInstance(document.getElementById('separateFilesModal'));
        if (modal) modal.hide();
    }

    selectLayout(layout) {
        console.log(`üéØ Layout ausgew√§hlt: ${layout}`);
        
        // Layout anwenden
        this.applyLayout(layout);
        
        // Rendering starten falls nicht aktiv
        if (!this.isComposing) {
            this.startRenderLoop();
        }
        
        // UI aktualisieren
        this.updateLayoutUI(layout);
    }

    updateLayoutUI(layout) {
        // WICHTIG: Komplett neu rendern statt Klassen zu manipulieren
        // Das verhindert CSS-Klassen-Konflikte bei den Layout Cards
        
        // Show/hide PIP controls based on layout
        const pipControls = document.getElementById('pipControls');
        if (pipControls) {
            pipControls.style.display = (layout === 'pip') ? 'block' : 'none';
        }
        
        // Aktuelle Stream-Anzahl ermitteln
        const count = this.streams.size;
        const layouts = this.getAvailableLayouts(count);
        
        // Neu rendern mit korrektem aktuellen Layout
        this.refreshLayoutChips();
        
        console.log(`üé® Layout UI komplett neu gerendert f√ºr: ${layout}`);
    }
    
    setupPIPControls() {
        console.log('üîß Setting up PIP controls...');
        
        // PIP Size Control
        const pipSizeSlider = document.getElementById('pipSize');
        const pipSizeValue = document.getElementById('pipSizeValue');
        
        console.log('üéõÔ∏è PIP Size slider found:', !!pipSizeSlider);
        
        if (pipSizeSlider) {
            pipSizeSlider.addEventListener('input', (e) => {
                this.pipSettings.size = parseInt(e.target.value);
                if (pipSizeValue) pipSizeValue.textContent = `${this.pipSettings.size}%`;
                
                console.log(`üîß PIP Size changed to: ${this.pipSettings.size}%`);
                console.log(`üé¨ Current layout: ${this.currentLayout}, Is composing: ${this.isComposing}`);
                
                if (this.isComposing && this.currentLayout === 'pip') {
                    console.log('üîÑ Triggering render update...');
                    this.renderCurrentLayout();
                }
            });
            console.log('‚úÖ PIP size listener added');
        }
        
        // PIP Shape Toggle
        const shapeRadios = document.querySelectorAll('input[name="pipShape"]');
        console.log('üîò PIP Shape radios found:', shapeRadios.length);
        
        shapeRadios.forEach((radio, index) => {
            console.log(`üìª Adding listener to radio ${index}: ${radio.value}`);
            radio.addEventListener('change', (e) => {
                this.pipSettings.shape = e.target.value;
                console.log(`üîß PIP Shape changed to: ${this.pipSettings.shape}`);
                
                if (this.isComposing && this.currentLayout === 'pip') {
                    console.log('üîÑ Triggering render update for shape...');
                    this.renderCurrentLayout();
                }
            });
        });
        
        // Setup PIP Drag & Drop for canvas
        this.setupPIPDragAndDrop();
        
        console.log('‚úÖ PIP controls setup complete');
        console.log('üéõÔ∏è Initial PIP settings:', this.pipSettings);
    }

    setupPIPDragAndDrop() {
        // Only setup drag and drop for PIP mode
        if (!this.canvas) return;
        
        // Initialize PIP position if not set yet
        this.initializePIPPosition();
        
        // Mouse down event for starting drag
        this.canvas.addEventListener('mousedown', (e) => {
            console.log(`üñ±Ô∏è Mouse down - Layout: ${this.currentLayout}, Composing: ${this.isComposing}`);
            if (this.currentLayout !== 'pip' || !this.isComposing) return;

            const coords = this.getCanvasCoordinates(e);
            console.log(`üñ±Ô∏è Mouse coordinates (scaled): ${coords.x}, ${coords.y}`);
            console.log(`üñ±Ô∏è PIP position: ${this.pipSettings.x}, ${this.pipSettings.y}`);

            // Check if click is within PIP area
            const hitTest = this.isPIPHitTest(coords.x, coords.y);
            console.log(`üéØ PIP hit test result: ${hitTest}`);

            if (hitTest) {
                this.pipDragState.isDragging = true;
                // Store original positions for delta calculation
                this.pipDragState.startMouseX = e.clientX;
                this.pipDragState.startMouseY = e.clientY;
                this.pipDragState.startPIPX = this.pipSettings.x;
                this.pipDragState.startPIPY = this.pipSettings.y;
                this.canvas.style.cursor = 'grabbing';
                console.log('üéØ PIP drag started');
                e.preventDefault();
            }
        });
        
        // Mouse move event for dragging
        this.canvas.addEventListener('mousemove', (e) => {
            if (this.currentLayout !== 'pip' || !this.isComposing) return;

            if (this.pipDragState.isDragging) {
                // Calculate mouse movement delta in screen coordinates
                const deltaScreenX = e.clientX - this.pipDragState.startMouseX;
                const deltaScreenY = e.clientY - this.pipDragState.startMouseY;

                // Convert delta to canvas coordinates
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;

                const deltaCanvasX = deltaScreenX * scaleX;
                const deltaCanvasY = deltaScreenY * scaleY;

                // Calculate new position
                const newX = this.pipDragState.startPIPX + deltaCanvasX;
                const newY = this.pipDragState.startPIPY + deltaCanvasY;

                // Get PIP dimensions
                const sizePercentage = this.pipSettings.size / 100;
                const pipWidth = this.canvas.width * sizePercentage;
                const pipHeight = this.canvas.height * sizePercentage;

                // Constrain to canvas bounds
                this.pipSettings.x = Math.max(0, Math.min(this.canvas.width - pipWidth, newX));
                this.pipSettings.y = Math.max(0, Math.min(this.canvas.height - pipHeight, newY));

                // Trigger re-render
                this.renderCurrentLayout();

            } else {
                // Change cursor when hovering over PIP area
                const coords = this.getCanvasCoordinates(e);
                if (this.isPIPHitTest(coords.x, coords.y)) {
                    this.canvas.style.cursor = 'grab';
                } else {
                    this.canvas.style.cursor = 'default';
                }
            }
        });
        
        // Mouse up event for ending drag
        this.canvas.addEventListener('mouseup', (e) => {
            if (this.pipDragState.isDragging) {
                this.pipDragState.isDragging = false;
                this.canvas.style.cursor = 'default';
                console.log(`üéØ PIP drag ended at: ${this.pipSettings.x}, ${this.pipSettings.y}`);
            }
        });
        
        // Mouse leave event to stop drag if mouse leaves canvas
        this.canvas.addEventListener('mouseleave', (e) => {
            if (this.pipDragState.isDragging) {
                this.pipDragState.isDragging = false;
                this.canvas.style.cursor = 'default';
                console.log('üéØ PIP drag cancelled (mouse left canvas)');
            }
        });
        
        console.log('‚úÖ PIP Drag & Drop setup complete');
    }
    
    getCanvasCoordinates(e) {
        // Convert mouse coordinates to canvas coordinates, accounting for scaling
        const rect = this.canvas.getBoundingClientRect();
        const scaleX = this.canvas.width / rect.width;
        const scaleY = this.canvas.height / rect.height;
        
        return {
            x: (e.clientX - rect.left) * scaleX,
            y: (e.clientY - rect.top) * scaleY
        };
    }
    
    initializePIPPosition() {
        // Initialize PIP position if canvas is available and position not set
        if (this.canvas && this.pipSettings.x === 0 && this.pipSettings.y === 0) {
            const sizePercentage = this.pipSettings.size / 100;
            const pipWidth = this.canvas.width * sizePercentage;
            const pipHeight = this.canvas.height * sizePercentage;
            
            // Default position: top-right corner with padding, but ensure it fits on screen
            const maxX = this.canvas.width - pipWidth - this.pipSettings.padding;
            const maxY = this.canvas.height - pipHeight - this.pipSettings.padding;
            
            this.pipSettings.x = Math.max(this.pipSettings.padding, maxX);
            this.pipSettings.y = this.pipSettings.padding;
            
            console.log(`üéØ PIP position initialized: x=${this.pipSettings.x}, y=${this.pipSettings.y}`);
            console.log(`üñºÔ∏è Canvas dimensions: ${this.canvas.width}x${this.canvas.height}`);
            console.log(`üìê PIP dimensions: ${pipWidth}x${pipHeight}`);
            console.log(`üìç Max position: ${maxX}, ${maxY}`);
        }
    }
    
    isPIPHitTest(mouseX, mouseY) {
        // Check if mouse position is within PIP area
        const sizePercentage = this.pipSettings.size / 100;
        const pipWidth = this.canvas.width * sizePercentage;
        const pipHeight = this.canvas.height * sizePercentage;
        
        return (mouseX >= this.pipSettings.x && 
                mouseX <= this.pipSettings.x + pipWidth &&
                mouseY >= this.pipSettings.y && 
                mouseY <= this.pipSettings.y + pipHeight);
    }
    
    setupBackgroundEffects() {
        console.log('üé® Setting up background effects...');
        
        // Enable/disable effects
        const enableSwitch = document.getElementById('enableBackgroundEffects');
        if (enableSwitch) {
            enableSwitch.addEventListener('change', (e) => {
                this.backgroundEffects.enabled = e.target.checked;
                document.getElementById('backgroundEffectOptions').style.display = e.target.checked ? 'block' : 'none';
                
                if (e.target.checked) {
                    // Check if camera is ready first
                    if (this.streams.has('camera')) {
                        const cameraVideo = this.getRawVideoElement('camera');
                        if (cameraVideo && cameraVideo.readyState >= 2) {
                            console.log('‚úÖ Camera is ready, starting background effects');
                            this.createSegmentationCanvas();
                            this.initializeSegmentation();
                        } else {
                            console.log('‚è≥ Camera not ready, waiting...');
                            // Wait for camera to be ready
                            this.waitForCameraAndStartEffects();
                        }
                    } else {
                        console.log('‚ùå No camera stream available');
                        this.updateSegmentationStatus('Fehler: Keine Kamera');
                        e.target.checked = false;
                    }
                } else {
                    this.disableBackgroundEffects();
                }
            });
        }
        
        // Effect mode selection
        document.querySelectorAll('input[name="bgEffect"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                const selectedValue = e.target.value;
                this.backgroundEffects.mode = selectedValue;
                this.updateEffectControls(selectedValue);
                
                // Auto-enable/disable effects based on selection
                const enableSwitch = document.getElementById('enableBackgroundEffects');
                const effectsActiveBadge = document.getElementById('effectsActiveBadge');
                
                if (selectedValue === 'none') {
                    // Disable effects when "Aus" is selected
                    if (this.backgroundEffects.enabled) {
                        console.log('üîÑ Disabling background effects (None selected)');
                        enableSwitch.checked = false;
                        this.backgroundEffects.enabled = false;
                        this.backgroundEffects.mode = 'none';
                        this.applySimpleEffect('none'); // Remove all CSS effects
                        effectsActiveBadge.style.display = 'none';
                    }
                } else {
                    // Enable effects with MediaPipe-based approach
                    if (!this.backgroundEffects.enabled) {
                        console.log('üéÜ Enabling background effects (MediaPipe mode) for:', selectedValue);
                        enableSwitch.checked = true;
                        this.backgroundEffects.enabled = true;
                        this.backgroundEffects.mode = selectedValue;
                        
                        // Start MediaPipe segmentation
                        this.createSegmentationCanvas();
                        this.initializeSegmentation();
                        effectsActiveBadge.style.display = 'inline';
                    } else {
                        // Just change mode
                        console.log('üîÑ Changing effect mode to:', selectedValue);
                        this.backgroundEffects.mode = selectedValue;
                        
                        // If MediaPipe is running, it will pick up the new mode
                        // Otherwise fall back to simple effect
                        if (!this.backgroundEffects.segmentationActive) {
                            this.applySimpleEffect(selectedValue);
                        }
                    }
                }
            });
        });
        
        // Blur strength slider
        const blurSlider = document.getElementById('blurStrength');
        if (blurSlider) {
            blurSlider.addEventListener('input', (e) => {
                this.backgroundEffects.blurStrength = parseInt(e.target.value);
                document.getElementById('blurStrengthValue').textContent = e.target.value;
            });
        }
        
        // Background image upload
        const imageUpload = document.getElementById('backgroundImageUpload');
        if (imageUpload) {
            imageUpload.addEventListener('change', (e) => {
                this.handleBackgroundImageUpload(e);
            });
        }
        
        // Test button - now auto-enables background effects
        const testButton = document.getElementById('testBackgroundEffects');
        if (testButton) {
            testButton.addEventListener('click', () => {
                console.log('üß™ Test button clicked');
                
                // Auto-enable effects and set to test mode
                const enableSwitch = document.getElementById('enableBackgroundEffects');
                const effectsActiveBadge = document.getElementById('effectsActiveBadge');
                
                this.backgroundEffects.mode = 'test';
                this.updateSegmentationStatus('Test-Modus aktiv');
                
                if (!this.backgroundEffects.enabled) {
                    console.log('üîÑ Auto-enabling background effects for test mode');
                    enableSwitch.checked = true;
                    this.backgroundEffects.enabled = true;
                    
                    // Trigger the enable logic
                    if (this.streams.has('camera')) {
                        const cameraVideo = this.getRawVideoElement('camera');
                        if (cameraVideo && cameraVideo.readyState >= 2) {
                            console.log('‚úÖ Camera is ready, starting background effects for test');
                            this.createSegmentationCanvas();
                            this.initializeSegmentation();
                            effectsActiveBadge.style.display = 'inline';
                        } else {
                            console.log('‚è≥ Camera not ready, waiting for test mode...');
                            this.waitForCameraAndStartEffects();
                            effectsActiveBadge.style.display = 'inline';
                        }
                    }
                }
                
                // Draw test pattern immediately if canvas is available
                setTimeout(() => {
                    if (this.backgroundEffects.segmentationCanvas) {
                        const ctx = this.backgroundEffects.segmentationCtx;
                        ctx.fillStyle = '#ff0000';
                        ctx.fillRect(0, 0, ctx.canvas.width/2, ctx.canvas.height);
                        ctx.fillStyle = '#00ff00';
                        ctx.fillRect(ctx.canvas.width/2, 0, ctx.canvas.width/2, ctx.canvas.height);
                        console.log('‚úÖ Drew test pattern directly to canvas');
                    }
                }, 200);
            });
        }
        
        console.log('‚úÖ Background effects setup complete');
    }
    
    createSegmentationCanvas() {
        console.log('üé® Creating segmentation canvas...');
        
        try {
            // Create canvas if it doesn't exist
            if (!this.backgroundEffects.segmentationCanvas) {
                this.backgroundEffects.segmentationCanvas = document.createElement('canvas');
                this.backgroundEffects.segmentationCtx = this.backgroundEffects.segmentationCanvas.getContext('2d', { willReadFrequently: true });
                
                // Set canvas size to match video dimensions (default to 640x480 initially)
                this.backgroundEffects.segmentationCanvas.width = 640;
                this.backgroundEffects.segmentationCanvas.height = 480;
                
                console.log('üìê Segmentation canvas created:', {
                    width: this.backgroundEffects.segmentationCanvas.width,
                    height: this.backgroundEffects.segmentationCanvas.height
                });
            }
            
            // Update canvas size if camera stream exists
            if (this.streams.has('camera')) {
                const videoElement = this.getRawVideoElement('camera');
                if (videoElement) {
                    // Wait for video metadata if not ready
                    if (videoElement.videoWidth > 0 && videoElement.videoHeight > 0) {
                        this.backgroundEffects.segmentationCanvas.width = videoElement.videoWidth;
                        this.backgroundEffects.segmentationCanvas.height = videoElement.videoHeight;
                        console.log('üìê Updated segmentation canvas size from video:', {
                            width: this.backgroundEffects.segmentationCanvas.width,
                            height: this.backgroundEffects.segmentationCanvas.height
                        });
                    } else {
                        console.log('‚è≥ Waiting for video metadata to set canvas size...');
                        videoElement.addEventListener('loadedmetadata', () => {
                            this.backgroundEffects.segmentationCanvas.width = videoElement.videoWidth || 640;
                            this.backgroundEffects.segmentationCanvas.height = videoElement.videoHeight || 480;
                            console.log('üìê Updated canvas size after metadata:', {
                                width: this.backgroundEffects.segmentationCanvas.width,
                                height: this.backgroundEffects.segmentationCanvas.height
                            });
                        }, { once: true });
                    }
                }
                // WICHTIG: KEIN fallback drawing hier!
                // Das normale Video soll weiter laufen
            }

            // WICHTIG: KEINE Test-Pattern zeichnen!
            // Canvas bleibt leer bis MediaPipe es f√ºllt
            
            console.log('‚úÖ Segmentation canvas created successfully');
            
            // DON'T start drawing immediately - wait for MediaPipe
            // this.drawEffectWithoutSegmentation(this.backgroundEffects.mode || 'none');
            
            // Don't start canvas stream automatically - wait for user to enable effects
            console.log('üé® Segmentation canvas ready, waiting for user to enable effects');
            
        } catch (error) {
            console.error('‚ùå Failed to create segmentation canvas:', error);
        }
    }

    // üöÄ PERFORMANCE OPTIMIERUNG: Initialisiere Downscale-Canvas f√ºr schnellere Verarbeitung
    initializeOptimizationCanvases() {
        const opt = this.segmentationOptimization;

        // Downscale Canvas f√ºr niedrigere Eingabe-Aufl√∂sung
        if (!opt.downscaleCanvas) {
            if (opt.useOffscreenCanvas) {
                // GPU-beschleunigter OffscreenCanvas (wenn verf√ºgbar)
                try {
                    opt.downscaleCanvas = new OffscreenCanvas(opt.inputWidth, opt.inputHeight);
                    opt.downscaleCtx = opt.downscaleCanvas.getContext('2d', {
                        alpha: false,
                        desynchronized: true,  // Erm√∂glicht schnelleres Rendering
                        willReadFrequently: false
                    });
                    console.log('üöÄ OffscreenCanvas f√ºr GPU-Beschleunigung aktiviert');
                } catch (e) {
                    console.warn('‚ö†Ô∏è OffscreenCanvas nicht verf√ºgbar, nutze normalen Canvas');
                    opt.useOffscreenCanvas = false;
                }
            }

            if (!opt.useOffscreenCanvas) {
                // Fallback: Normaler Canvas
                opt.downscaleCanvas = document.createElement('canvas');
                opt.downscaleCanvas.width = opt.inputWidth;
                opt.downscaleCanvas.height = opt.inputHeight;
                opt.downscaleCtx = opt.downscaleCanvas.getContext('2d', {
                    alpha: false,
                    willReadFrequently: false
                });
            }

            console.log(`üìê Downscale Canvas erstellt: ${opt.inputWidth}x${opt.inputHeight}`);
        }
    }

    // üöÄ PERFORMANCE: Skaliere Video-Frame auf niedrige Aufl√∂sung f√ºr Segmentation
    getOptimizedFrameForSegmentation(videoElement) {
        const opt = this.segmentationOptimization;

        if (!opt.downscaleCanvas || !opt.downscaleCtx) {
            return videoElement; // Fallback: Original-Video
        }

        // Frame-Skipping: Nur jeden N-ten Frame verarbeiten
        opt.frameCounter++;
        if (opt.frameCounter % opt.processEveryNthFrame !== 0) {
            // Gib cached Canvas zur√ºck wenn vorhanden
            if (opt.cachedMask) {
                return null; // Signal: Nutze gecachte Maske
            }
            return videoElement;
        }

        // Zeichne Video auf niedrigaufl√∂senden Canvas
        opt.downscaleCtx.drawImage(
            videoElement,
            0, 0,
            opt.inputWidth, opt.inputHeight
        );

        return opt.downscaleCanvas;
    }

    // üöÄ PERFORMANCE: Async Frame-Optimierung mit ImageBitmap (GPU-beschleunigt)
    async getOptimizedFrameAsync(videoElement) {
        const opt = this.segmentationOptimization;

        // Frame-Skipping Check
        opt.frameCounter++;
        if (opt.frameCounter % opt.processEveryNthFrame !== 0) {
            return null; // √úberspringe diesen Frame
        }

        try {
            // createImageBitmap ist GPU-beschleunigt und non-blocking
            const bitmap = await createImageBitmap(
                videoElement,
                {
                    resizeWidth: opt.inputWidth,
                    resizeHeight: opt.inputHeight,
                    resizeQuality: 'low' // 'low' f√ºr maximale Performance
                }
            );
            return bitmap;
        } catch (e) {
            // Fallback auf synchrone Methode
            return this.getOptimizedFrameForSegmentation(videoElement);
        }
    }

    // üöÄ PERFORMANCE: Nutze requestIdleCallback f√ºr nicht-kritische Updates
    scheduleIdleTask(callback, timeout = 50) {
        if ('requestIdleCallback' in window) {
            return requestIdleCallback(callback, { timeout });
        } else {
            // Fallback f√ºr Safari
            return setTimeout(callback, 1);
        }
    }

    startFallbackDrawing() {
        // DEAKTIVIERT: Diese Funktion verursacht das wei√üe Canvas Problem
        console.log('‚ö†Ô∏è startFallbackDrawing wurde aufgerufen aber ist deaktiviert');
        return; // Sofort beenden

        const drawFallback = () => {
            if (!this.backgroundEffects.enabled || !this.backgroundEffects.segmentationCanvas) {
                return;
            }
            
            const canvas = this.backgroundEffects.segmentationCanvas;
            const ctx = this.backgroundEffects.segmentationCtx;
            
            // Try to draw actual camera video if available
            if (this.backgroundEffects.originalCameraStream || this.streams.has('camera')) {
                const videoElement = this.getRawVideoElement('camera');
                if (videoElement && videoElement.readyState >= 2) {
                    // Update canvas size to match video
                    if (videoElement.videoWidth > 0 && videoElement.videoHeight > 0) {
                        canvas.width = videoElement.videoWidth;
                        canvas.height = videoElement.videoHeight;
                    }
                    
                    // Clear and draw the video
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
                    
                    console.log('‚úÖ Drew camera video to fallback canvas');
                } else {
                    // Draw a test pattern if video not ready
                    ctx.fillStyle = '#FF6B6B';
                    ctx.fillRect(0, 0, canvas.width/3, canvas.height);
                    ctx.fillStyle = '#4ECDC4';
                    ctx.fillRect(canvas.width/3, 0, canvas.width/3, canvas.height);
                    ctx.fillStyle = '#45B7D1';
                    ctx.fillRect((canvas.width/3)*2, 0, canvas.width/3, canvas.height);
                    
                    // Add text
                    ctx.fillStyle = 'white';
                    ctx.font = '20px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('Background Effects Active', canvas.width/2, canvas.height/2);
                    ctx.fillText('Camera Loading...', canvas.width/2, canvas.height/2 + 30);
                }
            }
            
            // Continue the loop
            if (this.backgroundEffects.enabled) {
                requestAnimationFrame(drawFallback);
            }
        };
        
        // Start the drawing loop
        drawFallback();
    }
    
    drawEffectWithoutSegmentation(mode) {
        console.log(`üéØ Drawing effect without segmentation: ${mode}`);
        
        if (!this.backgroundEffects.segmentationCanvas || !this.backgroundEffects.segmentationCtx) {
            console.error('‚ùå No canvas available');
            return;
        }
        
        const canvas = this.backgroundEffects.segmentationCanvas;
        const ctx = this.backgroundEffects.segmentationCtx;
        
        // Get the correct video element for drawing
        let videoElement = null;
        
        // Always try to create/use a source element for the original stream
        if (this.backgroundEffects.originalCameraStream) {
            if (!this.backgroundEffects.sourceVideoElement) {
                // Create source video element for original stream
                this.backgroundEffects.sourceVideoElement = document.createElement('video');
                this.backgroundEffects.sourceVideoElement.autoplay = true;
                this.backgroundEffects.sourceVideoElement.playsInline = true;
                this.backgroundEffects.sourceVideoElement.muted = true;
                this.backgroundEffects.sourceVideoElement.srcObject = this.backgroundEffects.originalCameraStream;
                
                // Add to DOM but hide it
                this.backgroundEffects.sourceVideoElement.style.display = 'none';
                document.body.appendChild(this.backgroundEffects.sourceVideoElement);
                
                console.log('üìπ Created and added source video element to DOM');
            }
            videoElement = this.backgroundEffects.sourceVideoElement;
        } else {
            // Fallback: Use the current camera video element
            videoElement = document.getElementById('video-camera') || this.getRawVideoElement('camera');
            console.log('‚ö†Ô∏è Using fallback video element');
        }
        
        if (!videoElement) {
            console.log('‚ùå No video element available');
            return;
        }
        
        if (videoElement.readyState < 2) {
            console.log('‚è≥ Video not ready, waiting...');
            videoElement.addEventListener('loadeddata', () => {
                this.drawEffectWithoutSegmentation(mode);
            }, { once: true });
            return;
        }
        
        // Cancel any existing animation frame
        if (this.backgroundEffects.animationFrame) {
            cancelAnimationFrame(this.backgroundEffects.animationFrame);
        }
        
        // Start continuous drawing loop
        const draw = () => {
            if (!this.backgroundEffects.enabled || this.backgroundEffects.mode === 'none') {
                console.log('üîÑ Stopping drawing loop - effects disabled');
                return;
            }
            
            // Stop fallback if MediaPipe is working
            if (this.backgroundEffects.mediapipeWorking) {
                console.log('üîÑ Stopping fallback drawing - MediaPipe is working');
                return;
            }
            
            try {
                // Update canvas size to match video if needed
                if (videoElement.videoWidth > 0 && videoElement.videoHeight > 0) {
                    if (canvas.width !== videoElement.videoWidth || canvas.height !== videoElement.videoHeight) {
                        canvas.width = videoElement.videoWidth;
                        canvas.height = videoElement.videoHeight;
                        console.log('üìê Updated canvas size:', canvas.width, 'x', canvas.height);
                    }
                }
                
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                switch (mode) {
                case 'remove':
                    // Draw white background
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw the video normally in the center (simulate person)
                    const removeScale = 0.8;
                    const removeW = canvas.width * removeScale;
                    const removeH = canvas.height * removeScale;
                    const removeX = (canvas.width - removeW) / 2;
                    const removeY = (canvas.height - removeH) / 2;
                    
                    ctx.drawImage(videoElement, removeX, removeY, removeW, removeH);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.fillRect(10, canvas.height - 50, 300, 30);
                    ctx.fillStyle = 'black';
                    ctx.font = '14px Arial';
                    ctx.fillText('Hintergrund-Entfernung (vereinfacht)', 15, canvas.height - 30);
                    break;
                    
                case 'blur':
                    // First draw the blurred background
                    ctx.save();
                    ctx.filter = `blur(${this.backgroundEffects.blurStrength || 15}px)`;
                    ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
                    ctx.restore();
                    
                    // Now draw a clear center area (simulated person)
                    const centerW = canvas.width * 0.5;
                    const centerH = canvas.height * 0.7;
                    const personX = (canvas.width - centerW) / 2;
                    const personY = (canvas.height - centerH) / 2;
                    
                    // Draw oval mask for person area
                    ctx.save();
                    ctx.beginPath();
                    ctx.ellipse(
                        canvas.width / 2,      // center x
                        canvas.height / 2,     // center y  
                        centerW / 2,           // radius x
                        centerH / 2,           // radius y
                        0, 0, 2 * Math.PI      // angles
                    );
                    ctx.clip();
                    
                    // Draw clear video in clipped area
                    ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
                    ctx.restore();
                    break;
                    
                case 'image':
                    // Draw background image if available, otherwise solid color
                    if (this.backgroundEffects.backgroundImage) {
                        ctx.drawImage(this.backgroundEffects.backgroundImage, 0, 0, canvas.width, canvas.height);
                    } else {
                        ctx.fillStyle = '#4CAF50';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    }
                    
                    // Draw person in center (simplified)
                    const personW2 = canvas.width * 0.5;
                    const personH2 = canvas.height * 0.7;
                    const personX2 = (canvas.width - personW2) / 2;
                    const personY2 = (canvas.height - personH2) / 2;
                    
                    ctx.drawImage(videoElement,
                        personX2, personY2, personW2, personH2,  // source 
                        personX2, personY2, personW2, personH2   // dest
                    );
                    break;
                    
                case 'test':
                    // Test mode - show video with colored overlay
                    // First draw the video
                    ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
                    
                    // Add semi-transparent colored overlay
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                    ctx.fillRect(0, 0, canvas.width/2, canvas.height);
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.3)'; 
                    ctx.fillRect(canvas.width/2, 0, canvas.width/2, canvas.height);
                    
                    // Add text to show it's working
                    ctx.fillStyle = 'white';
                    ctx.font = '20px Arial';
                    ctx.fillText('Test Mode Active', 10, 30);
                    break;
                    
                default:
                    // Just draw the video normally
                    ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
                    break;
            }
            
            // Log successful draw for debugging
            if (this.backgroundEffects.debugMode) {
                console.log(`‚úÖ Drew frame with effect: ${mode}`);
            }
            
                // Trigger canvas stream update after drawing
                if (this.backgroundEffects.canvasStream) {
                    const tracks = this.backgroundEffects.canvasStream.getVideoTracks();
                    if (tracks.length > 0 && tracks[0].readyState === 'live') {
                        // Stream is active, no action needed
                    }
                }
                
            } catch (error) {
                console.error('‚ùå Failed to draw effect without segmentation:', error);
                // Fallback to normal video
                ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
            }
            
            // Continue animation loop if effects are still enabled
            if (this.backgroundEffects.enabled && this.backgroundEffects.mode !== 'none') {
                this.backgroundEffects.animationFrame = requestAnimationFrame(draw);
            }
        };
        
        // Start the drawing loop
        draw();
        console.log('‚úÖ Started continuous drawing for effect:', mode);
        
        // Also update the main video element to show the canvas
        const mainVideoElement = document.getElementById('video-camera');
        if (mainVideoElement && this.backgroundEffects.canvasStream) {
            mainVideoElement.srcObject = this.backgroundEffects.canvasStream;
            console.log('üì∫ Updated main video element with canvas stream');
        }
    }
    
    startContinuousCanvasDrawing() {
        console.log('üé¨ Starting continuous canvas drawing loop...');
        
        let lastMediaPipeUpdate = Date.now();
        
        const drawLoop = () => {
            if (!this.backgroundEffects.enabled || !this.backgroundEffects.segmentationCanvas) {
                return;
            }
            
            // Check if MediaPipe is working (updated recently)
            const timeSinceLastUpdate = Date.now() - lastMediaPipeUpdate;
            
            // If MediaPipe hasn't updated in more than 500ms, use fallback
            if (timeSinceLastUpdate > 500) {
                // Check if we're not in test mode (test mode should always work)
                if (this.backgroundEffects.mode !== 'test') {
                    this.drawDirectVideoToCanvas();
                }
            }
            
            // Update timestamp when MediaPipe is working
            if (this.segmentationReady && this.streams.has('camera')) {
                lastMediaPipeUpdate = Date.now();
            }
            
            // Continue the loop
            if (this.backgroundEffects.enabled) {
                setTimeout(drawLoop, 33); // ~30 FPS
            }
        };
        
        // Start the loop
        drawLoop();
    }
    
    getRawVideoElement(type) {
        // Get raw video element without background effects logic
        // Used internally to avoid circular dependencies
        
        // 1. Check pool first
        if (this.videoElements.has(type)) {
            return this.videoElements.get(type);
        }
        
        // 2. Check DOM
        const video = document.getElementById(`video-${type}`);
        if (video) {
            this.videoElements.set(type, video);
            return video;
        }
        
        return null;
    }
    
    waitForCameraAndStartEffects() {
        console.log('‚è≥ Waiting for camera to be ready...');
        this.updateSegmentationStatus('Warte auf Kamera...');
        
        let attempts = 0;
        const maxAttempts = 50; // 5 seconds max
        
        const checkCamera = () => {
            attempts++;
            
            if (!this.backgroundEffects.enabled) {
                // User turned off effects while waiting
                console.log('‚ùå Background effects disabled while waiting');
                return;
            }
            
            if (attempts > maxAttempts) {
                console.log('‚ùå Camera wait timeout');
                this.updateSegmentationStatus('Fehler: Kamera-Timeout');
                const enableSwitch = document.getElementById('enableBackgroundEffects');
                if (enableSwitch) enableSwitch.checked = false;
                this.backgroundEffects.enabled = false;
                return;
            }
            
            const cameraVideo = this.getRawVideoElement('camera');
            if (cameraVideo && cameraVideo.readyState >= 2) {
                console.log('‚úÖ Camera ready after waiting, starting effects');
                this.createSegmentationCanvas();
                this.initializeSegmentation();
            } else {
                console.log(`‚è≥ Still waiting for camera... (attempt ${attempts}/${maxAttempts})`);
                setTimeout(checkCamera, 100);
            }
        };
        
        checkCamera();
    }
    
    getOrCreateSegmentationVideoElement() {
        console.log('üé¨ Creating/getting segmentation video element...');
        
        // Check if we already have a segmentation video element
        let segVideo = document.getElementById('video-segmentation');
        
        if (!segVideo) {
            console.log('üé¨ Creating new segmentation video element');
            segVideo = document.createElement('video');
            segVideo.id = 'video-segmentation';
            segVideo.autoplay = true;
            segVideo.muted = true;
            segVideo.playsInline = true;
            segVideo.style.display = 'none';
            segVideo.style.position = 'absolute';
            segVideo.style.top = '-9999px';
            document.body.appendChild(segVideo);
        }
        
        // Create stream from canvas if not already done
        if (!segVideo.srcObject && this.backgroundEffects.segmentationCanvas) {
            try {
                console.log('üé¨ Creating canvas stream...');
                
                // Create stream from canvas with 30 FPS
                const canvasStream = this.backgroundEffects.segmentationCanvas.captureStream(30);
                segVideo.srcObject = canvasStream;
                
                // Store reference to the stream for later use
                this.backgroundEffects.canvasStream = canvasStream;
                
                console.log('‚úÖ Canvas stream created and assigned to video element');
                
                // Start playback
                segVideo.play().catch(err => {
                    console.error('‚ùå Failed to play segmentation video:', err);
                });
                
            } catch (error) {
                console.error('‚ùå Failed to create canvas stream:', error);
                
                // Even if canvas stream creation fails, return the video element
                // The rendering system expects a video element, not a canvas
            }
        }
        
        // Return the video element if it's ready, otherwise setup ready callback
        if (segVideo.readyState >= 2) {
            console.log('‚úÖ Returning ready segmentation video element');
            return segVideo;
        } else {
            console.log('üîÑ Video not ready yet, setting up ready callback');
            
            // Set up event listener for when video is ready
            segVideo.addEventListener('loadedmetadata', () => {
                console.log('‚úÖ Segmentation video ready, dimensions:', segVideo.videoWidth, 'x', segVideo.videoHeight);
                // Clear video cache to force refresh
                this.videoElements.delete('camera');
            }, { once: true });
            
            // Always return the video element, even if not ready - rendering system will handle it
            return segVideo;
        }
    }
    
    updateStreamWithCanvasStream() {
        console.log('üîÑ Updating stream map with canvas stream...');
        
        if (!this.backgroundEffects.enabled || !this.backgroundEffects.segmentationCanvas) {
            console.log('‚ùå Background effects not enabled or no canvas');
            return;
        }
        
        try {
            // Make sure canvas has content before creating stream
            const ctx = this.backgroundEffects.segmentationCtx;
            
            // Get proper video element - use original stream if effects are enabled
            let videoElement = null;
            if (this.backgroundEffects.originalCameraStream) {
                // Create hidden video element for original stream if needed
                if (!this.backgroundEffects.sourceVideoElement) {
                    this.backgroundEffects.sourceVideoElement = document.createElement('video');
                    this.backgroundEffects.sourceVideoElement.autoplay = true;
                    this.backgroundEffects.sourceVideoElement.playsInline = true;
                    this.backgroundEffects.sourceVideoElement.muted = true;
                    this.backgroundEffects.sourceVideoElement.srcObject = this.backgroundEffects.originalCameraStream;
                    
                    // Add to DOM but hide it
                    this.backgroundEffects.sourceVideoElement.style.display = 'none';
                    document.body.appendChild(this.backgroundEffects.sourceVideoElement);
                    
                    console.log('üìπ Created and added source video element to DOM');
                }
                videoElement = this.backgroundEffects.sourceVideoElement;
            } else if (this.streams.has('camera')) {
                videoElement = this.getRawVideoElement('camera');
            }
            
            // Draw initial content
            if (videoElement && videoElement.readyState >= 2) {
                // Update canvas size if needed
                if (videoElement.videoWidth > 0) {
                    ctx.canvas.width = videoElement.videoWidth;
                    ctx.canvas.height = videoElement.videoHeight;
                }
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                ctx.drawImage(videoElement, 0, 0, ctx.canvas.width, ctx.canvas.height);
                console.log('‚úÖ Drew initial camera frame to canvas');
            } else {
                // DON'T draw white placeholder - wait for video to be ready
                console.log('‚ö†Ô∏è Camera not ready, waiting...');

                // Wait for video to be ready and try again - but DON'T update stream yet
                setTimeout(() => {
                    if (this.backgroundEffects.enabled) {
                        this.updateStreamWithCanvasStream();
                    }
                }, 500);

                // Exit early - don't create stream until video is ready
                return;
            }
            
            // Create or recreate the canvas stream if needed
            if (!this.backgroundEffects.canvasStream || 
                this.backgroundEffects.canvasStream.getVideoTracks().length === 0 ||
                this.backgroundEffects.canvasStream.getVideoTracks()[0].readyState === 'ended') {
                
                // Stop old stream if it exists
                if (this.backgroundEffects.canvasStream) {
                    this.backgroundEffects.canvasStream.getVideoTracks().forEach(track => track.stop());
                }
                
                this.backgroundEffects.canvasStream = this.backgroundEffects.segmentationCanvas.captureStream(30);
                console.log('‚úÖ Created new canvas stream');
            }
            
            // Store original camera stream if not already stored  
            if (this.streams.has('camera') && !this.backgroundEffects.originalCameraStream) {
                this.backgroundEffects.originalCameraStream = this.streams.get('camera');
                console.log('‚úÖ Stored original camera stream');
            }
            
            // Only replace stream if we successfully created a canvas stream
            if (this.backgroundEffects.canvasStream && this.backgroundEffects.canvasStream.active) {
                // Replace camera stream with canvas stream
                this.streams.set('camera', this.backgroundEffects.canvasStream);
                console.log('‚úÖ Updated camera stream with canvas stream');
                
                // Update the video element to show the canvas stream
                const videoElement = document.getElementById('video-camera');
                if (videoElement) {
                    videoElement.srcObject = this.backgroundEffects.canvasStream;
                    console.log('‚úÖ Updated video element with canvas stream');
                    
                    // Ensure video plays
                    videoElement.play().catch(e => {
                        console.error('Error playing canvas stream:', e);
                    });
                }
                
                // Trigger UI update
                this.onStreamUpdate('camera', this.backgroundEffects.canvasStream);
            } else {
                console.warn('‚ö†Ô∏è Canvas stream not ready or inactive');
            }
            
            // Trigger stream update event if needed
            this.onStreamUpdate('camera', this.backgroundEffects.canvasStream);
            
            // Start monitoring the canvas stream (only if not already monitoring)
            if (!this.backgroundEffects.isMonitoring) {
                this.backgroundEffects.isMonitoring = true;
                this.monitorCanvasStream();
            }
            
        } catch (error) {
            console.error('‚ùå Failed to update stream with canvas:', error);
        }
    }
    
    monitorCanvasStream() {
        console.log('üîç Starting canvas stream monitoring...');
        
        let checkCount = 0;
        const maxChecks = 30; // Increased monitoring time
        
        const checkStream = () => {
            checkCount++;
            
            if (!this.backgroundEffects.enabled || !this.backgroundEffects.canvasStream) {
                this.backgroundEffects.isMonitoring = false;
                return;
            }
            
            if (checkCount > maxChecks) {
                console.log('‚úÖ Canvas stream monitoring complete');
                this.backgroundEffects.isMonitoring = false;
                return;
            }
            
            // Check if the canvas stream has tracks and they're active
            const videoTracks = this.backgroundEffects.canvasStream.getVideoTracks();
            if (videoTracks.length === 0) {
                console.error('‚ùå Canvas stream has no video tracks! Recreating stream...');
                this.backgroundEffects.isMonitoring = false;
                this.recreateCanvasStream();
                return;
            }
            
            const track = videoTracks[0];
            if (track.readyState === 'ended') {
                console.error('‚ùå Canvas stream track has ended! Recreating stream...');
                this.backgroundEffects.isMonitoring = false;
                this.recreateCanvasStream();
                return;
            }
            
            console.log(`‚úÖ Canvas stream check ${checkCount}/${maxChecks} passed`);
            
            // Continue monitoring
            setTimeout(checkStream, 500);
        };
        
        // Start monitoring after a brief delay
        setTimeout(checkStream, 1000);
    }
    
    recreateCanvasStream() {
        console.log('üîÑ Recreating canvas stream to maintain background effects...');
        
        if (!this.backgroundEffects.enabled || !this.backgroundEffects.segmentationCanvas) {
            console.log('‚ùå Cannot recreate stream - effects disabled or no canvas');
            return;
        }
        
        try {
            // Stop the old stream if it exists
            if (this.backgroundEffects.canvasStream) {
                this.backgroundEffects.canvasStream.getVideoTracks().forEach(track => {
                    track.stop();
                });
            }
            
            // Ensure canvas has content
            const ctx = this.backgroundEffects.segmentationCtx;
            if (ctx) {
                // WICHTIG: KEIN wei√üer Hintergrund!
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

                // Draw current camera frame if available
                if (this.streams.has('camera') && this.backgroundEffects.originalCameraStream) {
                    const videoElement = this.getRawVideoElement('camera');
                    if (videoElement && videoElement.readyState >= 2) {
                        ctx.drawImage(videoElement, 0, 0, ctx.canvas.width, ctx.canvas.height);
                        console.log('‚úÖ Drew camera frame to refreshed canvas');
                    }
                }
            }
            
            // Create new canvas stream
            this.backgroundEffects.canvasStream = this.backgroundEffects.segmentationCanvas.captureStream(30);
            
            // Update stream map
            this.streams.set('camera', this.backgroundEffects.canvasStream);
            this.onStreamUpdate('camera', this.backgroundEffects.canvasStream);
            
            console.log('‚úÖ Successfully recreated canvas stream');
            
            // Continue background processing if MediaPipe is working
            if (this.backgroundEffects.mediapipeWorking) {
                console.log('üîÑ Resuming MediaPipe processing with new stream');
            }
            
            // Start new monitoring cycle
            this.backgroundEffects.isMonitoring = false;
            setTimeout(() => {
                if (!this.backgroundEffects.isMonitoring) {
                    this.backgroundEffects.isMonitoring = true;
                    this.monitorCanvasStream();
                }
            }, 500);
            
        } catch (error) {
            console.error('‚ùå Failed to recreate canvas stream:', error);
            // Only fall back to original stream if recreation fails
            this.restoreOriginalStream();
        }
    }
    
    validateCanvasStream() {
        // Quick check if canvas stream is still valid
        if (!this.backgroundEffects.enabled || !this.backgroundEffects.canvasStream) {
            return;
        }
        
        const videoTracks = this.backgroundEffects.canvasStream.getVideoTracks();
        if (videoTracks.length === 0 || videoTracks[0].readyState === 'ended') {
            console.log('üîÑ Canvas stream invalid during processing, recreating...');
            this.recreateCanvasStream();
        }
    }
    
    restoreOriginalStream() {
        console.log('üîÑ Restoring original camera stream due to canvas stream failure');
        
        if (this.backgroundEffects.originalCameraStream) {
            this.streams.set('camera', this.backgroundEffects.originalCameraStream);
            this.onStreamUpdate('camera', this.backgroundEffects.originalCameraStream);
            
            // Reset effects
            const enableSwitch = document.getElementById('enableBackgroundEffects');
            if (enableSwitch) enableSwitch.checked = false;
            this.backgroundEffects.enabled = false;
            this.updateSegmentationStatus('Stream-Fehler - Effekte deaktiviert');
            
            console.log('‚úÖ Original stream restored');
        }
    }
    
    async initializeSegmentation() {
        if (this.selfieSegmentation) {
            console.log('üéØ Segmentation already initialized');
            return;
        }
        
        try {
            console.log('üöÄ Initializing MediaPipe Selfie Segmentation...');
            this.updateSegmentationStatus('Initialisiere...');
            
            // Check if SelfieSegmentation is available
            if (typeof window.SelfieSegmentation === 'undefined') {
                console.error('‚ùå SelfieSegmentation not loaded. Waiting...');
                // Try again after a delay
                setTimeout(() => this.initializeSegmentation(), 1000);
                return;
            }
            
            // Ensure segmentation canvas exists
            if (!this.backgroundEffects.segmentationCanvas) {
                console.log('üîÑ Canvas not found, creating...');
                this.createSegmentationCanvas();
            }
            
            // üöÄ PERFORMANCE: Erstelle Downscale-Canvas f√ºr niedrigere Aufl√∂sung
            this.initializeOptimizationCanvases();

            // Initialize MediaPipe mit GPU-optimierten Einstellungen
            this.selfieSegmentation = new window.SelfieSegmentation({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}`;
                }
            });

            // WICHTIG: modelSelection 0 = fast (f√ºr fl√ºssige Performance)
            // modelSelection 1 = accurate (langsamer, bessere Qualit√§t)
            this.selfieSegmentation.setOptions({
                modelSelection: 0, // 0 = fast f√ºr fl√ºssige Aufnahme
                selfieMode: true
            });

            console.log('üöÄ GPU-Optimierungen aktiviert:', {
                useOffscreenCanvas: this.segmentationOptimization.useOffscreenCanvas,
                inputResolution: `${this.segmentationOptimization.inputWidth}x${this.segmentationOptimization.inputHeight}`,
                frameSkipping: `Jeden ${this.segmentationOptimization.processEveryNthFrame}. Frame`
            });
            
            this.selfieSegmentation.onResults((results) => {
                this.onSegmentationResults(results);
            });
            
            this.segmentationReady = true;
            this.updateSegmentationStatus('Bereit');
            console.log('‚úÖ MediaPipe Selfie Segmentation initialized');
            
            // Start processing if camera is active
            if (this.streams.has('camera')) {
                this.startBackgroundProcessing();

                // DON'T update stream immediately - wait for MediaPipe to process frames first
                // Stream will be updated automatically in onSegmentationResults() when MediaPipe is working
                console.log('‚è≥ Waiting for MediaPipe to start processing before switching stream...');

                // Set up timeout for MediaPipe initialization
                setTimeout(() => {
                    if (!this.backgroundEffects.mediapipeWorking) {
                        console.log('‚ö†Ô∏è MediaPipe timeout, using permanent fallback mode');
                        this.backgroundEffects.useFallbackMode = true;
                        this.updateSegmentationStatus('Fallback-Modus (MediaPipe nicht verf√ºgbar)');
                    }
                }, 3000); // 3 second timeout
            }
            
        } catch (error) {
            console.error('‚ùå Failed to initialize segmentation:', error);
            this.updateSegmentationStatus('Fehler: ' + error.message);
            this.segmentationReady = false;
            
            // Show user-friendly error message
            const errorMsg = `MediaPipe konnte nicht geladen werden. 
                             Bitte stellen Sie sicher, dass Sie eine stabile Internetverbindung haben.
                             Fehler: ${error.message}`;
            console.warn(errorMsg);
        }
    }
    
    startBackgroundProcessing() {
        if (!this.segmentationReady || !this.backgroundEffects.enabled) {
            console.log('‚ùå Cannot start processing - segmentation not ready or effects disabled');
            return;
        }
        
        const cameraStream = this.streams.get('camera');
        if (!cameraStream) {
            console.log('‚ùå No camera stream available for background processing');
            return;
        }
        
        console.log('üé¨ Starting background processing...');
        this.resetMaskCache('start-processing');
        
        // Create video element for processing
        let processingVideo = document.getElementById('processing-video');
        if (!processingVideo) {
            processingVideo = document.createElement('video');
            processingVideo.id = 'processing-video';
            processingVideo.autoplay = true;
            processingVideo.muted = true;
            processingVideo.playsInline = true;
            processingVideo.style.display = 'none';
            processingVideo.style.position = 'absolute';
            processingVideo.style.top = '-9999px';
            document.body.appendChild(processingVideo);
        }
        
        // Frame-Throttling: Verarbeite nur alle ~66ms (ca. 15 FPS) f√ºr fl√ºssige Performance
        // MediaPipe kann nicht mit 60 FPS mithalten
        const targetSegmentationFPS = 15;
        const minFrameInterval = 1000 / targetSegmentationFPS;
        let lastProcessTime = 0;

        const processFrame = async (timestamp) => {
            if (!this.backgroundEffects.enabled || !this.streams.has('camera') || !this.segmentationReady) {
                return;
            }

            // Frame-Throttling: √úberspringe Frames wenn zu schnell
            const elapsed = timestamp - lastProcessTime;
            if (elapsed < minFrameInterval) {
                requestAnimationFrame(processFrame);
                return;
            }
            lastProcessTime = timestamp;

            try {
                const opt = this.segmentationOptimization;

                // üöÄ Nur senden wenn MediaPipe nicht busy ist
                if (processingVideo.readyState >= 2 && !opt.isProcessing) {
                    const optimizedFrame = this.getOptimizedFrameForSegmentation(processingVideo);

                    if (optimizedFrame !== null) {
                        // Markiere als "in Bearbeitung"
                        opt.isProcessing = true;

                        // Sende Frame - Results kommen √ºber onSegmentationResults Callback
                        this.selfieSegmentation.send({ image: optimizedFrame })
                            .then(() => {
                                // isProcessing wird in onSegmentationResults zur√ºckgesetzt
                            })
                            .catch(err => {
                                console.warn('MediaPipe send error:', err);
                                opt.isProcessing = false; // Bei Fehler wieder freigeben
                            });
                    }
                }

                // Continue processing loop
                requestAnimationFrame(processFrame);

            } catch (error) {
                console.error('‚ùå Error in background processing:', error);
                this.updateSegmentationStatus('Fehler beim Verarbeiten');
                // Trotzdem weitermachen
                requestAnimationFrame(processFrame);
            }
        };
        
        let processingStarted = false;

        const startProcessing = () => {
            console.log(`üìπ Processing video ready: ${processingVideo.videoWidth}x${processingVideo.videoHeight}`);

            if (this.backgroundEffects.segmentationCanvas) {
                this.backgroundEffects.segmentationCanvas.width = processingVideo.videoWidth;
                this.backgroundEffects.segmentationCanvas.height = processingVideo.videoHeight;
                console.log(`üñºÔ∏è Segmentation canvas set to: ${this.backgroundEffects.segmentationCanvas.width}x${this.backgroundEffects.segmentationCanvas.height}`);
            }

            if (processingStarted) {
                return;
            }

            processingStarted = true;

            // üöÄ WICHTIG: Live-Render-Loop SOFORT starten (unabh√§ngig von MediaPipe)
            this.startLiveRenderLoop();

            // MediaPipe Masken-Berechnung starten (l√§uft parallel)
            processFrame();
        };

        processingVideo.onloadedmetadata = () => {
            startProcessing();
        };

        processingVideo.onerror = (error) => {
            console.error('‚ùå Processing video error:', error);
            this.updateSegmentationStatus('Video-Fehler');
        };

        processingVideo.srcObject = cameraStream;

        // Ensure autoplay reliably starts so MediaPipe receives frames
        const playPromise = processingVideo.play();
        if (playPromise && typeof playPromise.catch === 'function') {
            playPromise.catch(err => {
                console.warn('‚ö†Ô∏è Processing video autoplay blocked:', err);
            });
        }

        // If metadata is already available (e.g., when reusing the element), trigger processing immediately
        if (processingVideo.readyState >= 2) {
            startProcessing();
        }
    }
    
    drawDirectVideoToCanvas() {
        this.logDebug('üéØ Drawing direct video to canvas (fallback mode)');
        
        if (!this.backgroundEffects.segmentationCanvas || !this.backgroundEffects.segmentationCtx) {
            console.error('‚ùå No canvas available for direct video drawing');
            return;
        }
        
        const canvas = this.backgroundEffects.segmentationCanvas;
        const ctx = this.backgroundEffects.segmentationCtx;
        
        // Get the raw camera video element
        const videoElement = this.getRawVideoElement('camera');
        
        if (videoElement && videoElement.readyState >= 2) {
            try {
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw the video directly
                ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
                
                // Add overlay text to show it's fallback mode
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.fillRect(10, 10, 200, 30);
                ctx.fillStyle = 'black';
                ctx.font = '14px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('Kamera (Fallback-Modus)', 15, 30);
                
                this.logDebug('‚úÖ Direct video drawn to canvas');
                
            } catch (error) {
                console.error('‚ùå Failed to draw direct video:', error);
                
                // Last resort: draw a colored background
                ctx.fillStyle = '#4CAF50';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'white';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Kamera wird geladen...', canvas.width/2, canvas.height/2);
            }
        } else {
            // Video not ready, draw placeholder
            ctx.fillStyle = '#2196F3';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Kamera wird initialisiert...', canvas.width/2, canvas.height/2);
            
            this.logDebug('üìπ Video not ready, drew placeholder');
        }
    }
    
    onSegmentationResults(results) {
        // üöÄ WICHTIG: Busy-Flag zur√ºcksetzen damit n√§chster Frame verarbeitet werden kann
        this.segmentationOptimization.isProcessing = false;

        // üöÄ PERFORMANCE FIX: Nur Maske speichern, LIVE-Video f√ºr Rendering verwenden!
        // Das verhindert die 1-2 Sekunden Verz√∂gerung

        if (!results || !results.segmentationMask) {
            this.logDebug('‚ùå No segmentation mask received');
            return;
        }

        const canvas = this.backgroundEffects.segmentationCanvas;
        const ctx = this.backgroundEffects.segmentationCtx;

        if (!canvas || !ctx) {
            console.warn('‚ùå No segmentation canvas available');
            return;
        }

        // üöÄ NUR die Maske cachen - NICHT das Bild!
        const opt = this.segmentationOptimization;
        try {
            // Maske auf volle Canvas-Gr√∂√üe skaliert speichern
            if (!opt.cachedMaskCanvas) {
                opt.cachedMaskCanvas = document.createElement('canvas');
                opt.cachedMaskCtx = opt.cachedMaskCanvas.getContext('2d', { willReadFrequently: true });
            }

            opt.cachedMaskCanvas.width = canvas.width;
            opt.cachedMaskCanvas.height = canvas.height;
            opt.cachedMaskCtx.clearRect(0, 0, canvas.width, canvas.height);
            opt.cachedMaskCtx.drawImage(results.segmentationMask, 0, 0, canvas.width, canvas.height);
            opt.lastMaskTime = performance.now();

            // Speichere nur die Maske f√ºr sp√§teren Zugriff
            this.backgroundEffects.lastSegmentationResults = {
                segmentationMask: opt.cachedMaskCanvas
            };

        } catch (cacheError) {
            console.warn('‚ö†Ô∏è Failed to cache mask:', cacheError);
        }

        // Mark MediaPipe as working
        this.backgroundEffects.mediapipeWorking = true;
        this.backgroundEffects.segmentationActive = true;

        // üöÄ Starte Live-Render-Loop falls noch nicht aktiv
        if (!opt.liveRenderActive) {
            this.startLiveRenderLoop();
        }
    }

    // üöÄ NEU: Live-Render-Loop - zeichnet AKTUELLES Video mit gecachter Maske
    startLiveRenderLoop() {
        const opt = this.segmentationOptimization;
        if (opt.liveRenderActive) return;

        opt.liveRenderActive = true;
        console.log('üöÄ Live-Render-Loop gestartet (keine Verz√∂gerung mehr!)');

        const renderLiveFrame = () => {
            if (!this.backgroundEffects.enabled || !opt.liveRenderActive) {
                opt.liveRenderActive = false;
                return;
            }

            const canvas = this.backgroundEffects.segmentationCanvas;
            const ctx = this.backgroundEffects.segmentationCtx;

            if (!canvas || !ctx) {
                requestAnimationFrame(renderLiveFrame);
                return;
            }

            // üöÄ Hole das AKTUELLE Live-Video (nicht das gecachte!)
            const liveVideo = document.getElementById('processing-video');
            if (!liveVideo || liveVideo.readyState < 2) {
                requestAnimationFrame(renderLiveFrame);
                return;
            }

            // üöÄ Zeichne aktuelles Video mit gecachter Maske
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const mask = opt.cachedMaskCanvas;
            const mode = this.backgroundEffects.mode;

            if (mask && (mode === 'remove' || mode === 'blur' || mode === 'image')) {
                // Wende Effekt mit LIVE-Video und gecachter Maske an
                this.applyEffectWithLiveVideo(ctx, liveVideo, mask, mode);
            } else {
                // Kein Effekt - zeichne nur das Video
                ctx.drawImage(liveVideo, 0, 0, canvas.width, canvas.height);
            }

            // Validate und update stream
            this.validateCanvasStream();
            this.updateCameraStreamWithProcessed();

            // N√§chster Frame
            opt.liveRenderFrame = requestAnimationFrame(renderLiveFrame);
        };

        renderLiveFrame();
    }

    // üöÄ NEU: Wende Effekt mit Live-Video und gecachter Maske an
    applyEffectWithLiveVideo(ctx, liveVideo, mask, mode) {
        const canvas = ctx.canvas;
        const w = canvas.width;
        const h = canvas.height;

        // ü™û Helper: Maske gespiegelt zeichnen (Kamera ist gespiegelt, Maske nicht)
        const drawMaskMirrored = () => {
            ctx.save();
            ctx.translate(w, 0);
            ctx.scale(-1, 1);
            ctx.drawImage(mask, 0, 0, w, h);
            ctx.restore();
        };

        try {
            switch (mode) {
                case 'remove':
                    // Zeichne Live-Video
                    ctx.drawImage(liveVideo, 0, 0, w, h);
                    // Wende gespiegelte Maske als Clip an (nur Person sichtbar)
                    ctx.globalCompositeOperation = 'destination-in';
                    drawMaskMirrored();
                    ctx.globalCompositeOperation = 'source-over';
                    break;

                case 'blur':
                    // Hintergrund: Geblurrtes Video
                    ctx.filter = 'blur(15px)';
                    ctx.drawImage(liveVideo, 0, 0, w, h);
                    ctx.filter = 'none';
                    // Vordergrund: Scharfes Video mit gespiegelter Maske
                    ctx.globalCompositeOperation = 'destination-out';
                    drawMaskMirrored();
                    ctx.globalCompositeOperation = 'destination-over';
                    ctx.drawImage(liveVideo, 0, 0, w, h);
                    ctx.globalCompositeOperation = 'source-over';
                    break;

                case 'image':
                    // Hintergrundbild
                    if (this.backgroundEffects.backgroundImage) {
                        ctx.drawImage(this.backgroundEffects.backgroundImage, 0, 0, w, h);
                    } else {
                        ctx.fillStyle = this.backgroundEffects.color || '#00ff00';
                        ctx.fillRect(0, 0, w, h);
                    }
                    // Person dar√ºber mit gespiegelter Maske
                    ctx.globalCompositeOperation = 'destination-out';
                    drawMaskMirrored();
                    ctx.globalCompositeOperation = 'destination-over';
                    ctx.drawImage(liveVideo, 0, 0, w, h);
                    ctx.globalCompositeOperation = 'source-over';
                    break;

                default:
                    ctx.drawImage(liveVideo, 0, 0, w, h);
            }
        } catch (error) {
            console.error('‚ùå Error applying live effect:', error);
            ctx.drawImage(liveVideo, 0, 0, w, h);
        }
    }

    // Stoppe Live-Render-Loop
    stopLiveRenderLoop() {
        const opt = this.segmentationOptimization;
        opt.liveRenderActive = false;
        if (opt.liveRenderFrame) {
            cancelAnimationFrame(opt.liveRenderFrame);
            opt.liveRenderFrame = null;
        }
        console.log('üõë Live-Render-Loop gestoppt');
    }
    
    applyBackgroundRemoval(ctx, results) {
        const canvas = ctx.canvas;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        try {
            const weights = this.computeMaskWeights(results);
            if (!weights) {
                this.logDebug('‚ö†Ô∏è No segmentation mask available, drawing original');
                if (results.image) {
                    ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
                }
                return;
            }

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
            tempCtx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
            const imageData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);

            const pixelCount = Math.min(weights.length, imageData.data.length / 4);
            for (let p = 0, i = 0; p < pixelCount; p++, i += 4) {
                const alpha = Math.round(Math.min(1, Math.max(0, weights[p])) * 255);
                imageData.data[i + 3] = alpha;
            }

            ctx.putImageData(imageData, 0, 0);

            this.logDebug('‚úÖ Applied background removal with segmentation mask');
        } catch (error) {
            console.error('‚ùå Error applying background removal:', error);
            if (results.image) {
                ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
            }
        }

        this.updateDebugCanvas(canvas);
    }

    applyBackgroundBlur(ctx, results) {
        const canvas = ctx.canvas;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const weights = this.computeMaskWeights(results);
        if (!weights) {
            this.logDebug('‚ö†Ô∏è No segmentation mask available, drawing original');
            if (results.image) {
                ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
            }
            return;
        }

        try {
            const blurStrength = this.backgroundEffects.blurStrength || 10;
            const dimensions = this.backgroundEffects.maskDimensions;
            const personMaskCanvas = this.createMaskCanvasFromWeights(weights, dimensions);

            ctx.save();
            ctx.filter = `blur(${blurStrength}px)`;
            ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
            ctx.restore();

            if (personMaskCanvas) {
                ctx.save();
                ctx.globalCompositeOperation = 'destination-out';
                ctx.drawImage(personMaskCanvas, 0, 0, canvas.width, canvas.height);
                ctx.restore();
            }

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
            tempCtx.globalCompositeOperation = 'destination-in';

            if (personMaskCanvas) {
                tempCtx.drawImage(personMaskCanvas, 0, 0, canvas.width, canvas.height);
            } else if (results.segmentationMask) {
                tempCtx.drawImage(results.segmentationMask, 0, 0, canvas.width, canvas.height);
            }

            ctx.globalCompositeOperation = 'source-over';
            ctx.drawImage(tempCanvas, 0, 0);

            this.logDebug(`‚úÖ Applied background blur (strength: ${blurStrength}px)`);
        } catch (error) {
            console.error('‚ùå Error applying background blur:', error);
            ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
        }

        this.updateDebugCanvas(canvas);
    }

    applyBackgroundImage(ctx, results) {
        const canvas = ctx.canvas;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const weights = this.computeMaskWeights(results);
        const dimensions = this.backgroundEffects.maskDimensions;
        const personMaskCanvas = this.createMaskCanvasFromWeights(weights, dimensions);

        if (this.backgroundEffects.backgroundImage) {
            ctx.drawImage(this.backgroundEffects.backgroundImage, 0, 0, canvas.width, canvas.height);
        } else {
            ctx.fillStyle = '#00FF00';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        if (results.image) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
            tempCtx.globalCompositeOperation = 'destination-in';

            if (personMaskCanvas) {
                tempCtx.drawImage(personMaskCanvas, 0, 0, canvas.width, canvas.height);
            } else if (results.segmentationMask) {
                tempCtx.drawImage(results.segmentationMask, 0, 0, canvas.width, canvas.height);
            }

            ctx.globalCompositeOperation = 'source-over';
            ctx.drawImage(tempCanvas, 0, 0);
        } else {
            ctx.fillStyle = '#000000';
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Image Test', canvas.width/2, canvas.height/2);
            this.logDebug('‚úÖ Drew image test pattern');
        }

        this.updateDebugCanvas(canvas);
    }

    computeMaskWeights(results) {
        if (!results || !results.segmentationMask) {
            this.backgroundEffects._maskImmediateFrame = false;
            return null;
        }

        const canvas = this.backgroundEffects.segmentationCanvas;
        const width = canvas && canvas.width ? canvas.width : (results.segmentationMask.width || (results.image ? results.image.width : 0));
        const height = canvas && canvas.height ? canvas.height : (results.segmentationMask.height || (results.image ? results.image.height : 0));

        if (!width || !height) {
            this.backgroundEffects._maskImmediateFrame = false;
            return null;
        }

        if (!this.backgroundEffects._maskProcessingCanvas) {
            this.backgroundEffects._maskProcessingCanvas = document.createElement('canvas');
            this.backgroundEffects._maskProcessingCtx = this.backgroundEffects._maskProcessingCanvas.getContext('2d', { willReadFrequently: true });
        }

        const procCanvas = this.backgroundEffects._maskProcessingCanvas;
        const procCtx = this.backgroundEffects._maskProcessingCtx;
        procCanvas.width = width;
        procCanvas.height = height;
        procCtx.clearRect(0, 0, width, height);

        const blurRadius = Math.max(0, this.backgroundEffects.maskBlurRadius || 0);
        if (blurRadius > 0) {
            procCtx.filter = `blur(${blurRadius}px)`;
        }
        procCtx.drawImage(results.segmentationMask, 0, 0, width, height);
        if (blurRadius > 0) {
            procCtx.filter = 'none';
        }

        const maskData = procCtx.getImageData(0, 0, width, height);
        const pixelCount = width * height;

        if (!this.backgroundEffects.previousMaskData || this.backgroundEffects.previousMaskData.length !== pixelCount) {
            this.backgroundEffects.previousMaskData = new Float32Array(pixelCount);
            this.backgroundEffects.maskInitialized = false;
        }

        const prevMask = this.backgroundEffects.previousMaskData;
        const forceFresh = this.backgroundEffects._maskImmediateFrame;
        const hasPrevMask = !forceFresh && this.backgroundEffects.maskInitialized;
        const smoothingRaw = this.backgroundEffects.maskSmoothing ?? 0.65;
        const smoothing = Math.max(0, Math.min(0.99, smoothingRaw));
        const threshold = Math.max(0, Math.min(1, this.backgroundEffects.confidenceThreshold ?? 0.6));
        const featherRaw = this.backgroundEffects.edgeFeather ?? 0.12;
        const feather = Math.max(0.001, Math.min(0.5, featherRaw));
        const minAlpha = 0;
        const thresholdShift = (threshold - 0.6) * 1.4; // tighten (>0) or loosen (<0) mask
        const featherGamma = Math.max(0.1, 1.0 + (0.25 - feather) * 3.5);

        if (this.debugLogging) {
            const now = performance.now();
            if (!this.backgroundEffects._lastMaskLog || now - this.backgroundEffects._lastMaskLog > 5000) {
                console.log('üßÆ Mask params', {
                    smoothing: smoothing.toFixed(2),
                    threshold: threshold.toFixed(2),
                    feather: feather.toFixed(2),
                    blurRadius,
                    thresholdShift: thresholdShift.toFixed(2),
                    featherGamma: featherGamma.toFixed(2)
                });
                this.backgroundEffects._lastMaskLog = now;
            }
        }

        const normalizeDenominator = Math.max(0.0001, 1 - thresholdShift);

        for (let i = 0, p = 0; p < pixelCount && i < maskData.data.length; i += 4, p++) {
            const maskSample = maskData.data[i] / 255; // red channel normalised

            let normalized = (maskSample - thresholdShift) / normalizeDenominator;
            normalized = Math.min(1, Math.max(0, normalized));

            // Feather controls transitions via gamma curve (lower feather = sharper edges)
            let value = Math.pow(normalized, featherGamma);

            if (hasPrevMask) {
                value = prevMask[p] * smoothing + value * (1 - smoothing);
            }

            if (value < minAlpha) value = 0;
            if (value > 1 - minAlpha) value = 1;

            prevMask[p] = value;
        }

        this.backgroundEffects.maskInitialized = true;
        this.backgroundEffects.maskDimensions = { width, height };
        this.backgroundEffects._maskImmediateFrame = false;

        return prevMask;
    }

    createMaskCanvasFromWeights(weights, dimensions, invert = false) {
        if (!weights || !dimensions || !dimensions.width || !dimensions.height) {
            return null;
        }

        const maskCanvas = document.createElement('canvas');
        maskCanvas.width = dimensions.width;
        maskCanvas.height = dimensions.height;
        const maskCtx = maskCanvas.getContext('2d');
        const imageData = maskCtx.createImageData(dimensions.width, dimensions.height);

        const pixelCount = Math.min(weights.length, imageData.data.length / 4);
        for (let p = 0, i = 0; p < pixelCount; p++, i += 4) {
            const value = invert ? 1 - weights[p] : weights[p];
            const clamped = Math.min(1, Math.max(0, value));
            const alpha = Math.round(clamped * 255);
            imageData.data[i] = 255;
            imageData.data[i + 1] = 255;
            imageData.data[i + 2] = 255;
            imageData.data[i + 3] = alpha;
        }

        maskCtx.putImageData(imageData, 0, 0);
        return maskCanvas;
    }

    updateDebugCanvas(sourceCanvas) {
        const debugCanvas = document.getElementById('debugCanvas');
        const debugStatus = document.getElementById('debugCanvasStatus');

        this.logDebug('üîç updateDebugCanvas called:', {
            hasDebugCanvas: !!debugCanvas,
            hasSourceCanvas: !!sourceCanvas,
            sourceCanvasSize: sourceCanvas ? `${sourceCanvas.width}x${sourceCanvas.height}` : 'none'
        });
        
        if (debugCanvas) {
            const debugCtx = debugCanvas.getContext('2d');
            
            // Always draw something to test
            debugCtx.clearRect(0, 0, debugCanvas.width, debugCanvas.height);
            
            if (sourceCanvas) {
                // Try to copy the source canvas
                try {
                    debugCtx.drawImage(sourceCanvas, 0, 0, debugCanvas.width, debugCanvas.height);
                    this.logDebug('üñºÔ∏è Successfully copied source canvas to debug canvas');
                } catch (error) {
                    console.error('‚ùå Error copying source canvas:', error);
                    // Draw error pattern
                    debugCtx.fillStyle = '#FF0000';
                    debugCtx.fillRect(0, 0, debugCanvas.width, debugCanvas.height);
                    debugCtx.fillStyle = '#FFFFFF';
                    debugCtx.font = '12px Arial';
                    debugCtx.textAlign = 'center';
                    debugCtx.fillText('ERROR', debugCanvas.width/2, debugCanvas.height/2);
                }
            } else {
                // Draw "no source" pattern
                debugCtx.fillStyle = '#800080'; // Purple
                debugCtx.fillRect(0, 0, debugCanvas.width, debugCanvas.height);
                debugCtx.fillStyle = '#FFFFFF';
                debugCtx.font = '12px Arial';
                debugCtx.textAlign = 'center';
                debugCtx.fillText('NO SOURCE', debugCanvas.width/2, debugCanvas.height/2);
                this.logDebug('üñºÔ∏è Drew "no source" pattern');
        }
        
            // Update status
            if (debugStatus) {
                debugStatus.textContent = sourceCanvas ? `Aktiv (${sourceCanvas.width}x${sourceCanvas.height})` : 'Kein Canvas';
                debugStatus.className = sourceCanvas ? 'badge bg-success' : 'badge bg-warning';
            }
        } else {
            console.warn('‚ùå Debug canvas element not found');
        }
    }
    
    updateCameraStreamWithProcessed() {
        // If background effects are enabled, use the processed stream
        if (this.backgroundEffects.enabled && this.backgroundEffects.mode !== 'none' && this.backgroundEffects.segmentationCanvas) {
            try {
                // Create stream from canvas (throttle to avoid too frequent updates)
                if (!this.backgroundEffects.processedStream || !this.backgroundEffects.streamReplaced) {
                    // Create the processed stream - 60 FPS f√ºr fl√ºssiges Video!
                    this.backgroundEffects.processedStream = this.backgroundEffects.segmentationCanvas.captureStream(60);
                    this.backgroundEffects.canvasStream = this.backgroundEffects.processedStream; // F√ºr getVideoElementOptimized
                    console.log('üé¨ Created processed stream from canvas (60 FPS)');

                    // Replace the video element's stream ONCE when MediaPipe is working
                    if (!this.backgroundEffects.streamReplaced && this.backgroundEffects.mediapipeWorking) {
                        const videoElement = document.getElementById('video-camera');
                        if (videoElement && this.backgroundEffects.processedStream) {
                            // Save original stream if not saved
                            if (!this.backgroundEffects.originalCameraStream) {
                                this.backgroundEffects.originalCameraStream = this.streams.get('camera');
                                console.log('üíæ Saved original camera stream');
                            }

                            // Replace stream
                            videoElement.srcObject = this.backgroundEffects.processedStream;
                            this.streams.set('camera', this.backgroundEffects.processedStream);

                            videoElement.play().catch(e => {
                                console.error('Error playing processed stream:', e);
                            });

                            this.backgroundEffects.streamReplaced = true;
                            console.log('‚úÖ Replaced camera stream with processed stream');
                        }
                    }
                }
            } catch (error) {
                console.error('‚ùå Error creating/updating processed stream:', error);
            }
        }
    }
    
    handleBackgroundImageUpload(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        // Check file size (max 5MB)
        if (file.size > 5 * 1024 * 1024) {
            alert('Datei zu gro√ü. Maximal 5MB erlaubt.');
            return;
        }
        
        const reader = new FileReader();
        reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
                this.backgroundEffects.backgroundImage = img;
                
                // Show preview
                const preview = document.getElementById('backgroundImagePreview');
                if (preview) {
                    preview.style.display = 'block';
                    const previewImg = preview.querySelector('img');
                    if (previewImg) {
                        previewImg.src = e.target.result;
                    }
                }
                
                // If image mode is active, reapply the effect
                if (this.backgroundEffects.mode === 'image' && this.backgroundEffects.enabled) {
                    this.applySimpleEffect('image');
                    this.logDebug('üñºÔ∏è Updated background image effect');
                }
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    }
    
    applyEffectToCompositionCanvas(mode, segmentationResults = null) {
        this.logDebug('üé® Applying effect to composition canvas:', mode, segmentationResults ? 'with segmentation' : 'without segmentation');
        
        // Get the main composition canvas in the Live Vorschau area
        const compositionCanvas = document.getElementById('compositionCanvas');
        if (!compositionCanvas) {
            console.warn('‚ùå Composition canvas not found');
            return;
        }
        
        // Get the direct parent container of the canvas
        const container = compositionCanvas.parentElement;
        if (!container) {
            console.warn('‚ùå Canvas container not found');
            return;
        }

        this.logDebug('üéØ Targeting composition canvas in Live Vorschau');
        
        // Ensure container has position relative for overlay positioning
        container.style.position = 'relative';
        container.style.overflow = 'hidden';
        
        // Remove any existing effects first
        compositionCanvas.style.filter = '';
        compositionCanvas.style.transform = '';
        compositionCanvas.style.mixBlendMode = '';
        container.style.backgroundColor = '';
        
        // Remove old overlays
        const oldOverlays = container.querySelectorAll('.effect-overlay, .blur-overlay, .bg-image-overlay, .intelligent-effect-canvas');
        oldOverlays.forEach(o => o.remove());

        // Ensure sliders/listeners stay initialised regardless of mode
        this.setupEffectControls();

        // For pure removal we intentionally leave the canvas untouched
        if (mode === 'remove') {
            return;
        }

        // If we have segmentation results, apply intelligent effects
        if (segmentationResults && segmentationResults.segmentationMask) {
            this.applyIntelligentEffect(compositionCanvas, container, mode, segmentationResults);
        } else {
            // Fall back to simple CSS-based effects
            this.applySimpleCSSEffect(compositionCanvas, container, mode);
        }
    }
    
    applyIntelligentEffect(canvas, container, mode, results) {
        this.logDebug('üß† Applying intelligent effect with person segmentation:', mode);
        
        // Create an overlay canvas for the effect
        let effectCanvas = container.querySelector('.intelligent-effect-canvas');
        if (!effectCanvas) {
            effectCanvas = document.createElement('canvas');
            effectCanvas.className = 'intelligent-effect-canvas';
            effectCanvas.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
                z-index: 3;
            `;
            container.appendChild(effectCanvas);
        }
        
        // Set canvas size to match composition canvas
        effectCanvas.width = canvas.width;
        effectCanvas.height = canvas.height;
        const effectCtx = effectCanvas.getContext('2d');
        
        // Clear the effect canvas
        effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);

        if (!results || !results.image) {
            this.logDebug('‚ö†Ô∏è Missing image for intelligent effect, falling back to simple effect');
            effectCanvas.remove();
            this.applySimpleCSSEffect(canvas, container, mode);
            return;
        }

        try {
            let weights = this.backgroundEffects.previousMaskData;
            if ((!weights || !this.backgroundEffects.maskDimensions) && results && results.segmentationMask) {
                weights = this.computeMaskWeights(results);
            }
            const dimensions = this.backgroundEffects.maskDimensions;

            switch(mode) {
                case 'blur':
                    this.applyIntelligentBlur(effectCtx, results, weights, dimensions);
                    break;
                case 'remove':
                    this.applyIntelligentRemoval(effectCtx, results, weights, dimensions);
                    break;
                case 'image':
                    this.applyIntelligentImageBackground(effectCtx, results, weights, dimensions);
                    break;
                default:
                    // Remove effect canvas for 'none'
                    effectCanvas.remove();
                    break;
            }
        } catch (error) {
            console.error('‚ùå Error applying intelligent effect:', error);
            // Fall back to simple effect
            effectCanvas.remove();
            this.applySimpleCSSEffect(canvas, container, mode);
        }
    }
    
    applyIntelligentBlur(ctx, results, weights, dimensions) {
        const canvas = ctx.canvas;

        const blurStrength = this.backgroundEffects.blurStrength || 15;

        ctx.save();
        ctx.filter = `blur(${blurStrength}px)`;
        ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
        ctx.restore();

        const personMaskCanvas = this.createMaskCanvasFromWeights(weights, dimensions);

        if (personMaskCanvas) {
            ctx.save();
            ctx.globalCompositeOperation = 'destination-out';
            ctx.drawImage(personMaskCanvas, 0, 0, canvas.width, canvas.height);
            ctx.restore();
        }

        const personCanvas = document.createElement('canvas');
        personCanvas.width = canvas.width;
        personCanvas.height = canvas.height;
        const personCtx = personCanvas.getContext('2d');
        personCtx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
        personCtx.globalCompositeOperation = 'destination-in';

        if (personMaskCanvas) {
            personCtx.drawImage(personMaskCanvas, 0, 0, canvas.width, canvas.height);
        } else if (results.segmentationMask) {
            personCtx.drawImage(results.segmentationMask, 0, 0, canvas.width, canvas.height);
        }

        ctx.globalCompositeOperation = 'source-over';
        ctx.drawImage(personCanvas, 0, 0);

        this.logDebug(`‚úÖ Applied intelligent blur (strength: ${blurStrength}px)`);
    }
    
    applyIntelligentRemoval(ctx, results, weights, dimensions) {
        const canvas = ctx.canvas;

        ctx.fillStyle = '#f0f0f0';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        if (!results.image) {
            return;
        }

        const personMaskCanvas = this.createMaskCanvasFromWeights(weights, dimensions);
        const personCanvas = document.createElement('canvas');
        personCanvas.width = canvas.width;
        personCanvas.height = canvas.height;
        const personCtx = personCanvas.getContext('2d');
        personCtx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
        personCtx.globalCompositeOperation = 'destination-in';

        if (personMaskCanvas) {
            personCtx.drawImage(personMaskCanvas, 0, 0, canvas.width, canvas.height);
        } else if (results.segmentationMask) {
            personCtx.drawImage(results.segmentationMask, 0, 0, canvas.width, canvas.height);
        }

        ctx.globalCompositeOperation = 'source-over';
        ctx.drawImage(personCanvas, 0, 0);

        this.logDebug('‚úÖ Applied intelligent background removal');
    }
    
    applyIntelligentImageBackground(ctx, results, weights, dimensions) {
        const canvas = ctx.canvas;

        if (this.backgroundEffects.backgroundImage) {
            ctx.drawImage(this.backgroundEffects.backgroundImage, 0, 0, canvas.width, canvas.height);
        } else {
            ctx.fillStyle = '#00ff00';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        if (!results.image) {
            return;
        }

        const personMaskCanvas = this.createMaskCanvasFromWeights(weights, dimensions);
        const personCanvas = document.createElement('canvas');
        personCanvas.width = canvas.width;
        personCanvas.height = canvas.height;
        const personCtx = personCanvas.getContext('2d');
        personCtx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
        personCtx.globalCompositeOperation = 'destination-in';

        if (personMaskCanvas) {
            personCtx.drawImage(personMaskCanvas, 0, 0, canvas.width, canvas.height);
        } else if (results.segmentationMask) {
            personCtx.drawImage(results.segmentationMask, 0, 0, canvas.width, canvas.height);
        }

        ctx.globalCompositeOperation = 'source-over';
        ctx.drawImage(personCanvas, 0, 0);

        this.logDebug('‚úÖ Applied intelligent background image');
    }
    
    applySimpleEffect(mode) {
        // Forward to new function
        this.applyEffectToCompositionCanvas(mode);
    }
    
    applySimpleCSSEffect(canvas, container, mode) {
        this.logDebug('üé® Applying simple CSS effect:', mode);
        
        // Apply effect to the main canvas
        switch(mode) {
            case 'blur':
                // Create a canvas-based blur effect
                const blurOverlay = document.createElement('div');
                blurOverlay.className = 'blur-overlay effect-overlay';
                blurOverlay.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    backdrop-filter: blur(${this.backgroundEffects.blurStrength || 15}px);
                    -webkit-backdrop-filter: blur(${this.backgroundEffects.blurStrength || 15}px);
                    mask-image: radial-gradient(ellipse 35% 45% at center, transparent 60%, black 100%);
                    -webkit-mask-image: radial-gradient(ellipse 35% 45% at center, transparent 60%, black 100%);
                    pointer-events: none;
                    z-index: 2;
                `;
                container.appendChild(blurOverlay);
                this.logDebug('‚úÖ Applied blur overlay effect to composition canvas');
                break;
                    
            case 'remove':
                // Set a neutral studio background
                container.style.backgroundColor = '#f0f0f0';
                
                // Apply stronger contrast and saturation to make canvas content stand out
                canvas.style.filter = 'contrast(1.6) saturate(1.3) brightness(1.2)';
                
                // Create a better background removal simulation with soft edges
                const removeOverlay = document.createElement('div');
                removeOverlay.className = 'effect-overlay';
                removeOverlay.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: radial-gradient(ellipse 60% 70% at center, 
                        transparent 0%, 
                        transparent 35%,
                        rgba(240, 240, 240, 0.4) 55%,
                        rgba(240, 240, 240, 0.95) 85%,
                        rgba(240, 240, 240, 1) 100%);
                    pointer-events: none;
                    z-index: 2;
                `;
                container.appendChild(removeOverlay);
                this.logDebug('‚úÖ Applied improved background removal effect to composition canvas');
                break;
                    
            case 'image':
                // Background image effect
                if (this.backgroundEffects.backgroundImage) {
                    // Create image overlay behind canvas
                    const imgOverlay = document.createElement('div');
                    imgOverlay.className = 'bg-image-overlay effect-overlay';
                    imgOverlay.style.cssText = `
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background-image: url(${this.backgroundEffects.backgroundImage.src});
                        background-size: cover;
                        background-position: center;
                        z-index: 0;
                    `;
                    container.appendChild(imgOverlay);
                    
                    // Make canvas appear on top with some transparency
                    canvas.style.position = 'relative';
                    canvas.style.zIndex = '1';
                    
                    // Create mask for canvas
                    const maskOverlay = document.createElement('div');
                    maskOverlay.className = 'effect-overlay';
                    maskOverlay.style.cssText = `
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: radial-gradient(ellipse at center,
                            transparent 40%,
                            rgba(0, 0, 0, 0.8) 70%);
                        pointer-events: none;
                        z-index: 2;
                    `;
                    container.appendChild(maskOverlay);
                    this.logDebug('‚úÖ Applied background image effect to composition canvas');
                } else {
                    // Default green screen effect
                    container.style.backgroundColor = '#00ff00';
                    canvas.style.filter = 'contrast(1.2)';
                    this.logDebug('‚úÖ Applied green screen effect to composition canvas (no image uploaded)');
                }
                break;
                    
            case 'none':
            default:
                // Already cleaned up at the beginning
                this.logDebug('‚úÖ Removed all effects from composition canvas');
                break;
        }
        
        // Setup blur strength slider if not already done
        this.setupEffectControls();
    }
    
    setupEffectControls() {
        // Blur strength slider
        const blurSlider = document.getElementById('blurStrength');
        if (blurSlider && !blurSlider.hasListener) {
            blurSlider.hasListener = true;
            blurSlider.addEventListener('input', (e) => {
                this.backgroundEffects.blurStrength = parseInt(e.target.value);
                document.getElementById('blurStrengthValue').textContent = e.target.value;
                
                // Update blur overlay if blur is active
                if (this.backgroundEffects.mode === 'blur') {
                    const overlays = document.querySelectorAll('.blur-overlay');
                    overlays.forEach(overlay => {
                        overlay.style.backdropFilter = `blur(${this.backgroundEffects.blurStrength}px)`;
                        overlay.style.webkitBackdropFilter = `blur(${this.backgroundEffects.blurStrength}px)`;
                    });
                }
            });
        }
        
        // Background image upload
        const imageUpload = document.getElementById('backgroundImageUpload');
        if (imageUpload && !imageUpload.hasListener) {
            imageUpload.hasListener = true;
            imageUpload.addEventListener('change', (e) => {
                this.handleBackgroundImageUpload(e);
            });
        }

        const setupRangeControl = (id, valueId, propertyKey, parser = parseFloat, formatter = (v) => Number(v).toFixed(2)) => {
            const input = document.getElementById(id);
            if (!input) return;

            const label = valueId ? document.getElementById(valueId) : null;
            const updateValueLabel = (val) => {
                if (label) {
                    label.textContent = formatter(val);
                }
            };

            if (!input.hasListener) {
                input.hasListener = true;
                input.addEventListener('input', (e) => {
                    const raw = parser(e.target.value);
                    if (!Number.isFinite(raw)) {
                        return;
                    }
                    this.backgroundEffects[propertyKey] = raw;
                    input.value = `${raw}`;
                    this.resetMaskCache(`slider:${propertyKey}`);
                    updateValueLabel(raw);
                    this.logDebug(`üéöÔ∏è Updated ${propertyKey} to`, raw);
                    if (this.backgroundEffects.enabled && this.segmentationReady && !this.backgroundEffects.segmentationActive) {
                        this.startBackgroundProcessing();
                    }
                    if (this.backgroundEffects.enabled && this.backgroundEffects.lastSegmentationResults) {
                        this.onSegmentationResults(this.backgroundEffects.lastSegmentationResults);
                    }
                    this.updateSegmentationStatus(`Feinjustierung: ${propertyKey} = ${formatter(raw)}`);
                });
            }

            const currentValue = this.backgroundEffects[propertyKey];
            if (Number.isFinite(currentValue)) {
                input.value = currentValue;
                updateValueLabel(currentValue);
            }
        };

        setupRangeControl('maskSmoothing', 'maskSmoothingValue', 'maskSmoothing');
        setupRangeControl('maskConfidence', 'maskConfidenceValue', 'confidenceThreshold', parseFloat, (v) => Number(v).toFixed(2));
        setupRangeControl('maskFeather', 'maskFeatherValue', 'edgeFeather', parseFloat, (v) => Number(v).toFixed(2));
        setupRangeControl('maskBlurRadius', 'maskBlurRadiusValue', 'maskBlurRadius', (v) => parseInt(v, 10), (v) => parseInt(v, 10));
    }
    
    updateEffectControls(mode) {
        // Hide all controls
        const blurControls = document.getElementById('blurControls');
        const imageControls = document.getElementById('imageControls');
        
        if (blurControls) blurControls.style.display = 'none';
        if (imageControls) imageControls.style.display = 'none';
        
        // Show relevant controls
        switch (mode) {
            case 'blur':
                if (blurControls) blurControls.style.display = 'block';
                break;
            case 'image':
                if (imageControls) imageControls.style.display = 'block';
                break;
        }
    }

    async toggleGreenScreen(enabled) {
        console.log(`üé¨ Green Screen ${enabled ? 'aktivieren' : 'deaktivieren'}...`);

        const statusBadge = document.getElementById('greenScreenStatus');
        const toggle = document.getElementById('greenScreenToggle');

        if (enabled) {
            // Check if camera is active
            if (!this.streams.has('camera')) {
                console.warn('‚ö†Ô∏è Keine Kamera aktiv - bitte zuerst Kamera starten');
                alert('Bitte starten Sie zuerst Ihre Kamera, bevor Sie den Green Screen Effekt aktivieren.');
                if (toggle) toggle.checked = false;
                return;
            }

            try {
                // SIMPLE APPROACH: Don't replace stream, just enable effect mode
                this.backgroundEffects.enabled = true;
                this.backgroundEffects.mode = 'remove';
                this.backgroundEffects.greenScreenActive = true; // Special flag for green screen

                // Save original stream reference (but don't replace it!)
                if (!this.backgroundEffects.originalCameraStream) {
                    this.backgroundEffects.originalCameraStream = this.streams.get('camera');
                    console.log('üíæ Saved camera stream reference');
                }

                // Show status badge (loading state)
                if (statusBadge) {
                    statusBadge.style.display = 'block';
                    const fpsSpan = document.getElementById('greenScreenFPS');
                    if (fpsSpan) fpsSpan.textContent = '(l√§dt...)';
                }

                // Initialize MediaPipe if not already done
                if (!this.segmentationReady) {
                    console.log('üöÄ MediaPipe wird initialisiert...');

                    // Create segmentation canvas
                    if (!this.backgroundEffects.segmentationCanvas) {
                        this.createSegmentationCanvas();
                    }

                    // Initialize MediaPipe
                    await this.initializeSegmentation();

                    console.log('‚úÖ MediaPipe initialisiert');
                } else {
                    console.log('‚úÖ MediaPipe bereits initialisiert, aktiviere Effekt');

                    // Start processing if not already running
                    if (!this.backgroundEffects.segmentationActive) {
                        this.startBackgroundProcessing();
                    }
                }

                // Update status
                if (statusBadge) {
                    const fpsSpan = document.getElementById('greenScreenFPS');
                    if (fpsSpan) fpsSpan.textContent = '(aktiv)';
                }

                console.log('‚úÖ Green Screen aktiviert - Effekt wird auf Composition Canvas angewendet');

            } catch (error) {
                console.error('‚ùå Fehler beim Aktivieren:', error);
                if (toggle) toggle.checked = false;
                if (statusBadge) statusBadge.style.display = 'none';
            }

        } else {
            // Disable and restore original stream
            this.backgroundEffects.greenScreenActive = false;
            this.backgroundEffects.segmentationActive = false; // Stop segmentation
            this.backgroundEffects.mediapipeWorking = false; // Reset MediaPipe flag

            this.disableBackgroundEffects();

            // Hide status badge
            if (statusBadge) {
                statusBadge.style.display = 'none';
            }

            console.log('‚úÖ Green Screen deaktiviert - normale Kamera wieder sichtbar');
        }
    }

    disableBackgroundEffects() {
        console.log('üîÑ Disabling background effects...');

        this.backgroundEffects.enabled = false;
        this.backgroundEffects.mode = 'none';
        this.backgroundEffects.streamReplaced = false; // Reset flag for next activation
        
        // Stop animation frame first
        if (this.backgroundEffects.animationFrame) {
            cancelAnimationFrame(this.backgroundEffects.animationFrame);
            this.backgroundEffects.animationFrame = null;
        }
        
        // Clean up source video element
        if (this.backgroundEffects.sourceVideoElement) {
            this.backgroundEffects.sourceVideoElement.srcObject = null;
            if (this.backgroundEffects.sourceVideoElement.parentNode) {
                this.backgroundEffects.sourceVideoElement.parentNode.removeChild(this.backgroundEffects.sourceVideoElement);
            }
            this.backgroundEffects.sourceVideoElement = null;
        }
        
        // Clean up canvas stream BEFORE restoring
        if (this.backgroundEffects.canvasStream) {
            this.backgroundEffects.canvasStream.getTracks().forEach(track => track.stop());
            this.backgroundEffects.canvasStream = null;
        }

        // Clean up processed stream
        if (this.backgroundEffects.processedStream) {
            this.backgroundEffects.processedStream.getTracks().forEach(track => track.stop());
            this.backgroundEffects.processedStream = null;
        }
        
        // Restore original camera stream
        if (this.backgroundEffects.originalCameraStream) {
            console.log('üîÑ Restoring original camera stream');

            // Update stream map and notify listeners
            this.streams.set('camera', this.backgroundEffects.originalCameraStream);
            this.onStreamUpdate('camera', this.backgroundEffects.originalCameraStream);

            // Keep reference for next activation
            // this.backgroundEffects.originalCameraStream = null;
        } else {
            console.warn('‚ö†Ô∏è No original stream to restore');
        }
        
        // Continue with the rest of cleanup
        if (this.backgroundEffects.animationFrame) {
            cancelAnimationFrame(this.backgroundEffects.animationFrame);
            this.backgroundEffects.animationFrame = null;
            console.log('‚úÖ Stopped animation frame');
        }

        // Clean up segmentation video element
        const segVideo = document.getElementById('video-segmentation');
        if (segVideo) {
            segVideo.srcObject = null;
            segVideo.remove();
            console.log('‚úÖ Segmentation video element removed');
        }

        // Clean up processing helper video element
        const processingVideo = document.getElementById('processing-video');
        if (processingVideo) {
            processingVideo.pause();
            processingVideo.srcObject = null;
            processingVideo.remove();
            console.log('‚úÖ Processing video element removed');
        }

        // Reset UI
        const noneRadio = document.getElementById('bgEffectNone');
        if (noneRadio) noneRadio.checked = true;
        this.updateSegmentationStatus('Deaktiviert');

        // Remove any remaining overlays from the live preview
        this.applyEffectToCompositionCanvas('none');

        // Ensure camera stays active and composition loop continues
        this.activeStreams.add('camera');
        this.checkCompositionReady();

        // Allow next activation to capture a fresh reference
        this.backgroundEffects.originalCameraStream = this.streams.get('camera');
        this.resetMaskCache('disable');
        this.backgroundEffects.lastSegmentationResults = null;

        console.log('‚úÖ Background effects disabled');
    }
    
    onStreamUpdate(type, newStream) {
        console.log(`üîÑ Stream update for ${type}:`, newStream);

        try {
            // Clear cached video element before updating
            if (this.videoElements.has(type)) {
                this.videoElements.delete(type);
                console.log(`üóëÔ∏è Cleared cached video element for ${type}`);
            }

            // Update the main video element for this stream type
            let videoElement = document.getElementById(`video-${type}`);
            if (!videoElement && newStream) {
                videoElement = document.createElement('video');
                videoElement.id = `video-${type}`;
                videoElement.autoplay = true;
                videoElement.muted = true;
                videoElement.playsInline = true;
                videoElement.style.display = 'none';
                videoElement.style.position = 'absolute';
                videoElement.style.top = '-9999px';
                document.body.appendChild(videoElement);
                console.log(`üÜï Created hidden video element for ${type}`);
            }
            if (videoElement) {
                videoElement.srcObject = newStream;
                console.log(`‚úÖ Updated video-${type} with new stream`);

                const markReady = () => {
                    this.videoElements.set(type, videoElement);
                    this.needsCanvasRefresh = true;
                    if (!this.isComposing && this.activeStreams.size > 0) {
                        this.startRenderLoop();
                    }
                };

                if (videoElement.readyState >= 2) {
                    markReady();
                } else {
                    videoElement.addEventListener('loadedmetadata', () => {
                        markReady();
                    }, { once: true });
                }

                const playPromise = videoElement.play();
                if (playPromise && typeof playPromise.catch === 'function') {
                    playPromise.catch(err => {
                        console.warn(`‚ö†Ô∏è Autoplay retry required for video-${type}:`, err);
                        const resumePlayback = () => {
                            videoElement.play().catch(() => {});
                            document.removeEventListener('click', resumePlayback);
                        };
                        document.addEventListener('click', resumePlayback, { once: true });
                    });
                }
            }
            
            // Force canvas refresh for next frame
            this.needsCanvasRefresh = true;
            
            // Update PiP if it's currently active for this stream
            if (type === 'camera' && this.pipVideo && !this.pipVideo.paused) {
                console.log('üîÑ Updating PiP video with new stream');
                this.pipVideo.srcObject = newStream;
            }
            
            console.log(`‚úÖ Stream update complete for ${type}`);
            
        } catch (error) {
            console.error(`‚ùå Failed to update stream for ${type}:`, error);
        }
    }
    
    updateSegmentationStatus(status) {
        const statusEl = document.getElementById('segmentationStatus');
        if (statusEl) {
            statusEl.textContent = status;
        }
    }

    checkBrowserSupport() {
        console.log('üîç Starting Browser Support Check...');
        
        const support = {
            getUserMedia: !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia),
            getDisplayMedia: !!(navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia),
            canvas: !!(this.canvas && this.ctx),
            mediaRecorder: !!(window.MediaRecorder)
        };
        
        // Mit setTimeout sicherstellen, dass DOM-Elemente bereit sind
        setTimeout(() => {
            try {
                // System Information elements removed from UI - only log to console
                const browserInfo = this.getBrowserInfo();
                const webrtcStatus = support.getUserMedia && support.getDisplayMedia ? '‚úì Unterst√ºtzt' : '‚ùå Nicht verf√ºgbar';
                const canvasStatus = support.canvas ? '‚úì Verf√ºgbar' : '‚ùå Fehler';
                const recorderStatus = support.mediaRecorder ? '‚úì Verf√ºgbar' : '‚ùå Nicht unterst√ºtzt';
                
                console.log('üåê Browser:', browserInfo);
                console.log('üîß WebRTC:', webrtcStatus);
                console.log('üé® Canvas:', canvasStatus);
                console.log('üìπ MediaRecorder:', recorderStatus);
                console.log('üìä Browser Support Check abgeschlossen');
            } catch (error) {
                console.error('‚ùå Fehler beim Aktualisieren der System Info:', error);
            }
        }, 100); // 100ms Verz√∂gerung f√ºr DOM-Bereitschaft
        
        console.log('üîç Browser Support:', support);
        return support;
    }
    
    getBrowserInfo() {
        const ua = navigator.userAgent;
        
        if (ua.includes('Firefox')) {
            const version = ua.match(/Firefox\/(\d+)/)?.[1];
            return `Firefox ${version || '?'}`;
        } else if (ua.includes('Chrome') && !ua.includes('Edge')) {
            const version = ua.match(/Chrome\/(\d+)/)?.[1];
            return `Chrome ${version || '?'}`;
        } else if (ua.includes('Safari') && !ua.includes('Chrome')) {
            const version = ua.match(/Safari\/(\d+)/)?.[1];
            return `Safari ${version || '?'}`;
        } else if (ua.includes('Edge')) {
            const version = ua.match(/Edge\/(\d+)/)?.[1];
            return `Edge ${version || '?'}`;
        } else {
            return 'Unbekannt';
        }
    }

    getBrowserInfo() {
        const ua = navigator.userAgent;
        if (ua.includes('Chrome')) return 'Chrome';
        if (ua.includes('Firefox')) return 'Firefox';
        if (ua.includes('Safari')) return 'Safari';
        if (ua.includes('Edge')) return 'Edge';
        return 'Unbekannt';
    }

    async startCamera() {
        try {
            this.updateStatus('camera', 'Kamera wird gestartet...', 'info');
            
            // Get selected camera device
            const cameraSelect = document.getElementById('cameraSelect');
            const videoDeviceId = cameraSelect ? cameraSelect.value : undefined;
            
            // Get audio processing settings from UI with selected microphone
            const audioConstraints = this.getAudioConstraints();
            
            // Build video constraints with selected camera
            // WICHTIG: Full HD f√ºr beste Qualit√§t + min frameRate f√ºr fl√ºssige Aufnahme
            const videoConstraints = {
                width: { ideal: 1920, min: 1280 },
                height: { ideal: 1080, min: 720 },
                frameRate: { min: 24, ideal: this.targetFPS, max: 60 }
            };
            
            // Add specific device if selected
            if (videoDeviceId) {
                videoConstraints.deviceId = { exact: videoDeviceId };
            }
            
            const stream = await navigator.mediaDevices.getUserMedia({
                video: videoConstraints,
                audio: audioConstraints
            });

            this.streams.set('camera', stream);
            this.activeStreams.add('camera');
            this.streamOrder.push('camera'); // Add to order for z-index
            this.streamDisplayModes.set('camera', 'cover'); // Default for camera
            this.streamMirror.set('camera', false); // Default: not mirrored

            // Show camera options panel
            const cameraOptionsPanel = document.getElementById('cameraOptionsPanel');
            if (cameraOptionsPanel) {
                cameraOptionsPanel.style.display = 'block';
                // Set default values
                const displayModeSelect = document.getElementById('cameraDisplayMode');
                const mirrorToggle = document.getElementById('cameraMirrorToggle');
                if (displayModeSelect) displayModeSelect.value = 'cover';
                if (mirrorToggle) mirrorToggle.checked = false;
            }

            this.updateStatus('camera', 'Aktiv', 'success');
            this.updateButtons('camera', true);
            this.updateStatusBadge('camera', 'success');
            this.addStreamThumbnail('camera', stream);
            this.checkCompositionReady();
            this.updateActiveStreamsCount();
            this.refreshLayoutChips();
            this.checkAudioStream(); // Check audio status after stream added

            console.log('‚úÖ Kamera-Stream erfolgreich gestartet');
        } catch (error) {
            console.error('‚ùå Kamera-Zugriff fehlgeschlagen:', error);
            this.updateStatus('camera', `Fehler: ${error.message}`, 'danger');
            this.updateStatusBadge('camera', 'danger');
        }
    }

    async startScreen() {
        this.nextScreenId = 1; // Initialize screen counter
        return this.addScreen();
    }

    async addScreen() {
        try {
            // Check if we're on a mobile device
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            if (isMobile) {
                this.updateStatus('screen', 'Bildschirm-Sharing ist auf Mobilger√§ten nicht verf√ºgbar', 'danger');
                this.updateStatusBadge('screen', 'danger');
                console.log('üì± Bildschirm-Sharing auf Mobilger√§t versucht');
                return;
            }

            // Check if getDisplayMedia is available
            if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia) {
                this.updateStatus('screen', 'Bildschirm-Sharing wird von diesem Browser nicht unterst√ºtzt', 'danger');
                this.updateStatusBadge('screen', 'danger');
                console.log('‚ùå getDisplayMedia nicht verf√ºgbar');
                return;
            }

            const screenId = `screen${this.nextScreenId}`;
            this.updateStatus('screen', 'Bildschirm-Sharing wird gestartet...', 'info');
            
            // Get audio processing settings from UI
            const audioConstraints = this.getAudioConstraints();
            
            // WICHTIG: min frameRate f√ºr fl√ºssige Aufnahme
            const stream = await navigator.mediaDevices.getDisplayMedia({
                video: {
                    width: { ideal: 1920, min: 1280 },
                    height: { ideal: 1080, min: 720 },
                    frameRate: { min: 24, ideal: this.targetFPS, max: 60 },
                    cursor: 'always'
                },
                audio: audioConstraints
            });

            this.streams.set(screenId, stream);
            this.streamOrder.push(screenId); // Add to order for z-index
            this.nextScreenId++;

            // Update UI based on number of screens
            const screenCount = Array.from(this.streams.keys()).filter(k => k.startsWith('screen')).length;
            this.updateStatus('screen', `${screenCount} Bildschirm(e) aktiv`, 'success');
            this.updateScreenButtons();
            this.updateStatusBadge('screen', 'success');
            this.addStreamThumbnail(screenId, stream);
            this.updateScreensList();
            this.checkCompositionReady();
            this.updateActiveStreamsCount();
            this.refreshLayoutChips();
            this.checkAudioStream(); // Check audio status after stream added

            // Handle screen sharing end event
            stream.getVideoTracks()[0].addEventListener('ended', () => {
                this.removeScreen(screenId);
            });

            console.log(`‚úÖ Bildschirm-Stream ${screenId} erfolgreich gestartet`);
        } catch (error) {
            console.error('‚ùå Bildschirm-Capture fehlgeschlagen:', error);
            this.updateStatus('screen', `Fehler: ${error.message}`, 'danger');
            this.updateStatusBadge('screen', 'danger');
        }
    }

    stopCamera() {
        const stream = this.streams.get('camera');
        if (stream) {
            stream.getTracks().forEach(track => track.stop());
            this.streams.delete('camera');
            this.streamOrder = this.streamOrder.filter(k => k !== 'camera'); // Remove from order
            this.streamPositions.delete('camera'); // Remove position data
            this.streamMirror.delete('camera'); // Remove mirror state
            this.cleanupVideoElement('camera');

            // Hide camera options panel
            const cameraOptionsPanel = document.getElementById('cameraOptionsPanel');
            if (cameraOptionsPanel) {
                cameraOptionsPanel.style.display = 'none';
            }

            this.updateStatus('camera', 'Nicht aktiv', 'secondary');
            this.updateButtons('camera', false);
            this.updateStatusBadge('camera', 'secondary');
            this.removeStreamThumbnail('camera');
            this.updateActiveStreamsCount();
            this.refreshLayoutChips();
            this.checkCompositionReady();
        }
    }

    removeScreen(screenId) {
        const stream = this.streams.get(screenId);
        if (stream) {
            stream.getTracks().forEach(track => track.stop());
            this.streams.delete(screenId);
            this.streamOrder = this.streamOrder.filter(k => k !== screenId); // Remove from order
            this.streamPositions.delete(screenId); // Remove position data
            this.cleanupVideoElement(screenId);
            this.removeStreamThumbnail(screenId);
            this.updateScreenStatus();
            this.updateScreenButtons();
            this.updateScreensList();
            this.updateActiveStreamsCount();
            this.refreshLayoutChips();
            this.checkCompositionReady();
        }
    }

    stopAllScreens() {
        const screenIds = Array.from(this.streams.keys()).filter(k => k.startsWith('screen'));
        screenIds.forEach(screenId => this.removeScreen(screenId));
    }

    updateScreenStatus() {
        const screenCount = Array.from(this.streams.keys()).filter(k => k.startsWith('screen')).length;
        if (screenCount === 0) {
            this.updateStatus('screen', 'Nicht aktiv', 'secondary');
            this.updateStatusBadge('screen', 'secondary');
        } else {
            this.updateStatus('screen', `${screenCount} Bildschirm(e) aktiv`, 'success');
            this.updateStatusBadge('screen', 'success');
        }
    }

    updateScreenButtons() {
        const screenCount = Array.from(this.streams.keys()).filter(k => k.startsWith('screen')).length;
        const startBtn = document.getElementById('startScreenBtn');
        const addBtn = document.getElementById('addScreenBtn');
        const stopAllBtn = document.getElementById('stopAllScreensBtn');
        
        // Disable "Bildschirm teilen" button when any screen is active
        if (startBtn) startBtn.disabled = screenCount > 0;
        
        if (addBtn) addBtn.disabled = false; // Always allow adding more screens
        if (stopAllBtn) stopAllBtn.disabled = screenCount === 0;
    }

    updateScreensList() {
        const screenIds = Array.from(this.streams.keys()).filter(k => k.startsWith('screen'));
        const activeScreensDiv = document.getElementById('activeScreens');
        const listDiv = document.getElementById('screenStreamsList');
        
        if (screenIds.length > 0) {
            activeScreensDiv.style.display = 'block';
            listDiv.innerHTML = screenIds.map(screenId => {
                const currentMode = this.streamDisplayModes.get(screenId) || 'cover';
                return `
                <div class="bg-light rounded p-2 mb-2" style="font-size: 0.8rem;">
                    <div class="d-flex justify-content-between align-items-center mb-1">
                        <div class="d-flex align-items-center">
                            <i class="fas fa-desktop me-2 text-primary"></i>
                            <span class="fw-medium">${screenId === 'screen1' ? 'Bildschirm 1' : screenId.replace('screen', 'Bildschirm ')}</span>
                        </div>
                        <button class="btn btn-sm btn-outline-danger py-0 px-1" onclick="streamrecApp.removeScreen('${screenId}')" style="font-size: 0.7rem;">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <div class="d-flex align-items-center">
                        <label class="form-label mb-0 me-2 text-muted" style="font-size: 0.7rem;">Modus:</label>
                        <select class="form-select form-select-sm" style="width: 90px; font-size: 0.7rem;" 
                                onchange="streamrecApp.setStreamDisplayMode('${screenId}', this.value)">
                            <option value="cover" ${currentMode === 'cover' ? 'selected' : ''}>F√ºllen</option>
                            <option value="contain" ${currentMode === 'contain' ? 'selected' : ''}>Anpassen</option>
                            <option value="fill" ${currentMode === 'fill' ? 'selected' : ''}>Schneiden</option>
                            <option value="crop" ${currentMode === 'crop' ? 'selected' : ''}>Zentriert</option>
                        </select>
                    </div>
                </div>
                `;
            }).join('');
        } else {
            activeScreensDiv.style.display = 'none';
        }
    }

    startRenderLoop() {
        if (this.streams.size === 0) {
            console.log('‚è∏Ô∏è Keine Streams verf√ºgbar - warte auf Streams');
            return;
        }
        
        this.isComposing = true;
        this.renderComposition();
        console.log('‚úÖ Rendering Loop gestartet');
    }

    stopRenderLoop() {
        this.isComposing = false;
        
        if (this.animationFrame) {
            cancelAnimationFrame(this.animationFrame);
        }
        
        this.clearCanvas();
        console.log('üõë Rendering Loop gestoppt');
    }

    // üöÄ OPTIMIZED RENDERING ENGINE
    renderComposition() {
        if (!this.isComposing) return;

        const now = performance.now();
        const elapsed = now - this.lastRenderTime;
        
        // üéØ FRAME-RATE KONTROLLE: Nur rendern wenn Frame-Intervall erreicht
        if (elapsed >= this.frameInterval) {
            const renderStart = performance.now();
            
            // Frame Skip Logic bei Performance-Problemen
            if (!this.enableFrameSkipping || this.skipFrameCount < this.maxSkipFrames || elapsed >= this.frameInterval * 2) {
                this.clearCanvas();
                const hasValidStreams = this.renderCurrentLayout();
                
                // Nur rendern wenn g√ºltige Streams vorhanden
                if (hasValidStreams) {
                    this.updateRecordingIndicator();
                    this.skipFrameCount = 0;
                } else if (this.enableFrameSkipping) {
                    this.skipFrameCount++;
                }
                
                this.lastRenderTime = now;
                this.updatePerformanceMetrics(performance.now() - renderStart);
            } else if (this.enableFrameSkipping) {
                this.skipFrameCount++;
                this.performanceMetrics.droppedFrames++;
            }
        }
        
        this.animationFrame = requestAnimationFrame(() => this.renderComposition());
    }

    renderCurrentLayout() {
        // Only render active streams
        const allStreams = Array.from(this.streams.entries());
        const activeStreams = allStreams.filter(([type, stream]) => this.activeStreams.has(type));
        let hasValidStreams = false;
        
        // üîç Vorab-Check: Mindestens ein aktiver Stream bereit?
        for (const [type, stream] of activeStreams) {
            const video = this.getVideoElementOptimized(type, stream);
            if (video && video.readyState >= 2 && !video.paused) {
                hasValidStreams = true;
                break;
            }
        }
        
        if (!hasValidStreams) {
            return false; // Kein g√ºltiger Stream
        }
        
        try {
            switch (this.currentLayout) {
                case 'fullscreen':
                    this.renderFullscreen(activeStreams);
                    break;
                case 'pip':
                    this.renderPictureInPicture(activeStreams);
                    break;
                case 'side':
                    this.renderSideBySide(activeStreams);
                    break;
                case 'stack':
                    this.renderStacked(activeStreams);
                    break;
                case 'threeCols':
                    this.renderThreeColumns(activeStreams);
                    break;
                case 'leftBigRight2':
                    this.renderLeftBigRightTwo(activeStreams);
                    break;
                case 'grid2x2':
                    this.renderGrid2x2(activeStreams);
                    break;
                case 'free':
                    this.renderFreeLayout(activeStreams);
                    break;
                default:
                    // Default: Intelligente Auswahl basierend auf Stream-Anzahl
                    this.renderSmartDefault(activeStreams);
            }
            
            // üéØ Draw grid overlay if enabled
            if (this.showGrid) {
                this.drawGrid();
            }
            
            return true;
        } catch (error) {
            console.warn('‚ö†Ô∏è Render error:', error);
            if (this.enableErrorRecovery) {
                this.handleRenderError(error);
            }
            return false;
        }
    }

    renderPictureInPicture(streams) {
        if (streams.length < 2) {
            // Falls weniger als 2 Streams, Vollbild verwenden
            this.renderFullscreen(streams);
            return;
        }

        const map = new Map(streams);
        
        // Background: prefer any screen stream, fallback to first stream
        let bgEntry = null;
        // Find first screen stream (screen1, screen2, etc.)
        for (const [type, stream] of streams) {
            if (type.startsWith('screen')) {
                bgEntry = [type, stream];
                break;
            }
        }
        // If no screen stream found, use first stream
        if (!bgEntry) {
            bgEntry = streams[0];
        }
        
        // Draw background stream with its display mode
        if (bgEntry) {
            const [bgType, bgStream] = bgEntry;
            const bgVideo = this.getVideoElementOptimized(bgType, bgStream);
            if (bgVideo && bgVideo.readyState >= 2) {
                this.drawVideoWithMode(bgVideo, bgType, 0, 0, this.canvas.width, this.canvas.height);
            }
        }

        // Overlay: Find overlay stream (prefer camera, but exclude background stream)
        let overlayEntry = null;
        if (map.has('camera') && bgEntry[0] !== 'camera') {
            overlayEntry = ['camera', map.get('camera')];
        } else {
            // Use first stream that's not the background
            for (const [type, stream] of streams) {
                if (type !== bgEntry[0]) {
                    overlayEntry = [type, stream];
                    break;
                }
            }
        }

        // Draw overlay stream with customizable PIP settings
        if (overlayEntry) {
            const [overlayType, overlayStream] = overlayEntry;
            const overlayVideo = this.getVideoElementOptimized(overlayType, overlayStream);
            if (overlayVideo && overlayVideo.readyState >= 2) {
                console.log('üé¨ PIP Settings:', this.pipSettings); // Debug log
                
                // Calculate PIP size based on percentage
                const sizePercentage = this.pipSettings.size / 100;
                const pipWidth = this.canvas.width * sizePercentage;
                const pipHeight = this.canvas.height * sizePercentage;
                
                // Use stored x/y coordinates, with fallback to top-right
                if (this.pipSettings.x === 0 && this.pipSettings.y === 0) {
                    // Initialize position to top-right corner if not set yet
                    this.pipSettings.x = this.canvas.width - pipWidth - this.pipSettings.padding;
                    this.pipSettings.y = this.pipSettings.padding;
                }
                
                let x = this.pipSettings.x;
                let y = this.pipSettings.y;
                
                // Ensure PIP stays within bounds (in case canvas size changed)
                x = Math.max(0, Math.min(this.canvas.width - pipWidth, x));
                y = Math.max(0, Math.min(this.canvas.height - pipHeight, y));
                
                // Update stored position if it was constrained
                this.pipSettings.x = x;
                this.pipSettings.y = y;
                
                console.log(`üìê PIP Size: ${this.pipSettings.size}%, Shape: ${this.pipSettings.shape}`);
                console.log(`üìç PIP Position: x=${x}, y=${y}, w=${pipWidth}, h=${pipHeight}`);
                
                // Draw based on shape setting
                if (this.pipSettings.shape === 'circle') {
                    // Save context state
                    this.ctx.save();
                    
                    // Create circular clipping path
                    const centerX = x + pipWidth / 2;
                    const centerY = y + pipHeight / 2;
                    const radius = Math.min(pipWidth, pipHeight) / 2;
                    
                    this.ctx.beginPath();
                    this.ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                    this.ctx.closePath();
                    this.ctx.clip();
                    
                    // Draw video in circular area
                    const squareSize = radius * 2;
                    const squareX = centerX - radius;
                    const squareY = centerY - radius;
                    this.drawVideoWithMode(overlayVideo, overlayType, squareX, squareY, squareSize, squareSize);
                    
                    // Restore context and draw border
                    this.ctx.restore();
                    
                    // Draw circular border
                    this.ctx.strokeStyle = '#ffffff';
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                    this.ctx.stroke();
                    
                } else {
                    // Square/Rectangle shape (default)
                    // Draw PIP with frame
                    this.ctx.strokeStyle = '#ffffff';
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeRect(x - 1, y - 1, pipWidth + 2, pipHeight + 2);
                    
                    // Draw video content with display mode
                    this.drawVideoWithMode(overlayVideo, overlayType, x, y, pipWidth, pipHeight);
                }
            }
        }
    }

    renderSideBySide(streams) {
        const streamArray = Array.from(streams);
        const streamCount = streamArray.length;
        
        if (streamCount === 0) return;
        
        // üéØ QUALITY OPTIMIZATION: Adaptive rendering quality
        const qualitySettings = this.getAdaptiveRenderingSettings(streamCount);
        const streamWidth = this.canvas.width / streamCount;
        
        streamArray.forEach(([type, stream], index) => {
            const video = this.getVideoElementOptimized(type, stream);
            if (!video || video.readyState < 2) return;
            
            // üöÄ Apply quality optimizations before rendering
            this.applyVideoQualitySettings(video, qualitySettings);
            
            const x = index * streamWidth;
            this.drawVideoWithMode(video, type, x, 0, streamWidth, this.canvas.height);
            
            // Draw separator (except for last stream)
            if (index < streamCount - 1) {
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(x + streamWidth, 0);
                this.ctx.lineTo(x + streamWidth, this.canvas.height);
                this.ctx.stroke();
            }
        });
    }

    renderFullscreen(streams) {
        // Vollbild: Ersten verf√ºgbaren Stream verwenden
        const streamArray = Array.from(streams);
        if (streamArray.length === 0) return;
        
        const [type, stream] = streamArray[0];
        const video = this.getVideoElementOptimized(type, stream);
        if (video && video.readyState >= 2) {
            this.drawVideoWithMode(video, type, 0, 0, this.canvas.width, this.canvas.height);
        }
    }

    renderStacked(streams) {
        // Gestapelt: Streams √ºbereinander
        const streamArray = Array.from(streams).slice(0, 2);
        const halfHeight = this.canvas.height / 2;
        
        streamArray.forEach(([type, stream], index) => {
            const video = this.getVideoElementOptimized(type, stream);
            if (!video || video.readyState < 2) return;
            
            const y = index * halfHeight;
            this.drawVideoWithMode(video, type, 0, y, this.canvas.width, halfHeight);
            
            // Draw separator
            if (index === 0 && streamArray.length > 1) {
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(0, halfHeight);
                this.ctx.lineTo(this.canvas.width, halfHeight);
                this.ctx.stroke();
            }
        });
    }

    renderThreeColumns(streams) {
        // 3 Spalten Layout
        const streamArray = Array.from(streams).slice(0, 3);
        const colWidth = this.canvas.width / 3;
        
        streamArray.forEach(([type, stream], index) => {
            const video = this.getVideoElementOptimized(type, stream);
            if (!video || video.readyState < 2) return;
            
            const x = index * colWidth;
            this.drawVideoContain(video, x, 0, colWidth, this.canvas.height);
            
            // Draw separators
            if (index < streamArray.length - 1) {
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(x + colWidth, 0);
                this.ctx.lineTo(x + colWidth, this.canvas.height);
                this.ctx.stroke();
            }
        });
    }

    renderLeftBigRightTwo(streams) {
        // Links gro√ü, rechts zwei kleine
        const streamArray = Array.from(streams).slice(0, 3);
        if (streamArray.length === 0) return;
        
        const leftWidth = this.canvas.width * 0.6;
        const rightWidth = this.canvas.width * 0.4;
        const rightHalfHeight = this.canvas.height / 2;
        
        // Linker gro√üer Stream
        const [mainType, mainStream] = streamArray[0];
        const mainVideo = this.getVideoElementOptimized(mainType, mainStream);
        if (mainVideo && mainVideo.readyState >= 2) {
            this.drawVideoContain(mainVideo, 0, 0, leftWidth, this.canvas.height);
        }
        
        // Rechte zwei kleinere Streams
        streamArray.slice(1, 3).forEach(([type, stream], index) => {
            const video = this.getVideoElementOptimized(type, stream);
            if (!video || video.readyState < 2) return;
            
            const y = index * rightHalfHeight;
            this.drawVideoContain(video, leftWidth, y, rightWidth, rightHalfHeight);
        });
        
        // Separators
        this.ctx.strokeStyle = '#fff';
        this.ctx.lineWidth = 2;
        // Vertical separator
        this.ctx.beginPath();
        this.ctx.moveTo(leftWidth, 0);
        this.ctx.lineTo(leftWidth, this.canvas.height);
        this.ctx.stroke();
        // Horizontal separator (rechts)
        if (streamArray.length > 2) {
            this.ctx.beginPath();
            this.ctx.moveTo(leftWidth, rightHalfHeight);
            this.ctx.lineTo(this.canvas.width, rightHalfHeight);
            this.ctx.stroke();
        }
    }

    renderGrid2x2(streams) {
        // 2x2 Raster Layout
        const streamArray = Array.from(streams).slice(0, 4);
        const halfWidth = this.canvas.width / 2;
        const halfHeight = this.canvas.height / 2;
        
        const positions = [
            { x: 0, y: 0 },                    // Top-left
            { x: halfWidth, y: 0 },             // Top-right
            { x: 0, y: halfHeight },            // Bottom-left
            { x: halfWidth, y: halfHeight }     // Bottom-right
        ];
        
        streamArray.forEach(([type, stream], index) => {
            const video = this.getVideoElementOptimized(type, stream);
            if (!video || video.readyState < 2) return;
            
            const pos = positions[index];
            this.drawVideoContain(video, pos.x, pos.y, halfWidth, halfHeight);
        });
        
        // Draw grid separators
        this.ctx.strokeStyle = '#fff';
        this.ctx.lineWidth = 2;
        // Vertical separator
        this.ctx.beginPath();
        this.ctx.moveTo(halfWidth, 0);
        this.ctx.lineTo(halfWidth, this.canvas.height);
        this.ctx.stroke();
        // Horizontal separator
        this.ctx.beginPath();
        this.ctx.moveTo(0, halfHeight);
        this.ctx.lineTo(this.canvas.width, halfHeight);
        this.ctx.stroke();
    }

    renderSmartDefault(streams) {
        // Intelligente Standard-Auswahl basierend auf Stream-Anzahl
        const count = streams.length;
        
        if (count === 1) {
            this.renderFullscreen(streams);
        } else if (count === 2) {
            this.renderPictureInPicture(streams);
        } else if (count === 3) {
            this.renderLeftBigRightTwo(streams);
        } else if (count >= 4) {
            this.renderGrid2x2(streams);
        }
    }

    // üöÄ OPTIMIZED: Video Element Pool Management
    getVideoElementOptimized(type, stream) {
        // üöÄ KRITISCH: Bei Kamera mit Hintergrund-Effekten das verarbeitete Video verwenden!
        if (type === 'camera' && this.backgroundEffects.enabled &&
            this.backgroundEffects.mode !== 'none' && this.backgroundEffects.segmentationCanvas) {

            // Nutze das verarbeitete Video vom segmentationCanvas
            const segVideo = document.getElementById('video-segmentation');
            if (segVideo && segVideo.readyState >= 2) {
                return segVideo;
            }

            // Fallback: Erstelle Video-Element vom segmentationCanvas Stream
            if (this.backgroundEffects.canvasStream) {
                let processedVideo = document.getElementById('video-processed-camera');
                if (!processedVideo) {
                    processedVideo = document.createElement('video');
                    processedVideo.id = 'video-processed-camera';
                    processedVideo.autoplay = true;
                    processedVideo.muted = true;
                    processedVideo.playsInline = true;
                    processedVideo.style.display = 'none';
                    document.body.appendChild(processedVideo);
                }
                if (processedVideo.srcObject !== this.backgroundEffects.canvasStream) {
                    processedVideo.srcObject = this.backgroundEffects.canvasStream;
                    processedVideo.play().catch(() => {});
                }
                if (processedVideo.readyState >= 2) {
                    return processedVideo;
                }
            }
        }

        // 1. Check pool first (Performance)
        if (this.videoElements.has(type)) {
            const video = this.videoElements.get(type);
            if (video.srcObject === stream && video.readyState >= 2) {
                return video;
            }
        }
        
        // 2. Check existing video element
        let video = document.getElementById(`video-${type}`);
        if (video && video.srcObject === stream) {
            if (video.readyState >= 2) {
                this.videoElements.set(type, video);
                return video;
            }
            return null; // Video not ready yet
        }
        
        // 3. Create new video element (last resort)
        if (!video) {
            video = document.createElement('video');
            video.id = `video-${type}`;
            video.autoplay = true;
            video.muted = true;
            video.playsInline = true;
            video.style.display = 'none';
            video.style.position = 'absolute';
            video.style.top = '-9999px';
            document.body.appendChild(video);
            
            // üéØ PERFORMANCE: Only set if necessary
            if (video.srcObject !== stream) {
                video.srcObject = stream;
            }
            
            // Optimized playback start
            const initVideo = async () => {
                try {
                    if (video.readyState >= 2) {
                        await video.play();
                        this.videoElements.set(type, video);
                    } else {
                        video.addEventListener('loadedmetadata', async () => {
                            try {
                                await video.play();
                                this.videoElements.set(type, video);
                            } catch (err) {
                                console.warn('Video play failed:', err);
                            }
                        }, { once: true });
                    }
                } catch (err) {
                    console.warn('Video init failed:', err);
                }
            };
            
            initVideo();
            return null; // Not ready immediately
        }
        
        return video.readyState >= 2 ? video : null;
    }

    cleanupVideoElement(type) {
        if (this.videoElements.has(type)) {
            this.videoElements.delete(type);
        }
        
        const video = document.getElementById(`video-${type}`);
        if (video) {
            video.srcObject = null;
            video.remove();
        }
    }

    // Helper: draw video preserving aspect ratio (contain)
    drawVideoContain(video, dx, dy, dw, dh) {
        // WICHTIG: IMMER das normale Video zeichnen
        // Green Screen Effekt wird in onSegmentationResults angewendet
        // Niemals das segmentationCanvas hier direkt zeichnen!
        if (false) { // Diese Bedingung absichtlich deaktiviert

            // Draw the segmentation canvas instead of the video
            const canvas = this.backgroundEffects.segmentationCanvas;
            const vw = canvas.width;
            const vh = canvas.height;
            const videoAspect = vw / vh;
            const targetAspect = dw / dh;
            
            let renderW, renderH, x, y;
            if (videoAspect > targetAspect) {
                renderW = dw;
                renderH = dw / videoAspect;
                x = dx;
                y = dy + (dh - renderH) / 2;
            } else {
                renderH = dh;
                renderW = dh * videoAspect;
                x = dx + (dw - renderW) / 2;
                y = dy;
            }
            
            this.ctx.drawImage(canvas, x, y, renderW, renderH);
            return;
        }
        
        // Normal video handling
        const vw = video.videoWidth || video.width || 16;
        const vh = video.videoHeight || video.height || 9;
        const videoAspect = vw / vh;
        const targetAspect = dw / dh;
        
        let renderW, renderH, x, y;
        if (videoAspect > targetAspect) {
            renderW = dw;
            renderH = dw / videoAspect;
            x = dx;
            y = dy + (dh - renderH) / 2;
        } else {
            renderH = dh;
            renderW = dh * videoAspect;
            x = dx + (dw - renderW) / 2;
            y = dy;
        }
        
        this.ctx.drawImage(video, x, y, renderW, renderH);
    }

    // Helper: draw video covering target rect (cover) with cropping
    drawVideoCover(video, dx, dy, dw, dh) {
        // WICHTIG: IMMER das normale Video zeichnen
        // Green Screen Effekt wird in onSegmentationResults angewendet
        // Niemals das segmentationCanvas hier direkt zeichnen!

        // Normal video handling
        const vw = video.videoWidth || video.width || 16;
        const vh = video.videoHeight || video.height || 9;
        const videoAspect = vw / vh;
        const targetAspect = dw / dh;
        
        let sx = 0, sy = 0, sw = vw, sh = vh;
        if (videoAspect > targetAspect) {
            sw = vh * targetAspect;
            sx = (vw - sw) / 2;
        } else {
            sh = vw / targetAspect;
            sy = (vh - sh) / 2;
        }
        
        this.ctx.drawImage(video, sx, sy, sw, sh, dx, dy, dw, dh);
    }

    clearCanvas() {
        // üöÄ PERFORMANCE: Only clear when necessary
        this.ctx.fillStyle = '#000000';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Show/hide no content overlay
        const hasStreams = this.streams.size > 0;
        document.getElementById('noContentOverlay').style.display = hasStreams ? 'none' : 'block';
    }

    // Recording Methods
    startRecordingWithCountdown() {
        if (!this.isComposing) {
            alert('Bitte starten Sie zuerst die Live-Komposition');
            return;
        }
        
        const overlay = document.getElementById('countdownOverlay');
        const num = document.getElementById('countdownNumber');
        if (!overlay || !num) return this.startRecording();
        
        let n = 3;
        num.textContent = n;
        overlay.style.display = 'block';
        
        const interval = setInterval(() => {
            n -= 1;
            if (n === 0) {
                clearInterval(interval);
                overlay.style.display = 'none';
                this.startRecording();
            } else {
                num.textContent = n;
            }
        }, 700);
    }

    startRecording() {
        if (!this.isComposing) {
            alert('Bitte starten Sie zuerst die Live-Komposition');
            return;
        }

        // Choose recording method based on output mode
        if (this.outputMode === 'separate') {
            this.startSeparateStreamRecording();
        } else {
            this.startMergedRecording();
        }
    }

    startMergedRecording() {
        try {
            // üéØ OPTIMIZED: Adaptive frame rate based on browser
            const targetFPS = this.getBrowserOptimalFPS();
            const canvasStream = this.canvas.captureStream(targetFPS);
            
            // üé§ Combine with audio streams if audio is enabled
            const audioEnabled = document.getElementById('audioEnabled')?.checked;
            let finalStream = canvasStream;
            
        if (audioEnabled) {
            const combinedStream = new MediaStream();
            canvasStream.getVideoTracks().forEach(track => {
                combinedStream.addTrack(track);
            });

            let audioAttached = false;
            const AudioCtor = window.AudioContext || window.webkitAudioContext;

            if (AudioCtor) {
                let audioContext = null;
                let destination = null;
                const audioSources = [];
                const attachSourceFromStream = (stream, sourceId = 'source') => {
                    if (!stream) return false;
                    const audioTracks = stream.getAudioTracks().filter(track => track && track.readyState === 'live');
                    if (audioTracks.length === 0) {
                        return false;
                    }
                    if (!audioContext) {
                        audioContext = new AudioCtor();
                        destination = audioContext.createMediaStreamDestination();
                    }
                    audioTracks.forEach(track => {
                        const trackStream = new MediaStream([track]);
                        const sourceNode = audioContext.createMediaStreamSource(trackStream);

                        // üéµ Apply audio sync offset with DelayNode
                        const syncOffsetMs = this.audioSyncOffset || 0;

                        if (syncOffsetMs > 0) {
                            // Positive offset: delay audio (audio comes LATER)
                            const delaySeconds = syncOffsetMs / 1000;
                            const delayNode = audioContext.createDelay(1.0); // Max 1 second delay
                            delayNode.delayTime.value = Math.min(delaySeconds, 1.0);
                            sourceNode.connect(delayNode);
                            delayNode.connect(destination);
                            console.log(`üéµ Audio-Sync (sp√§ter): +${syncOffsetMs}ms (Delay: ${delaySeconds.toFixed(3)}s)`);
                        } else if (syncOffsetMs < 0) {
                            // Negative offset: delay video instead (audio comes EARLIER)
                            // For now, we use a base delay approach
                            const baseDelaySeconds = 0.5; // 500ms base delay on all audio
                            const adjustedDelaySeconds = Math.max(0, baseDelaySeconds + (syncOffsetMs / 1000));
                            const delayNode = audioContext.createDelay(1.0);
                            delayNode.delayTime.value = adjustedDelaySeconds;
                            sourceNode.connect(delayNode);
                            delayNode.connect(destination);
                            console.log(`üéµ Audio-Sync (fr√ºher): ${syncOffsetMs}ms (Base-Delay: ${baseDelaySeconds}s, Adjusted: ${adjustedDelaySeconds.toFixed(3)}s)`);
                        } else {
                            // No offset: direct connection
                            sourceNode.connect(destination);
                        }

                        audioSources.push({ node: sourceNode, stream: trackStream });
                        console.log(`üé§ Audio source connected from ${sourceId}`);
                    });
                    return true;
                };

                for (const [streamId, stream] of this.streams) {
                    attachSourceFromStream(stream, streamId);
                }

                if (this.backgroundEffects?.originalCameraStream) {
                    attachSourceFromStream(this.backgroundEffects.originalCameraStream, 'originalCamera');
                }

                if (this.backgroundEffects?.segmentationOriginStream) {
                    attachSourceFromStream(this.backgroundEffects.segmentationOriginStream, 'segmentationOrigin');
                }

                if (destination && destination.stream.getAudioTracks().length > 0) {
                    destination.stream.getAudioTracks().forEach(track => {
                        combinedStream.addTrack(track);
                    });
                    finalStream = combinedStream;
                    this.recordingAudioContext = audioContext;
                    this.recordingAudioDestination = destination;
                    this.recordingAudioSources = audioSources;
                    audioAttached = true;
                    console.log(`üé§ Audio-enabled recording (mixed): ${finalStream.getAudioTracks().length} audio tracks`);
                } else {
                    audioSources.forEach(({ node }) => {
                        try { node.disconnect(); } catch (err) { console.warn('Audio source disconnect failed', err); }
                    });
                    if (audioContext) {
                        audioContext.close().catch(() => {});
                    }
                    this.recordingAudioContext = null;
                    this.recordingAudioDestination = null;
                    this.recordingAudioSources = [];
                }
            }

            if (!audioAttached) {
                this.recordingAudioContext = null;
                this.recordingAudioDestination = null;
                this.recordingAudioSources = [];

                const addedAudioTrackIds = new Set();
                const addDirectAudioTracks = (stream, sourceId = 'source') => {
                    if (!stream) return;
                    stream.getAudioTracks().forEach(track => {
                        if (!track || track.readyState !== 'live' || addedAudioTrackIds.has(track.id)) {
                            return;
                        }
                        addedAudioTrackIds.add(track.id);
                        combinedStream.addTrack(track);
                        console.log(`üé§ Direct audio track added from ${sourceId}`);
                    });
                };

                for (const [streamId, stream] of this.streams) {
                    addDirectAudioTracks(stream, streamId);
                }

                if (this.backgroundEffects?.originalCameraStream) {
                    addDirectAudioTracks(this.backgroundEffects.originalCameraStream, 'originalCamera');
                }

                if (this.backgroundEffects?.segmentationOriginStream) {
                    addDirectAudioTracks(this.backgroundEffects.segmentationOriginStream, 'segmentationOrigin');
                }

                if (combinedStream.getAudioTracks().length > 0) {
                    finalStream = combinedStream;
                    audioAttached = true;
                    console.log(`üé§ Audio-enabled recording (direct): ${finalStream.getAudioTracks().length} audio tracks`);
                } else {
                    console.warn('‚ö†Ô∏è No active audio tracks found for recording');
                }
            }
        } else {
            console.log(`üîá Audio-disabled recording: video only`);
        }

        // üöÄ IMPROVED MediaRecorder configuration
            const options = this.getOptimalRecorderOptions();
            this.mediaRecorder = new MediaRecorder(finalStream, options);
            
            this.recordedChunks = [];
            this.pausedAccum = 0;
            this.pauseStart = null;

            console.log(`üìπ MediaRecorder gestartet: ${targetFPS}fps, ${options.videoBitsPerSecond}bps`);

            this.mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    this.recordedChunks.push(event.data);
                }
            };

            this.mediaRecorder.onstop = () => {
                // Create blob from recorded chunks (already in correct format from MediaRecorder)
                const blob = new Blob(this.recordedChunks, { type: this.mediaRecorder.mimeType });

                // Determine video type from blob
                const videoType = blob.type;

                // Debug: Log the actual format
                console.log(`üìπ Recording stopped. Format: ${videoType}, Size: ${(blob.size / 1024 / 1024).toFixed(2)} MB`);

                const url = URL.createObjectURL(blob);
                this.showPreviewModal(url, videoType);

                if (this.recordingAudioSources?.length) {
                    this.recordingAudioSources.forEach(({ node }) => {
                        try { node.disconnect(); } catch (error) { console.warn('Audio source disconnect error:', error); }
                    });
                    this.recordingAudioSources = [];
                }
                if (this.recordingAudioDestination) {
                    this.recordingAudioDestination.stream.getAudioTracks().forEach(track => track.stop());
                    this.recordingAudioDestination = null;
                }
                if (this.recordingAudioContext) {
                    this.recordingAudioContext.close().catch(() => {});
                    this.recordingAudioContext = null;
                }
                this.resetRecordingUI();
            };

            this.mediaRecorder.start();
            this.isRecording = true;
            this.recordingStartTime = Date.now();
            
            document.getElementById('recordBtn').disabled = true;
            document.getElementById('stopRecordBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = false;
            document.getElementById('recordingStatus').textContent = 'Status: Aufnahme l√§uft';
            document.getElementById('recordingIndicator').style.display = 'block';
            
            this.startRecordingTimer();
            console.log('üìπ Recording gestartet');

        } catch (error) {
            console.error('‚ùå Recording Fehler:', error);
            alert('Aufnahme-Fehler: ' + error.message);
        }
    }

    stopRecording() {
        if (this.outputMode === 'separate') {
            // Stop all separate recorders
            let stoppedCount = 0;
            for (const [streamType, recorder] of this.separateRecorders.entries()) {
                if (recorder && recorder.state === 'recording') {
                    recorder.stop();
                    stoppedCount++;
                }
            }
            console.log(`üìπ Stopped ${stoppedCount} separate recordings`);
        } else {
            // Stop merged recording
            if (this.mediaRecorder && this.mediaRecorder.state === 'recording') {
                this.mediaRecorder.stop();
                console.log('üìπ Merged recording stopped');
            }
        }
        
        this.isRecording = false;
        this.stopRecordingTimer();
    }

    togglePauseRecording() {
        const btn = document.getElementById('pauseBtn');
        
        if (this.outputMode === 'separate') {
            // Handle pausing for separate recorders
            let anyRecording = false;
            let anyPaused = false;
            
            for (const [streamType, recorder] of this.separateRecorders.entries()) {
                if (recorder.state === 'recording') anyRecording = true;
                if (recorder.state === 'paused') anyPaused = true;
            }
            
            if (anyRecording) {
                // Pause all recording recorders
                for (const [streamType, recorder] of this.separateRecorders.entries()) {
                    if (recorder.state === 'recording') {
                        recorder.pause();
                    }
                }
                this.pauseStart = Date.now();
                this.stopRecordingTimer();
                btn.innerHTML = '<i class="fas fa-play me-2"></i>Fortsetzen';
                document.getElementById('recordingStatus').textContent = 'Status: Aufnahme pausiert';
            } else if (anyPaused) {
                // Resume all paused recorders
                for (const [streamType, recorder] of this.separateRecorders.entries()) {
                    if (recorder.state === 'paused') {
                        recorder.resume();
                    }
                }
                if (this.pauseStart) {
                    this.pausedAccum += Date.now() - this.pauseStart;
                    this.pauseStart = null;
                }
                this.startRecordingTimer();
                btn.innerHTML = '<i class="fas fa-pause me-2"></i>Pausieren';
                document.getElementById('recordingStatus').textContent = 'Status: Aufnahme l√§uft';
            }
        } else {
            // Handle merged recording pause
            if (!this.mediaRecorder) return;
            
            if (this.mediaRecorder.state === 'recording') {
                this.mediaRecorder.pause();
                this.pauseStart = Date.now();
                this.stopRecordingTimer();
                btn.innerHTML = '<i class="fas fa-play me-2"></i>Fortsetzen';
                document.getElementById('recordingStatus').textContent = 'Status: Aufnahme pausiert';
            } else if (this.mediaRecorder.state === 'paused') {
                this.mediaRecorder.resume();
                if (this.pauseStart) {
                    this.pausedAccum += Date.now() - this.pauseStart;
                    this.pauseStart = null;
                }
                this.startRecordingTimer();
                btn.innerHTML = '<i class="fas fa-pause me-2"></i>Pausieren';
                document.getElementById('recordingStatus').textContent = 'Status: Aufnahme l√§uft';
            }
        }
    }

    startRecordingTimer() {
        this.recordingTimer = setInterval(() => {
            const elapsed = Date.now() - this.recordingStartTime - (this.pausedAccum || 0);
            const minutes = Math.floor(elapsed / 60000);
            const seconds = Math.floor((elapsed % 60000) / 1000);
            
            const timeStr = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('recordingTime').textContent = timeStr;
            document.getElementById('recordingTimeIndicator').textContent = timeStr;
            
            const progress = (elapsed / this.maxDuration) * 100;
            document.getElementById('recordingProgress').style.width = `${Math.min(progress, 100)}%`;
            
            // Auto-stop at max duration
            if (elapsed >= this.maxDuration) {
                this.stopRecording();
                alert('Aufnahme beendet - Maximale Aufnahmedauer erreicht (3 Minuten)');
            }
        }, 1000);
    }

    stopRecordingTimer() {
        if (this.recordingTimer) {
            clearInterval(this.recordingTimer);
            this.recordingTimer = null;
        }
    }

    resetRecordingUI() {
        const recordBtn = document.getElementById('recordBtn');
        const stopBtn = document.getElementById('stopRecordBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const status = document.getElementById('recordingStatus');
        const indicator = document.getElementById('recordingIndicator');
        const progress = document.getElementById('recordingProgress');
        const time = document.getElementById('recordingTime');
        
        if (recordBtn) recordBtn.disabled = false;
        if (stopBtn) stopBtn.disabled = true;
        if (pauseBtn) {
            pauseBtn.disabled = true;
            pauseBtn.innerHTML = '<i class="fas fa-pause me-2"></i>Pausieren';
        }
        if (status) status.textContent = 'Status: Bereit f√ºr Aufnahme';
        if (indicator) indicator.style.display = 'none';
        if (progress) progress.style.width = '0%';
        if (time) time.textContent = '00:00';
        
        document.getElementById('recordingStateIndicator').innerHTML = '<i class="fas fa-stop me-1"></i>Gestoppt';
    }

    updateRecordingIndicator() {
        const indicator = document.getElementById('recordingIndicator');
        if (indicator) {
            indicator.style.display = this.isRecording ? 'block' : 'none';
        }
    }

    // Preview Modal
    showPreviewModal(videoUrl, videoType = 'video/webm') {
        const existing = document.getElementById('recordPreviewModal');
        if (existing) existing.remove();

        // Determine file extension from type (includes check for codecs)
        const fileExtension = videoType.includes('mp4') ? 'mp4' : 'webm';

        const html = `
            <div class="modal fade" id="recordPreviewModal" tabindex="-1" data-video-type="${videoType}" data-file-extension="${fileExtension}">
                <div class="modal-dialog modal-lg">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title">
                                <i class="fas fa-play me-2"></i>Aufnahme Vorschau
                                <span class="badge bg-success ms-2">${fileExtension.toUpperCase()}</span>
                            </h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                        </div>
                        <div class="modal-body">
                            <div class="text-center mb-4">
                                <video id="previewVideo" controls style="max-width:100%;max-height:400px;">
                                    <source src="${videoUrl}" type="${videoType}">
                                    Ihr Browser unterst√ºtzt das Video-Element nicht.
                                </video>
                            </div>
                            
                            <!-- Custom filename input -->
                            <div class="mb-3" id="customFilenameSection" style="display: none;">
                                <label for="customVideoTitle" class="form-label">
                                    <i class="fas fa-tag me-2"></i>Video-Titel f√ºr Server-Speicherung:
                                </label>
                                <input type="text" 
                                       class="form-control" 
                                       id="customVideoTitle" 
                                       placeholder="Geben Sie einen Namen f√ºr Ihr Video ein..."
                                       maxlength="255"
                                       onkeypress="if(event.key==='Enter') document.getElementById('saveToServerBtn').click()">
                                <div class="form-text">
                                    Optional: Leer lassen f√ºr automatischen Namen
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Schlie√üen</button>
                            <button type="button" class="btn btn-outline-secondary" id="cancelSaveBtn" style="display: none;">
                                <i class="fas fa-times me-2"></i>Abbrechen
                            </button>
                            <button type="button" class="btn btn-primary" id="saveToServerBtn">
                                <i class="fas fa-cloud-upload-alt me-2"></i>Auf Server speichern
                            </button>
                            <button type="button" class="btn btn-success" id="downloadFromPreview">
                                <i class="fas fa-download me-2"></i>Herunterladen
                            </button>
                        </div>
                    </div>
                </div>
            </div>`;
        
        document.body.insertAdjacentHTML('beforeend', html);
        
        document.getElementById('downloadFromPreview')?.addEventListener('click', () => {
            const modal = document.getElementById('recordPreviewModal');
            const extension = modal?.dataset?.fileExtension || 'webm';
            const a = document.createElement('a');
            a.href = videoUrl;
            a.download = `streamrec-optimized-${Date.now()}.${extension}`;
            a.click();
        });

        document.getElementById('saveToServerBtn')?.addEventListener('click', () => {
            const customFilenameSection = document.getElementById('customFilenameSection');
            const saveBtn = document.getElementById('saveToServerBtn');
            const cancelBtn = document.getElementById('cancelSaveBtn');
            
            // First click: Show filename input
            if (customFilenameSection.style.display === 'none') {
                customFilenameSection.style.display = 'block';
                saveBtn.innerHTML = '<i class="fas fa-check me-2"></i>Jetzt speichern';
                saveBtn.className = 'btn btn-success';
                cancelBtn.style.display = 'inline-block';
                
                // Focus on input field
                document.getElementById('customVideoTitle').focus();
                
                // Generate default name
                const defaultTitle = `StreamRec Aufnahme ${new Date().toLocaleString('de-DE')}`;
                document.getElementById('customVideoTitle').value = defaultTitle;
                
                return;
            }
            
            // Second click: Actually save the video
            this.saveVideoToServer(videoUrl);
        });

        document.getElementById('cancelSaveBtn')?.addEventListener('click', () => {
            const customFilenameSection = document.getElementById('customFilenameSection');
            const saveBtn = document.getElementById('saveToServerBtn');
            const cancelBtn = document.getElementById('cancelSaveBtn');
            
            // Hide filename input and reset button
            customFilenameSection.style.display = 'none';
            saveBtn.innerHTML = '<i class="fas fa-cloud-upload-alt me-2"></i>Auf Server speichern';
            saveBtn.className = 'btn btn-primary';
            cancelBtn.style.display = 'none';
            
            // Clear input
            document.getElementById('customVideoTitle').value = '';
        });
        
        if (window.bootstrap) {
            const modal = new bootstrap.Modal(document.getElementById('recordPreviewModal'));
            modal.show();
        }
    }

    async saveVideoToServer(videoUrl) {
        const saveBtn = document.getElementById('saveToServerBtn');
        const originalBtnText = saveBtn.innerHTML;

        // Progress tracking variables
        let uploadStartTime = null;
        let lastLoaded = 0;
        let lastTime = null;

        // Helper functions for progress UI
        const formatBytes = (bytes) => {
            if (bytes === 0) return '0 MB';
            const mb = bytes / (1024 * 1024);
            return mb.toFixed(2) + ' MB';
        };

        const updateProgress = (loaded, total) => {
            const percent = Math.round((loaded / total) * 100);
            const progressBar = document.getElementById('uploadProgressBar');
            const progressText = document.getElementById('uploadProgressText');
            const uploadedSize = document.getElementById('uploadedSize');
            const totalSize = document.getElementById('totalSize');
            const speedValue = document.getElementById('speedValue');

            if (progressBar) {
                progressBar.style.width = percent + '%';
                progressText.textContent = percent + '%';
                uploadedSize.textContent = formatBytes(loaded);
                totalSize.textContent = formatBytes(total);

                // Calculate upload speed (update every 500ms)
                const now = Date.now();
                if (lastTime && (now - lastTime) > 500) {
                    const bytesPerSecond = (loaded - lastLoaded) / ((now - lastTime) / 1000);
                    speedValue.textContent = formatBytes(bytesPerSecond) + '/s';
                    lastLoaded = loaded;
                    lastTime = now;
                }
            }
        };

        const setStage = (stageNum, status) => {
            for (let i = 1; i <= 3; i++) {
                const stage = document.getElementById('uploadStage' + i);
                if (stage) {
                    stage.classList.remove('active', 'done', 'error');
                    if (i < stageNum) {
                        stage.classList.add('done');
                    } else if (i === stageNum) {
                        stage.classList.add(status);
                    }
                }
            }
        };

        const showUploadModal = () => {
            // Reset progress UI
            updateProgress(0, 1);
            setStage(1, 'active');
            document.getElementById('uploadStatus').textContent = 'Video wird hochgeladen...';
            document.getElementById('uploadIcon').innerHTML = '<i class="fas fa-cloud-upload-alt fa-4x text-primary"></i>';
            document.getElementById('speedValue').textContent = '-- MB/s';

            // Show modal
            const modal = new bootstrap.Modal(document.getElementById('uploadProgressModal'));
            modal.show();
            return modal;
        };

        const hideUploadModal = () => {
            const modal = bootstrap.Modal.getInstance(document.getElementById('uploadProgressModal'));
            if (modal) modal.hide();
        };

        try {
            // Show loading state on button
            saveBtn.disabled = true;
            saveBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Wird vorbereitet...';

            // Check storage status first
            const storageResponse = await fetch('/videos/api/storage-status/', {
                method: 'GET',
                headers: {
                    'X-CSRFToken': this.getCSRFToken(),
                    'Content-Type': 'application/json'
                }
            });

            if (!storageResponse.ok) {
                throw new Error('Fehler beim Abrufen des Speicherstatus');
            }

            const storageData = await storageResponse.json();

            if (!storageData.storage.can_upload) {
                throw new Error(storageData.storage.restriction_message || 'Upload nicht m√∂glich');
            }

            // Convert video blob URL to base64
            const response = await fetch(videoUrl);
            const blob = await response.blob();

            // Check file size against available storage
            const fileSizeMB = (blob.size / (1024 * 1024)).toFixed(2);
            if (blob.size > (storageData.storage.available_mb * 1024 * 1024)) {
                throw new Error(`Video zu gro√ü (${fileSizeMB} MB). Verf√ºgbarer Speicherplatz: ${storageData.storage.available_mb.toFixed(2)} MB`);
            }

            // Show upload progress modal
            const uploadModal = showUploadModal();
            uploadStartTime = Date.now();
            lastTime = uploadStartTime;

            const reader = new FileReader();
            reader.onload = async () => {
                try {
                    const base64Data = reader.result.split(',')[1];

                    // Get custom title
                    const customTitleInput = document.getElementById('customVideoTitle');
                    const customTitle = customTitleInput ? customTitleInput.value.trim() : '';
                    const finalFilename = customTitle ? `${customTitle}.webm` : `streamrec_${new Date().toISOString().replace(/[:.]/g, '-')}.webm`;

                    const uploadData = {
                        video_data: base64Data,
                        filename: finalFilename
                    };

                    const jsonBody = JSON.stringify(uploadData);
                    const totalSize = jsonBody.length;

                    // Use XMLHttpRequest for progress tracking
                    const xhr = new XMLHttpRequest();

                    xhr.upload.addEventListener('progress', (e) => {
                        if (e.lengthComputable) {
                            updateProgress(e.loaded, e.total);
                        }
                    });

                    xhr.addEventListener('load', () => {
                        if (xhr.status === 200) {
                            const result = JSON.parse(xhr.responseText);

                            if (result.success) {
                                // Stage 2: Processing
                                setStage(2, 'active');
                                document.getElementById('uploadStatus').textContent = 'Video wird verarbeitet...';

                                setTimeout(() => {
                                    // Stage 3: Done
                                    setStage(3, 'done');
                                    document.getElementById('uploadStatus').textContent = 'Video erfolgreich gespeichert!';
                                    document.getElementById('uploadIcon').innerHTML = '<i class="fas fa-check-circle fa-4x text-success"></i>';

                                    // Update button
                                    saveBtn.innerHTML = '<i class="fas fa-check me-2"></i>Gespeichert!';
                                    saveBtn.className = 'btn btn-success';

                                    // Close modals and show success
                                    setTimeout(() => {
                                        hideUploadModal();
                                        this.showSuccessMessage(result);

                                        const previewModal = bootstrap.Modal.getInstance(document.getElementById('recordPreviewModal'));
                                        if (previewModal) previewModal.hide();
                                    }, 1500);
                                }, 500);

                            } else {
                                throw new Error(result.error || 'Upload fehlgeschlagen');
                            }
                        } else {
                            throw new Error(`HTTP Fehler: ${xhr.status}`);
                        }
                    });

                    xhr.addEventListener('error', () => {
                        setStage(1, 'error');
                        document.getElementById('uploadStatus').textContent = 'Upload fehlgeschlagen';
                        document.getElementById('uploadIcon').innerHTML = '<i class="fas fa-times-circle fa-4x text-danger"></i>';

                        setTimeout(() => {
                            hideUploadModal();
                            this.handleUploadError(saveBtn, originalBtnText, 'Netzwerkfehler beim Upload');
                        }, 2000);
                    });

                    xhr.open('POST', '/streamrec/api/save-video/', true);
                    xhr.setRequestHeader('X-CSRFToken', this.getCSRFToken());
                    xhr.setRequestHeader('Content-Type', 'application/json');
                    xhr.timeout = 300000; // 5 minutes timeout
                    xhr.send(jsonBody);

                } catch (error) {
                    console.error('‚ùå Server Upload Fehler:', error);
                    setStage(1, 'error');
                    document.getElementById('uploadStatus').textContent = error.message;
                    document.getElementById('uploadIcon').innerHTML = '<i class="fas fa-times-circle fa-4x text-danger"></i>';

                    setTimeout(() => {
                        hideUploadModal();
                        this.handleUploadError(saveBtn, originalBtnText, error.message);
                    }, 2000);
                }
            };

            reader.readAsDataURL(blob);

        } catch (error) {
            console.error('‚ùå Save to Server Fehler:', error);
            hideUploadModal();
            this.handleUploadError(saveBtn, originalBtnText, error.message);
        }
    }

    handleUploadError(saveBtn, originalBtnText, errorMessage) {
        saveBtn.innerHTML = '<i class="fas fa-exclamation-triangle me-2"></i>Fehler';
        saveBtn.className = 'btn btn-danger';
        this.showErrorMessage(errorMessage);

        setTimeout(() => {
            saveBtn.disabled = false;
            saveBtn.innerHTML = originalBtnText;
            saveBtn.className = 'btn btn-primary';
        }, 3000);
    }

    showSuccessMessage(result) {
        const message = `
            <div class="alert alert-success alert-dismissible fade show" role="alert">
                <h6><i class="fas fa-cloud-upload-alt me-2"></i>Video erfolgreich gespeichert!</h6>
                <p class="mb-2">
                    <strong>${result.video.title}</strong><br>
                    Gr√∂√üe: ${result.video.file_size_mb} MB | 
                    Speicher: ${result.storage.used_mb}/${result.storage.max_mb} MB (${result.storage.used_percentage}%)
                </p>
                <div class="btn-group btn-group-sm">
                    <a href="${result.video.share_link}" target="_blank" class="btn btn-outline-primary btn-sm">
                        <i class="fas fa-eye me-1"></i>Video ansehen
                    </a>
                    <a href="/videos/" target="_blank" class="btn btn-outline-secondary btn-sm">
                        <i class="fas fa-list me-1"></i>Alle Videos
                    </a>
                    <a href="/videos/storage/" target="_blank" class="btn btn-outline-info btn-sm">
                        <i class="fas fa-hdd me-1"></i>Speicher-Verwaltung
                    </a>
                </div>
                <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
            </div>
        `;
        
        this.showNotification(message);
    }

    showErrorMessage(errorText) {
        const message = `
            <div class="alert alert-danger alert-dismissible fade show" role="alert">
                <h6><i class="fas fa-exclamation-triangle me-2"></i>Speichern fehlgeschlagen</h6>
                <p class="mb-2">${errorText}</p>
                <div class="btn-group btn-group-sm">
                    <a href="/videos/storage/" target="_blank" class="btn btn-outline-info btn-sm">
                        <i class="fas fa-hdd me-1"></i>Speicher-Verwaltung
                    </a>
                </div>
                <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
            </div>
        `;
        
        this.showNotification(message);
    }

    showNotification(html) {
        // Remove existing notifications
        document.querySelectorAll('.server-notification').forEach(el => el.remove());
        
        // Create notification container
        const container = document.createElement('div');
        container.className = 'server-notification';
        container.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 9999;
            max-width: 400px;
        `;
        container.innerHTML = html;
        
        document.body.appendChild(container);
        
        // Auto-remove after 10 seconds
        setTimeout(() => {
            if (container.parentNode) {
                container.remove();
            }
        }, 10000);
    }

    getCSRFToken() {
        const cookie = document.cookie.split(';').find(c => c.trim().startsWith('csrftoken='));
        return cookie ? cookie.split('=')[1] : '';
    }

    updateAspectRatio(ratio) {
        this.aspectRatio = ratio;
        
        // üéØ HIGH-RESOLUTION CANVAS: Professional video quality dimensions
        let width, height;
        
        switch (ratio) {
            case '9:16': // Vertikal - Social Media (Full HD Portrait)
                width = 1080;
                height = 1920;
                break;
            case '16:9': // Horizontal - Standard (Full HD)
                width = 1920;
                height = 1080;
                break;
            case '4:3': // Klassisch - TV Format (4K-like)
                width = 1440;
                height = 1080;
                break;
            case '1:1': // Quadratisch - Instagram (HD Square)
                width = 1080;
                height = 1080;
                break;
            case '21:9': // Ultrawide - Kino (2K Ultrawide)
                width = 2560;
                height = 1080;
                break;
            case '3:2': // Foto-Format (HD Photo)
                width = 1620;
                height = 1080;
                break;
            default: // Fallback to Full HD 16:9
                width = 1920;
                height = 1080;
        }
        
        this.aspectRatioDimensions = { width, height };
        
        // Update canvas dimensions
        if (this.canvas) {
            this.canvas.width = width;
            this.canvas.height = height;
            this.canvas.style.aspectRatio = ratio.replace(':', '/');
            
            // Force re-render
            this.clearCanvas();
            if (this.isComposing) {
                this.renderComposition();
            }
            
            console.log(`üñºÔ∏è Aspect ratio changed to ${ratio} (${width}x${height})`);
            
            // Update format display in UI
            const formatDisplay = document.getElementById('currentFormatDisplay');
            if (formatDisplay) {
                formatDisplay.textContent = ratio;
            }
            
            // Update preview in settings modal
            this.updateAspectRatioPreview(ratio, width, height);
        }
    }

    updateAspectRatioPreview(ratio, width, height) {
        const previewBox = document.getElementById('previewBox');
        const previewDimensions = document.getElementById('previewDimensions');
        
        if (previewBox && previewDimensions) {
            // Calculate preview box dimensions with proper aspect ratio scaling
            const maxSize = 45;
            let previewWidth, previewHeight;
            
            // Calculate aspect ratio
            const aspectRatio = width / height;
            
            if (aspectRatio >= 1) {
                // Landscape or square - fit to width
                previewWidth = maxSize;
                previewHeight = Math.round(maxSize / aspectRatio);
            } else {
                // Portrait - fit to height
                previewHeight = maxSize;
                previewWidth = Math.round(maxSize * aspectRatio);
            }
            
            // Ensure minimum visible size
            previewWidth = Math.max(previewWidth, 15);
            previewHeight = Math.max(previewHeight, 15);
            
            console.log(`üñºÔ∏è Preview updated: ${ratio} -> ${previewWidth}x${previewHeight}px (from ${width}x${height})`);
            
            previewBox.style.width = `${previewWidth}px`;
            previewBox.style.height = `${previewHeight}px`;
            previewDimensions.textContent = `${width} √ó ${height}px (${ratio})`;
        } else {
            console.warn('‚ö†Ô∏è Preview elements not found:', { previewBox: !!previewBox, previewDimensions: !!previewDimensions });
        }
    }

    // üöÄ PERFORMANCE OPTIMIZATION METHODS
    getBrowserOptimalFPS() {
        const ua = navigator.userAgent;
        
        // üöÄ PYTHONANYWHERE OPTIMIZED: Konservativere FPS f√ºr Server-Umgebung
        if (ua.includes('Chrome')) return Math.min(this.targetFPS, 25); // Reduziert von 30
        if (ua.includes('Firefox')) return Math.min(this.targetFPS, 20); // Reduziert von 25  
        if (ua.includes('Safari')) return Math.min(this.targetFPS, 15); // Reduziert von 20
        if (ua.includes('Edge')) return Math.min(this.targetFPS, 20);
        
        // Default f√ºr Server-Umgebung: Konservativ
        return Math.min(this.targetFPS, 20);
    }

    getOptimalRecorderOptions() {
        const quality = document.getElementById('qualitySelect')?.value || 'medium';
        const bitrate = document.getElementById('bitrateSetting')?.value || '4000000';
        
        // üéØ MULTI-STREAM OPTIMIZATION: Dynamische Bitrate basierend auf Stream-Anzahl
        const activeStreamCount = this.getActiveStreamCount();
        const multiStreamFactor = this.calculateMultiStreamBitrateFactor(activeStreamCount);
        
        let baseBitrate = parseInt(bitrate);
        let optimizedBitrate = Math.floor(baseBitrate * multiStreamFactor);
        
        // Quality-basierte Anpassungen mit Multi-Stream Ber√ºcksichtigung
        // ERH√ñHTE BITRATES f√ºr bessere Full HD Qualit√§t
        switch (quality) {
            case 'ultra':
                optimizedBitrate = Math.min(optimizedBitrate, activeStreamCount > 2 ? 5000000 : 8000000);
                break;
            case 'high':
                optimizedBitrate = Math.min(optimizedBitrate, activeStreamCount > 2 ? 3500000 : 6000000);
                break;
            case 'medium':
                optimizedBitrate = Math.min(optimizedBitrate, activeStreamCount > 2 ? 2500000 : 4000000);
                break;
            case 'low':
                optimizedBitrate = Math.min(optimizedBitrate, activeStreamCount > 2 ? 1500000 : 2500000);
                break;
            case 'potato':
                optimizedBitrate = Math.min(optimizedBitrate, activeStreamCount > 2 ? 800000 : 1200000);
                break;
        }
        
        // üöÄ ENHANCED CODEC SELECTION basierend auf Qualit√§ts-Level und Ausgabeformat
        let preferredCodec = 'video/webm;codecs=vp8,opus'; // Standard
        let audioBitrate = 128000;

        // Audio-Qualit√§t aus UI lesen
        const audioQualitySelect = document.getElementById('audioQualitySelect');
        const audioEnabled = document.getElementById('audioEnabled')?.checked !== false;
        const audioQuality = audioQualitySelect?.value || 'medium';

        // Audio-Bitrate basierend auf Auswahl
        switch (audioQuality) {
            case 'high':
                audioBitrate = 192000;
                break;
            case 'medium':
                audioBitrate = 128000;
                break;
            case 'low':
                audioBitrate = 96000;
                break;
        }

        // üé¨ MP4 FORMAT: Versuche browser-native MP4-Aufnahme mit AAC-Audio
        if (this.outputFormat === 'mp4') {
            // WICHTIG: Nur spezifische AAC-Codecs testen
            // Generisches 'video/mp4' w√ºrde Opus verwenden (nicht kompatibel)
            const mp4Codecs = audioEnabled
                ? [
                    'video/mp4;codecs=avc1.42E01E,mp4a.40.2',  // H.264 Baseline + AAC-LC (am besten unterst√ºtzt)
                    'video/mp4;codecs=h264,aac',                // Alternative H.264 + AAC
                    'video/mp4;codecs=avc1,mp4a',               // Generischere Version
                  ]
                : [
                    'video/mp4;codecs=avc1.42E01E',             // H.264 Baseline (nur Video)
                    'video/mp4;codecs=h264',                    // Alternative H.264
                    'video/mp4;codecs=avc1',                    // Generischer H.264
                  ];

            let mp4Found = false;
            for (const codec of mp4Codecs) {
                if (MediaRecorder.isTypeSupported(codec)) {
                    console.log(`‚úÖ MP4 mit AAC natively supported: ${codec}`);
                    preferredCodec = codec;
                    mp4Found = true;
                    break;
                }
            }

            // Falls kein MP4+AAC unterst√ºtzt wird, verwende WebM (KEIN MP4+Opus!)
            if (!mp4Found) {
                console.warn('‚ö†Ô∏è Browser unterst√ºtzt keine MP4-Aufnahme mit AAC-Audio');
                console.warn('‚ö†Ô∏è Fallback zu WebM (verhindert MP4+Opus Inkompatibilit√§t)');
                console.warn('Getestete MP4-Codecs:', mp4Codecs);
                this.outputFormat = 'webm'; // Auto-Fallback zu WebM
                preferredCodec = audioEnabled ? 'video/webm;codecs=vp8,opus' : 'video/webm;codecs=vp8';
            }
        } else {
            // WebM Format (Standard)
            switch (quality) {
                case 'ultra':
                    preferredCodec = audioEnabled ? 'video/webm;codecs=vp9,opus' : 'video/webm;codecs=vp9';
                    break;
                case 'high':
                    preferredCodec = audioEnabled ? 'video/webm;codecs=vp8,opus' : 'video/webm;codecs=vp8';
                    break;
                case 'medium':
                    preferredCodec = audioEnabled ? 'video/webm;codecs=vp8,opus' : 'video/webm;codecs=vp8';
                    break;
                case 'low':
                case 'potato':
                    preferredCodec = audioEnabled ? 'video/webm;codecs=vp8,opus' : 'video/webm';
                    break;
            }
        }
        
        let options = {
            mimeType: preferredCodec,
            videoBitsPerSecond: optimizedBitrate
        };

        // Audio-Bitrate nur hinzuf√ºgen wenn Audio aktiviert ist
        if (audioEnabled) {
            options.audioBitsPerSecond = audioBitrate;
        }

        // üõ°Ô∏è SAFETY CHECK: Verify codec is actually supported
        if (!MediaRecorder.isTypeSupported(preferredCodec)) {
            console.warn(`‚ö†Ô∏è Preferred codec not supported: ${preferredCodec}`);

            // Ultimate fallback
            const fallbackTypes = [
                'video/webm;codecs=vp8,opus',
                'video/webm;codecs=vp8',
                'video/webm'
            ];

            for (const type of fallbackTypes) {
                if (MediaRecorder.isTypeSupported(type)) {
                    console.log(`üìπ Fallback zu: ${type}`);
                    options.mimeType = type;
                    break;
                }
            }
        }

        console.log(`üìπ Multi-Stream optimiert (${activeStreamCount} Streams): ${Math.round(optimizedBitrate/1000)}kbps, ${options.mimeType}`);
        return options;
    }
    
    // üéØ Neue Hilfsfunktionen f√ºr Multi-Stream Optimierung
    getActiveStreamCount() {
        let count = 0;
        if (this.cameraStream) count++;
        if (this.screenStreams && this.screenStreams.size > 0) count += this.screenStreams.size;
        return Math.max(count, 1);
    }
    
    calculateMultiStreamBitrateFactor(streamCount) {
        // Reduziere Bitrate exponentiell mit mehr Streams (optimiert f√ºr bessere Performance)
        switch (streamCount) {
            case 1: return 1.0;      // Volle Bitrate
            case 2: return 0.7;      // 70% bei 2 Streams (optimiert von 80%)
            case 3: return 0.55;     // 55% bei 3 Streams (optimiert von 60%)
            case 4: return 0.40;     // 40% bei 4 Streams (optimiert von 45%)
            default: return 0.30;    // 30% bei 5+ Streams (optimiert von 35%)
        }
    }
    
    // üöÄ ADAPTIVE RENDERING f√ºr bessere Multi-Stream Qualit√§t
    getAdaptiveRenderingSettings(streamCount) {
        return {
            // Canvas-Optimierungen basierend auf Stream-Anzahl
            imageSmoothingEnabled: streamCount <= 2,
            imageSmoothingQuality: streamCount <= 2 ? 'high' : 'medium',
            skipFrame: streamCount > 3,
            maxFPS: streamCount > 3 ? 15 : (streamCount > 2 ? 20 : 30),
            downscale: streamCount > 4 ? 0.8 : 1.0
        };
    }
    
    applyVideoQualitySettings(video, settings) {
        // Anwenden der Canvas-Optimierungen
        this.ctx.imageSmoothingEnabled = settings.imageSmoothingEnabled;
        if (settings.imageSmoothingEnabled) {
            this.ctx.imageSmoothingQuality = settings.imageSmoothingQuality;
        }
        
        // Video-spezifische Optimierungen
        if (video.style) {
            video.style.imageRendering = settings.imageSmoothingEnabled ? 'auto' : 'pixelated';
        }
    }

    applyQualitySettings(quality) {
        // üéØ ENHANCED QUALITY SETTINGS mit Multi-Stream Optimierung
        const streamCount = this.getActiveStreamCount();
        
        switch (quality) {
            case 'ultra':
                this.targetFPS = streamCount <= 1 ? 30 : (streamCount === 2 ? 24 : 20);
                this.maxSkipFrames = streamCount <= 2 ? 1 : 2;
                this.quality = 'ultra';
                break;
            case 'high':
                this.targetFPS = streamCount <= 1 ? 25 : (streamCount === 2 ? 20 : 18);
                this.maxSkipFrames = streamCount <= 2 ? 2 : 3;
                this.quality = 'high';
                break;
            case 'medium':
                this.targetFPS = streamCount <= 1 ? 20 : (streamCount === 2 ? 16 : 14);
                this.maxSkipFrames = streamCount <= 2 ? 3 : 4;
                break;
            case 'low':
                this.targetFPS = streamCount <= 1 ? 15 : (streamCount === 2 ? 12 : 10);
                this.maxSkipFrames = streamCount <= 2 ? 4 : 5;
                this.quality = 'low';
                break;
            case 'potato':
                this.targetFPS = streamCount <= 1 ? 12 : (streamCount === 2 ? 10 : 8);
                this.maxSkipFrames = 6;
                this.quality = 'potato';
                break;
            default:
                this.quality = 'medium';
        }
        this.frameInterval = 1000 / this.targetFPS;
        
        console.log(`üéØ Qualit√§t "${quality}" angewendet: ${this.targetFPS}fps (${streamCount} Streams)`);
    }

    handleRenderError(error) {
        console.warn('üîß Auto-recovery from render error:', error);
        
        // Reset problematic states
        this.skipFrameCount = 0;
        
        // Clear video element pool if corrupted
        if (error.message.includes('video') || error.message.includes('canvas')) {
            this.videoElements.clear();
        }
    }

    // Performance Monitoring
    initPerformanceMonitoring() {
        setInterval(() => {
            this.calculateFPS();
            this.updateSystemInfoMetrics();
        }, 1000);
    }
    
    updateSystemInfoMetrics() {
        const metricsElement = document.getElementById('performanceMetrics');
        if (!metricsElement) return;
        
        const fps = this.performanceMetrics.lastFPS || 0;
        const dropped = this.performanceMetrics.droppedFrames || 0;
        const total = this.performanceMetrics.totalFrames || 0;
        const dropRate = total > 0 ? ((dropped / total) * 100).toFixed(1) : '0.0';
        const renderTime = Math.round(this.performanceMetrics.averageRenderTime || 0);
        
        // Farbkodierung basierend auf Performance
        let statusClass = 'text-muted';
        let statusText = 'Bereit';
        
        // Nur bewerten wenn bereits Frames verarbeitet wurden
        if (total > 0) {
            if (fps >= 20 && dropRate <= 5) {
                statusClass = 'text-success';
                statusText = 'Gut';
            } else if (fps >= 15 && dropRate <= 10) {
                statusClass = 'text-warning';
                statusText = 'Mittel';
            } else {
                statusClass = 'text-danger';
                statusText = 'Schlecht';
            }
        }
        
        metricsElement.innerHTML = `
            <div class="row g-2 text-center">
                <div class="col-6">
                    <small class="text-muted d-block">FPS</small>
                    <span class="fw-bold ${statusClass}">${fps}</span>
                </div>
                <div class="col-6">
                    <small class="text-muted d-block">Frames</small>
                    <span class="fw-bold text-info">${total}</span>
                </div>
                <div class="col-6">
                    <small class="text-muted d-block">Dropped</small>
                    <span class="fw-bold ${dropRate > 5 ? 'text-warning' : 'text-success'}">${dropRate}%</span>
                </div>
                <div class="col-6">
                    <small class="text-muted d-block">Status</small>
                    <span class="fw-bold ${statusClass}">${statusText}</span>
                </div>
            </div>
        `;
    }

    updatePerformanceMetrics(renderTime) {
        this.performanceMetrics.totalFrames++;
        this.renderTimeBuffer.push(renderTime);
        
        // Keep buffer size manageable
        if (this.renderTimeBuffer.length > 60) {
            this.renderTimeBuffer.shift();
        }
        
        // Calculate average render time
        const avgRenderTime = this.renderTimeBuffer.reduce((a, b) => a + b, 0) / this.renderTimeBuffer.length;
        this.performanceMetrics.averageRenderTime = avgRenderTime;
    }

    calculateFPS() {
        const now = performance.now();
        const elapsed = now - this.lastFPSUpdate;
        
        if (elapsed >= 1000) {
            const fps = Math.round(this.performanceBuffer.length * 1000 / elapsed);
            this.performanceMetrics.lastFPS = fps;
            this.performanceBuffer = [];
            this.lastFPSUpdate = now;
            
            this.updatePerformanceDisplay();
        }
        
        this.performanceBuffer.push(now);
    }

    updatePerformanceDisplay() {
        const indicator = document.getElementById('performanceIndicator');
        if (!indicator || indicator.style.display === 'none') return;
        
        const fps = this.performanceMetrics.lastFPS;
        const dropped = this.performanceMetrics.droppedFrames;
        const renderTime = Math.round(this.performanceMetrics.averageRenderTime);
        
        document.getElementById('fpsCounter').textContent = fps;
        document.getElementById('frameCounter').textContent = this.performanceMetrics.totalFrames;
        document.getElementById('droppedCounter').textContent = dropped;
        document.getElementById('renderTime').textContent = renderTime + 'ms';
        
        // Color coding
        indicator.className = 'performance-indicator ';
        if (fps >= this.targetFPS * 0.8 && renderTime < 16) {
            indicator.className += 'performance-good';
        } else if (fps >= this.targetFPS * 0.6 && renderTime < 25) {
            indicator.className += 'performance-warning';
        } else {
            indicator.className += 'performance-critical';
        }
    }

    togglePerformanceMonitor(show) {
        const indicator = document.getElementById('performanceIndicator');
        if (indicator) {
            indicator.style.display = show ? 'block' : 'none';
        }
    }

    // Utility Methods
    updateStatus(type, message, variant) {
        const statusElement = document.getElementById(`${type}Status`);
        if (statusElement) {
            statusElement.textContent = `Status: ${message}`;
            statusElement.className = `text-${variant} d-block mt-2`;
        }
    }

    updateButtons(type, active) {
        const startBtn = document.getElementById(`start${type.charAt(0).toUpperCase() + type.slice(1)}Btn`);
        const stopBtn = document.getElementById(`stop${type.charAt(0).toUpperCase() + type.slice(1)}Btn`);
        
        if (startBtn) startBtn.disabled = active;
        if (stopBtn) stopBtn.disabled = !active;
        
    }

    updateStatusBadge(type, variant) {
        const badge = document.getElementById(`${type}StatusBadge`);
        if (badge) {
            // Replace FontAwesome icon with simple colored dot
            const colorMap = {
                'success': '#28a745',
                'danger': '#dc3545',
                'secondary': '#6c757d'
            };
            
            badge.innerHTML = '';
            badge.style.cssText = `
                width: 16px;
                height: 16px;
                display: flex;
                align-items: center;
                justify-content: center;
            `;
            
            const dot = document.createElement('div');
            dot.style.cssText = `
                width: 12px;
                height: 12px;
                border-radius: 50%;
                background-color: ${colorMap[variant] || '#6c757d'} !important;
                border: 2px solid #ffffff;
                display: block;
                box-shadow: 0 0 3px rgba(0,0,0,0.3);
            `;
            badge.appendChild(dot);
            console.log(`üîß Status-Badge f√ºr ${type} auf ${variant} gesetzt (Farbe: ${colorMap[variant]})`);
        } else {
            console.error(`‚ùå Status-Badge f√ºr ${type} nicht gefunden!`);
        }
    }

    updateActiveStreamsCount() {
        const counter = document.getElementById('activeStreams');
        if (counter) {
            counter.textContent = this.streams.size;
        }
    }

    checkCompositionReady() {
        const hasActiveStreams = this.activeStreams.size > 0;
        if (hasActiveStreams && !this.isComposing) {
            this.startRenderLoop();
        } else if (!hasActiveStreams && this.isComposing) {
            this.stopRenderLoop();
        }
    }

    // Settings Management
    loadSettings() {
        try {
            const stored = localStorage.getItem('streamrec-optimized-settings');
            if (stored) {
                const settings = JSON.parse(stored);
                if (settings.targetFPS) {
                    this.targetFPS = settings.targetFPS;
                    document.getElementById('fpsSelect').value = settings.targetFPS;
                }
                if (settings.enableFrameSkipping !== undefined) {
                    this.enableFrameSkipping = settings.enableFrameSkipping;
                    document.getElementById('enableFrameSkipping').checked = settings.enableFrameSkipping;
                }
                if (settings.enableErrorRecovery !== undefined) {
                    this.enableErrorRecovery = settings.enableErrorRecovery;
                    document.getElementById('enableErrorRecovery').checked = settings.enableErrorRecovery;
                }
                if (settings.showPerformance !== undefined) {
                    this.togglePerformanceMonitor(settings.showPerformance);
                    document.getElementById('enablePerformanceMonitor').checked = settings.showPerformance;
                }
                if (settings.aspectRatio) {
                    this.updateAspectRatio(settings.aspectRatio);
                    document.getElementById('aspectRatioSetting').value = settings.aspectRatio;
                }
                if (settings.audioSyncOffset !== undefined) {
                    this.audioSyncOffset = settings.audioSyncOffset;
                    const slider = document.getElementById('audioSyncOffset');
                    const display = document.getElementById('audioSyncDisplay');
                    if (slider) slider.value = settings.audioSyncOffset;
                    if (display) display.textContent = `${settings.audioSyncOffset} ms`;
                }
                if (settings.outputFormat) {
                    this.outputFormat = settings.outputFormat;
                    const select = document.getElementById('outputFormatSetting');
                    if (select) select.value = settings.outputFormat;
                }
            } else {
                // No stored settings - apply default 16:9 format and mp4
                this.updateAspectRatio('16:9');
                document.getElementById('aspectRatioSetting').value = '16:9';
                this.outputFormat = 'mp4';
                const select = document.getElementById('outputFormatSetting');
                if (select) select.value = 'mp4';
            }
        } catch (e) {
            console.warn('Settings load error:', e);
            // On error, fallback to default 16:9 format
            this.updateAspectRatio('16:9');
            document.getElementById('aspectRatioSetting').value = '16:9';
        }
    }

    saveSettings() {
        try {
            const aspectRatio = document.getElementById('aspectRatioSetting')?.value ?? '16:9';
            const outputFormat = document.getElementById('outputFormatSetting')?.value ?? 'mp4';

            const settings = {
                targetFPS: this.targetFPS,
                enableFrameSkipping: document.getElementById('enableFrameSkipping')?.checked ?? true,
                enableErrorRecovery: document.getElementById('enableErrorRecovery')?.checked ?? true,
                showPerformance: document.getElementById('enablePerformanceMonitor')?.checked ?? false,
                bitrate: document.getElementById('bitrateSetting')?.value ?? '4000000',
                aspectRatio: aspectRatio,
                outputFormat: outputFormat,
                audioSyncOffset: this.audioSyncOffset
            };

            localStorage.setItem('streamrec-optimized-settings', JSON.stringify(settings));

            // Apply settings
            this.enableFrameSkipping = settings.enableFrameSkipping;
            this.enableErrorRecovery = settings.enableErrorRecovery;
            this.togglePerformanceMonitor(settings.showPerformance);
            this.updateAspectRatio(settings.aspectRatio);
            this.outputFormat = settings.outputFormat;
            
            this.showSettingsSavedNotification();
            
            // Close modal
            const modalEl = document.getElementById('settingsModal');
            if (modalEl && window.bootstrap) {
                const modal = bootstrap.Modal.getInstance(modalEl) || new bootstrap.Modal(modalEl);
                modal.hide();
            }
        } catch (e) {
            console.error('Settings save error:', e);
            this.showSettingsErrorNotification(e.message);
        }
    }

    showSettingsSavedNotification() {
        // Remove any existing notifications
        document.querySelectorAll('.settings-notification').forEach(el => el.remove());
        
        const notification = document.createElement('div');
        notification.className = 'settings-notification position-fixed top-0 start-50 translate-middle-x mt-4';
        notification.style.cssText = `
            z-index: 9999;
            animation: slideInFromTop 0.4s ease-out forwards, notificationBounce 0.5s ease-out 0.4s;
            pointer-events: auto;
        `;
        
        notification.innerHTML = `
            <div class="alert alert-success alert-dismissible d-flex align-items-center shadow-lg border-0" 
                 style="background: linear-gradient(135deg, #28a745 0%, #20c997 100%); color: white; min-width: 320px;">
                <i class="fas fa-check-circle fs-4 me-3"></i>
                <div class="flex-grow-1">
                    <h6 class="mb-1">Einstellungen gespeichert!</h6>
                    <small class="opacity-75">Alle √Ñnderungen wurden erfolgreich √ºbernommen</small>
                </div>
                <button type="button" class="btn-close btn-close-white" onclick="this.parentElement.parentElement.remove()"></button>
            </div>
        `;
        
        document.body.appendChild(notification);
        
        // Auto-remove after 4 seconds
        setTimeout(() => {
            if (notification.parentNode) {
                notification.style.animation = 'slideOutToTop 0.3s ease-in forwards';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.remove();
                    }
                }, 300);
            }
        }, 4000);
    }

    showSettingsErrorNotification(message) {
        // Remove any existing notifications
        document.querySelectorAll('.settings-notification').forEach(el => el.remove());
        
        const notification = document.createElement('div');
        notification.className = 'settings-notification position-fixed top-0 start-50 translate-middle-x mt-4';
        notification.style.cssText = `
            z-index: 9999;
            animation: slideInFromTop 0.4s ease-out forwards, notificationBounce 0.5s ease-out 0.4s;
            pointer-events: auto;
        `;
        
        notification.innerHTML = `
            <div class="alert alert-danger alert-dismissible d-flex align-items-center shadow-lg border-0" 
                 style="background: linear-gradient(135deg, #dc3545 0%, #e74c3c 100%); color: white; min-width: 320px;">
                <i class="fas fa-exclamation-triangle fs-4 me-3"></i>
                <div class="flex-grow-1">
                    <h6 class="mb-1">Speichern fehlgeschlagen</h6>
                    <small class="opacity-75">${message}</small>
                </div>
                <button type="button" class="btn-close btn-close-white" onclick="this.parentElement.parentElement.remove()"></button>
            </div>
        `;
        
        document.body.appendChild(notification);
        
        // Auto-remove after 6 seconds (longer for error messages)
        setTimeout(() => {
            if (notification.parentNode) {
                notification.style.animation = 'slideOutToTop 0.3s ease-in forwards';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.remove();
                    }
                }, 300);
            }
        }, 6000);
    }

    // üìê LAYOUT MANAGEMENT METHODS
    renderStacked(streams) {
        const streamArray = Array.from(streams);
        const height = this.canvas.height / streamArray.length;
        
        streamArray.forEach(([type, stream], index) => {
            const video = this.getVideoElementOptimized(type, stream);
            if (!video || video.readyState < 2) return;
            
            const y = index * height;
            this.drawVideoContain(video, 0, y, this.canvas.width, height);
            
            // Draw separator
            if (index > 0) {
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(0, y);
                this.ctx.lineTo(this.canvas.width, y);
                this.ctx.stroke();
            }
        });
    }

    renderGrid2x2(streams) {
        const items = Array.from(streams).slice(0, 4);
        const cols = 2, rows = 2;
        const cellW = Math.floor(this.canvas.width / cols);
        const cellH = Math.floor(this.canvas.height / rows);
        
        items.forEach(([type, stream], idx) => {
            const video = this.getVideoElementOptimized(type, stream);
            if (!video || video.readyState < 2) return;
            
            const col = idx % cols;
            const row = Math.floor(idx / cols);
            const dx = col * cellW;
            const dy = row * cellH;
            
            this.drawVideoContain(video, dx, dy, cellW, cellH);
            
            // Draw grid lines
            this.ctx.strokeStyle = '#fff';
            this.ctx.lineWidth = 2;
            if (col === 0) {
                this.ctx.beginPath();
                this.ctx.moveTo(cellW, 0);
                this.ctx.lineTo(cellW, this.canvas.height);
                this.ctx.stroke();
            }
            if (row === 0) {
                this.ctx.beginPath();
                this.ctx.moveTo(0, cellH);
                this.ctx.lineTo(this.canvas.width, cellH);
                this.ctx.stroke();
            }
        });
    }

    renderThreeColumns(streams) {
        const items = Array.from(streams).slice(0, 3);
        const colW = Math.floor(this.canvas.width / 3);
        
        items.forEach(([type, stream], idx) => {
            const video = this.getVideoElementOptimized(type, stream);
            if (!video || video.readyState < 2) return;
            
            const dx = idx * colW;
            this.drawVideoContain(video, dx, 0, colW, this.canvas.height);
            
            // Draw separators
            if (idx > 0) {
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(dx, 0);
                this.ctx.lineTo(dx, this.canvas.height);
                this.ctx.stroke();
            }
        });
    }

    renderLeftBigRightTwo(streams) {
        const streamArray = Array.from(streams);
        if (streamArray.length < 3) return this.renderStacked(streamArray);
        
        const left = streamArray[0];
        const right = streamArray.slice(1, 3);
        const leftW = Math.floor(this.canvas.width * 0.66);
        const rightW = this.canvas.width - leftW;
        const rightH = Math.floor(this.canvas.height / 2);
        
        // Left big
        const [lt, ls] = left;
        const lv = this.getVideoElementOptimized(lt, ls);
        if (lv && lv.readyState >= 2) {
            this.drawVideoContain(lv, 0, 0, leftW, this.canvas.height);
        }
        
        // Right stacked two
        right.forEach(([t, s], i) => {
            const v = this.getVideoElementOptimized(t, s);
            if (v && v.readyState >= 2) {
                const dx = leftW;
                const dy = i * rightH;
                this.drawVideoContain(v, dx, dy, rightW, rightH);
            }
        });
        
        // Separators
        this.ctx.strokeStyle = '#fff';
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.moveTo(leftW, 0);
        this.ctx.lineTo(leftW, this.canvas.height);
        this.ctx.moveTo(leftW, rightH);
        this.ctx.lineTo(this.canvas.width, rightH);
        this.ctx.stroke();
    }

    renderFullscreen(streams) {
        // üéØ FIXED: Show first stream fullscreen with proper scaling
        const firstStream = Array.from(streams)[0];
        if (firstStream) {
            const [type, stream] = firstStream;
            const video = this.getVideoElementOptimized(type, stream);
            if (video && video.readyState >= 2) {
                // Clear canvas first
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                // Draw video with proper aspect ratio
                this.drawVideoWithMode(video, type, 0, 0, this.canvas.width, this.canvas.height);
            }
        }
    }
    
    // üöÄ NEW: Canvas Fullscreen Support
    toggleCanvasFullscreen() {
        const previewContainer = document.getElementById('previewContainer');
        
        if (!document.fullscreenElement) {
            // Enter fullscreen
            if (previewContainer.requestFullscreen) {
                previewContainer.requestFullscreen().then(() => {
                    this.adjustCanvasForFullscreen(true);
                });
            } else if (previewContainer.webkitRequestFullscreen) {
                previewContainer.webkitRequestFullscreen();
                this.adjustCanvasForFullscreen(true);
            } else if (previewContainer.msRequestFullscreen) {
                previewContainer.msRequestFullscreen();
                this.adjustCanvasForFullscreen(true);
            }
        } else {
            // Exit fullscreen
            if (document.exitFullscreen) {
                document.exitFullscreen().then(() => {
                    this.adjustCanvasForFullscreen(false);
                });
            }
        }
    }
    
    adjustCanvasForFullscreen(isFullscreen) {
        const canvas = this.canvas;
        const previewContainer = document.getElementById('previewContainer');
        
        if (isFullscreen) {
            // Store original size
            this.originalCanvasSize = {
                width: canvas.width,
                height: canvas.height
            };
            
            // Adjust to fullscreen
            const screenWidth = screen.width;
            const screenHeight = screen.height;
            
            // Maintain aspect ratio
            const aspectRatio = this.originalCanvasSize.width / this.originalCanvasSize.height;
            
            if (screenWidth / screenHeight > aspectRatio) {
                canvas.height = screenHeight;
                canvas.width = screenHeight * aspectRatio;
            } else {
                canvas.width = screenWidth;
                canvas.height = screenWidth / aspectRatio;
            }
            
            canvas.style.width = canvas.width + 'px';
            canvas.style.height = canvas.height + 'px';
            previewContainer.style.backgroundColor = '#000';
            
        } else {
            // Restore original size
            if (this.originalCanvasSize) {
                canvas.width = this.originalCanvasSize.width;
                canvas.height = this.originalCanvasSize.height;
                this.updateAspectRatio(this.aspectRatio); // Restore proper dimensions
            }
            canvas.style.width = '';
            canvas.style.height = '';
            previewContainer.style.backgroundColor = '';
        }
        
        // Force a re-render
        if (this.isComposing) {
            this.renderCurrentLayout();
        }
        
        // Show grid if enabled
        if (this.showGrid) {
            this.drawGrid();
        }
    }
    
    // üéØ NEW: Grid Toggle Feature
    toggleGrid() {
        this.showGrid = !this.showGrid;
        const gridBtn = document.getElementById('gridToggle');
        
        if (this.showGrid) {
            gridBtn.classList.add('active');
            gridBtn.style.backgroundColor = 'rgba(255,255,255,0.2)';
        } else {
            gridBtn.classList.remove('active');
            gridBtn.style.backgroundColor = '';
        }
        
        // Re-render to show/hide grid
        if (this.isComposing) {
            this.renderCurrentLayout();
        }
    }
    
    // üéØ NEW: Zoom to Fit Feature
    zoomToFit() {
        // Reset any custom zoom/positioning
        this.canvasZoom = 1.0;
        this.canvasOffsetX = 0;
        this.canvasOffsetY = 0;
        
        // Update canvas styling
        this.canvas.style.transform = `scale(${this.canvasZoom}) translate(${this.canvasOffsetX}px, ${this.canvasOffsetY}px)`;
        
        // Show feedback
        this.showToast('üéØ Canvas auf optimale Gr√∂√üe angepasst', 'info');
    }
    
    // üéØ NEW: Grid Drawing Function
    drawGrid() {
        if (!this.showGrid) return;
        
        this.ctx.save();
        this.ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        this.ctx.lineWidth = 1;
        this.ctx.setLineDash([5, 5]);
        
        const gridSize = 50;
        
        // Vertical lines
        for (let x = gridSize; x < this.canvas.width; x += gridSize) {
            this.ctx.beginPath();
            this.ctx.moveTo(x, 0);
            this.ctx.lineTo(x, this.canvas.height);
            this.ctx.stroke();
        }
        
        // Horizontal lines
        for (let y = gridSize; y < this.canvas.height; y += gridSize) {
            this.ctx.beginPath();
            this.ctx.moveTo(0, y);
            this.ctx.lineTo(this.canvas.width, y);
            this.ctx.stroke();
        }
        
        this.ctx.restore();
    }
    
    // üöÄ Setup fullscreen event listeners
    setupFullscreenListener() {
        document.addEventListener('fullscreenchange', () => {
            if (!document.fullscreenElement) {
                this.adjustCanvasForFullscreen(false);
            }
        });
        
        document.addEventListener('webkitfullscreenchange', () => {
            if (!document.webkitFullscreenElement) {
                this.adjustCanvasForFullscreen(false);
            }
        });
        
        document.addEventListener('mozfullscreenchange', () => {
            if (!document.mozFullScreenElement) {
                this.adjustCanvasForFullscreen(false);
            }
        });
        
        document.addEventListener('msfullscreenchange', () => {
            if (!document.msFullscreenElement) {
                this.adjustCanvasForFullscreen(false);
            }
        });
    }

    applyLayout(layout) {
        this.currentLayout = layout;
        console.log(`üìê Layout angewendet: ${layout}`);
        
        // Update thumbnail appearances for the new layout
        this.updateThumbnailsForLayoutChange();
        
        // Sofortige Aktualisierung der Komposition wenn aktiv
        if (this.isComposing) {
            this.renderCurrentLayout();
        }
    }

    // üéØ LAYOUT MANAGEMENT
    refreshLayoutChips() {
        const container = document.getElementById('layoutChips');
        const streamCountElement = document.getElementById('layoutStreamCount');
        
        if (!container) return;
        
        const count = this.activeStreams.size;
        const layouts = this.getAvailableLayouts(count);
        
        // Update stream count display
        if (streamCountElement) {
            streamCountElement.textContent = `${count} Stream${count !== 1 ? 's' : ''}`;
        }
        
        if (layouts.length === 0) {
            container.innerHTML = '<small class="text-muted">Starte Streams f√ºr Layouts</small>';
            // Layout manager removed
            return;
        }
        
        // Create layout chips (small buttons) with icons - always show layout name
        container.innerHTML = layouts.map(l => 
            `<button type="button" class="btn btn-sm ${this.currentLayout === l.id ? 'btn-primary' : 'btn-outline-primary'}" data-layout="${l.id}" title="${l.description}">
                <i class="${l.icon} me-1" style="font-size: 12px;"></i>${l.name}${this.currentLayout === l.id ? ' ‚úì' : ''}
            </button>`
        ).join(' ');
        
        console.log(`üìê Layouts aktualisiert: ${count} Streams, ${layouts.length} Layouts verf√ºgbar`);
    }

    getAvailableLayouts(streamCount) {
        const layouts = [];
        
        if (streamCount >= 1) {
            layouts.push({ 
                id: 'fullscreen', 
                name: 'Vollbild', 
                description: 'Ein Stream im Vollbild',
                icon: 'fas fa-expand-arrows-alt'
            });
            layouts.push({ 
                id: 'free', 
                name: 'Freies Layout', 
                description: 'Streams frei positionieren und skalieren per Drag & Drop',
                icon: 'fas fa-arrows-alt'
            });
        }
        if (streamCount >= 2) {
            layouts.push({ 
                id: 'pip', 
                name: 'PiP', 
                description: 'Picture-in-Picture (Bildschirm + Kamera)',
                icon: 'fas fa-square'
            });
            layouts.push({ 
                id: 'side', 
                name: 'Nebeneinander', 
                description: 'Streams nebeneinander angeordnet',
                icon: 'fas fa-columns'
            });
            layouts.push({ 
                id: 'stack', 
                name: 'Gestapelt', 
                description: 'Streams √ºbereinander angeordnet',
                icon: 'fas fa-stream'
            });
        }
        if (streamCount >= 3) {
            layouts.push({ 
                id: 'threeCols', 
                name: '3 Spalten', 
                description: 'Drei gleichm√§√üige Spalten',
                icon: 'fas fa-grip-vertical'
            });
            layouts.push({ 
                id: 'leftBigRight2', 
                name: 'Links Gro√ü', 
                description: 'Links gro√ü, rechts zwei kleine',
                icon: 'fas fa-th-large'
            });
        }
        if (streamCount >= 4) {
            layouts.push({ 
                id: 'grid2x2', 
                name: '2x2 Grid', 
                description: '2x2 Raster Layout f√ºr 4 Streams',
                icon: 'fas fa-th'
            });
        }
        
        return layouts;
    }

    // updateLayoutManager function removed - Layout Manager section removed from UI

    // Layout Icon Mapping (not needed anymore, using layout.icon directly)
    getLayoutIcon(layoutId) {
        // Legacy fallback, now using layout.icon from getAvailableLayouts
        const icons = {
            'fullscreen': 'expand-arrows-alt',
            'pip': 'square',
            'side': 'columns',
            'stack': 'stream',
            'threeCols': 'grip-vertical',
            'leftBigRight2': 'th-large',
            'grid2x2': 'th'
        };
        return icons[layoutId] || 'square';
    }

    // üñºÔ∏è STREAM THUMBNAIL MANAGEMENT
    addStreamThumbnail(type, stream) {
        const container = document.getElementById('streamThumbnails');
        if (!container) return;

        // Remove no streams message
        const noStreamsMsg = document.getElementById('noStreamsMessage');
        if (noStreamsMsg) noStreamsMsg.style.display = 'none';

        // Show drag drop hint if we have streams
        const dragDropHint = document.getElementById('dragDropHint');
        if (dragDropHint && this.streams.size >= 1) {
            dragDropHint.style.display = 'block';
        }
        
        // Mark stream as active by default and set default display mode
        this.activeStreams.add(type);
        this.streamDisplayModes.set(type, 'cover'); // Default: cover (stretch to fill)
        
        // Create thumbnail
        const thumbnail = document.createElement('div');
        thumbnail.id = `thumbnail-${type}`;
        thumbnail.className = 'stream-thumbnail position-relative';
        thumbnail.style.cssText = 'width: 120px; height: 90px; border-radius: 0.5rem; overflow: hidden; border: 2px solid #28a745; cursor: grab; transition: all 0.3s;';
        thumbnail.setAttribute('data-stream-id', type);
        thumbnail.draggable = true;
        thumbnail.dataset.streamKey = type;

        // Add click handler for toggle or add to free layout
        thumbnail.addEventListener('click', () => this.handleThumbnailClick(type));

        // Add drag event listeners for reordering
        thumbnail.addEventListener('dragstart', (e) => this.handleThumbnailDragStart(e));
        thumbnail.addEventListener('dragend', (e) => this.handleThumbnailDragEnd(e));
        thumbnail.addEventListener('dragover', (e) => this.handleThumbnailDragOver(e));
        thumbnail.addEventListener('drop', (e) => this.handleThumbnailDrop(e));
        
        const video = document.createElement('video');
        video.srcObject = stream;
        video.autoplay = true;
        video.muted = true;
        video.playsInline = true;
        video.style.cssText = 'width: 100%; height: 100%; object-fit: cover;';
        
        const label = document.createElement('div');
        label.className = 'position-absolute bottom-0 start-0 end-0 bg-dark bg-opacity-75 text-white text-center py-1';
        label.style.fontSize = '0.75rem';
        label.textContent = type === 'camera' ? 'Kamera' : type.startsWith('screen') ? (type === 'screen1' ? 'Bildschirm 1' : type.replace('screen', 'Bildschirm ')) : type;
        
        // Add status indicator (simple colored dot)
        const statusIndicator = document.createElement('div');
        statusIndicator.className = 'position-absolute';
        statusIndicator.style.cssText = `
            top: 4px;
            right: 4px;
            width: 10px; 
            height: 10px; 
            border-radius: 50%; 
            border: 1px solid white;
            z-index: 10;
        `;
        statusIndicator.style.backgroundColor = '#28a745'; // Green for active
        statusIndicator.id = `status-${type}`;
        
        // Add close button
        const closeButton = document.createElement('div');
        closeButton.className = 'position-absolute top-0 start-0';
        closeButton.style.cssText = `
            width: 20px; 
            height: 20px; 
            background: rgba(220, 53, 69, 0.9); 
            border-radius: 50%; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            cursor: pointer; 
            margin: 2px;
            transition: background-color 0.2s;
        `;
        closeButton.innerHTML = '<i class="fas fa-times text-white" style="font-size: 10px;"></i>';
        closeButton.title = 'Stream entfernen';
        
        // Add hover effect
        closeButton.addEventListener('mouseenter', () => {
            closeButton.style.backgroundColor = 'rgba(220, 53, 69, 1)';
        });
        closeButton.addEventListener('mouseleave', () => {
            closeButton.style.backgroundColor = 'rgba(220, 53, 69, 0.9)';
        });
        
        // Add click handler to remove stream
        closeButton.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent thumbnail click
            this.removeStreamCompletely(type);
        });

        // Add layer indicator badge (shows position in stack)
        const layerBadge = document.createElement('span');
        layerBadge.className = 'badge bg-secondary position-absolute';
        layerBadge.style.cssText = 'bottom: 28px; right: 4px; font-size: 0.65rem; padding: 0.2rem 0.4rem;';
        layerBadge.id = `layer-badge-${type}`;
        const layerIndex = this.streamOrder.indexOf(type);
        layerBadge.textContent = layerIndex >= 0 ? layerIndex + 1 : this.streamOrder.length + 1;
        layerBadge.title = 'Ebene (links=hinten, rechts=vorne)';

        thumbnail.appendChild(video);
        thumbnail.appendChild(label);
        thumbnail.appendChild(statusIndicator);
        thumbnail.appendChild(closeButton);
        thumbnail.appendChild(layerBadge);
        container.appendChild(thumbnail);

        // Update all layer badges
        this.updateLayerBadges();
    }

    removeStreamThumbnail(type) {
        const thumbnail = document.getElementById(`thumbnail-${type}`);
        if (thumbnail) {
            thumbnail.remove();
        }

        // Remove from active streams and display modes
        this.activeStreams.delete(type);
        this.streamDisplayModes.delete(type);

        // Check if only the noStreamsMessage is left
        const container = document.getElementById('streamThumbnails');
        const streamThumbs = container?.querySelectorAll('.stream-thumbnail');

        if (streamThumbs && streamThumbs.length === 0) {
            const noStreamsMsg = document.getElementById('noStreamsMessage');
            if (noStreamsMsg) noStreamsMsg.style.display = 'block';

            // Hide drag drop hint
            const dragDropHint = document.getElementById('dragDropHint');
            if (dragDropHint) dragDropHint.style.display = 'none';
        }

        // Update layer badges after removal
        this.updateLayerBadges();
    }

    // Drag & Drop handlers for thumbnail reordering
    handleThumbnailDragStart(e) {
        this.draggedThumbnail = e.target.closest('.stream-thumbnail');
        if (this.draggedThumbnail) {
            e.target.style.opacity = '0.5';
            e.target.style.cursor = 'grabbing';
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', e.target.innerHTML);
        }
    }

    handleThumbnailDragEnd(e) {
        e.target.style.opacity = '1';
        e.target.style.cursor = 'grab';
        // Remove all drag-over classes
        document.querySelectorAll('.stream-thumbnail').forEach(thumb => {
            thumb.classList.remove('drag-over');
        });
    }

    handleThumbnailDragOver(e) {
        if (e.preventDefault) e.preventDefault();
        e.dataTransfer.dropEffect = 'move';

        const target = e.target.closest('.stream-thumbnail');
        if (target && target !== this.draggedThumbnail) {
            target.classList.add('drag-over');
        }
        return false;
    }

    handleThumbnailDrop(e) {
        if (e.stopPropagation) e.stopPropagation();
        e.preventDefault();

        const target = e.target.closest('.stream-thumbnail');
        if (this.draggedThumbnail && target && this.draggedThumbnail !== target) {
            // Get keys
            const draggedKey = this.draggedThumbnail.dataset.streamKey;
            const targetKey = target.dataset.streamKey;

            // Reorder streamOrder
            const draggedIndex = this.streamOrder.indexOf(draggedKey);
            const targetIndex = this.streamOrder.indexOf(targetKey);

            if (draggedIndex !== -1 && targetIndex !== -1) {
                // Simple swap: exchange positions
                this.streamOrder[draggedIndex] = targetKey;
                this.streamOrder[targetIndex] = draggedKey;

                // Reorder DOM elements
                const container = document.getElementById('streamThumbnails');
                const allThumbs = Array.from(container.querySelectorAll('.stream-thumbnail'));

                // Sort thumbnails based on streamOrder
                allThumbs.sort((a, b) => {
                    const aKey = a.dataset.streamKey;
                    const bKey = b.dataset.streamKey;
                    return this.streamOrder.indexOf(aKey) - this.streamOrder.indexOf(bKey);
                });

                // Re-append in correct order
                allThumbs.forEach(thumb => container.appendChild(thumb));

                // Update layer badges
                this.updateLayerBadges();

                this.showNotification('Reihenfolge ge√§ndert', `${draggedKey} verschoben. Ebenen aktualisiert (links=hinten, rechts=vorne)`, 'info');
                console.log('üîÑ Stream-Reihenfolge:', this.streamOrder);
            }
        }

        target?.classList.remove('drag-over');
        return false;
    }

    updateLayerBadges() {
        this.streamOrder.forEach((key, index) => {
            const badge = document.getElementById(`layer-badge-${key}`);
            if (badge) {
                badge.textContent = index + 1;
            }
        });
    }

    toggleStream(streamId) {
        const thumbnail = document.getElementById(`thumbnail-${streamId}`);
        const statusIndicator = document.getElementById(`status-${streamId}`);
        
        if (!thumbnail) return;
        
        const isActive = this.activeStreams.has(streamId);
        
        if (isActive) {
            // Deactivate stream
            this.activeStreams.delete(streamId);
            thumbnail.style.borderColor = '#ffc107'; // Yellow border
            if (statusIndicator) {
                statusIndicator.style.backgroundColor = '#ffc107'; // Yellow for inactive
            }
            console.log(`üü° Stream ${streamId} deaktiviert`);
        } else {
            // Activate stream  
            this.activeStreams.add(streamId);
            thumbnail.style.borderColor = '#28a745'; // Green border
            if (statusIndicator) {
                statusIndicator.style.backgroundColor = '#28a745'; // Green for active
            }
            console.log(`üü¢ Stream ${streamId} aktiviert`);
        }
        
        // Update layout options based on active streams
        this.refreshLayoutChips();
    }

    setStreamDisplayMode(streamId, mode) {
        this.streamDisplayModes.set(streamId, mode);
        console.log(`üì∫ Display-Modus f√ºr ${streamId} ge√§ndert: ${mode}`);

        // Update UI if it's camera
        if (streamId === 'camera') {
            const select = document.getElementById('cameraDisplayMode');
            if (select) select.value = mode;
        }

        // Force re-render to apply new display mode
        if (this.isComposing) {
            this.renderComposition();
        }
    }

    toggleCameraMirror(enabled) {
        this.streamMirror.set('camera', enabled);
        console.log(`ü™û Kamera-Spiegelung: ${enabled ? 'aktiviert' : 'deaktiviert'}`);

        // Force re-render to apply mirror effect
        if (this.isComposing) {
            this.renderComposition();
        }
    }

    setupCanvasInteraction() {
        if (!this.canvas) return;

        // Mouse events for drag and drop
        this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
        this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
        this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));

        // Touch events for mobile
        this.canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e));
        this.canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e));
        this.canvas.addEventListener('touchend', (e) => this.handleTouchEnd(e));
    }

    getCanvasCoordinates(e) {
        const rect = this.canvas.getBoundingClientRect();
        const scaleX = this.canvas.width / rect.width;
        const scaleY = this.canvas.height / rect.height;
        
        return {
            x: (e.clientX - rect.left) * scaleX,
            y: (e.clientY - rect.top) * scaleY
        };
    }

    handleMouseDown(e) {
        if (this.isRecording) return;

        // If not in free layout, check if user wants to interact with canvas
        // If so, switch to free layout automatically
        if (this.currentLayout !== 'free') {
            const coords = this.getCanvasCoordinates(e);
            // Try to detect if clicking on a stream area (rough detection)
            const isClickingOnStream = this.detectStreamClick(coords.x, coords.y);

            if (isClickingOnStream) {
                // Freeze current layout and switch to free
                this.freezeCurrentLayoutAndSwitchToFree();
                // Now proceed with the interaction
            } else {
                return; // Not clicking on a stream, ignore
            }
        }

        const coords = this.getCanvasCoordinates(e);
        const hitTest = this.hitTestFreeLayout(coords.x, coords.y);

        if (hitTest) {
            if (hitTest.type === 'resize') {
                this.isResizing = true;
                this.resizeStream = hitTest.streamId;
                this.resizeHandle = hitTest.handle;
            } else if (hitTest.type === 'drag') {
                this.isDragging = true;
                this.draggedStream = hitTest.streamId;
                const streamData = this.freeLayoutStreams.get(hitTest.streamId);

                // Store original positions (in both screen and canvas coords)
                this.dragStartMouseX = e.clientX;
                this.dragStartMouseY = e.clientY;
                this.dragStartStreamX = streamData.x;
                this.dragStartStreamY = streamData.y;
            }
            this.canvas.style.cursor = hitTest.cursor;
            document.addEventListener('mousemove', this.boundGlobalMouseMove);
            document.addEventListener('mouseup', this.boundGlobalMouseUp);
        }
    }

    detectStreamClick(x, y) {
        // Simple detection: if clicking anywhere on canvas (not edges), assume stream click
        const margin = 50;
        return x > margin && x < this.canvas.width - margin &&
               y > margin && y < this.canvas.height - margin;
    }

    freezeCurrentLayoutAndSwitchToFree() {
        console.log('üé® Auto-Wechsel zu freiem Layout');

        const previousLayout = new Map(this.freeLayoutStreams);
        const activeStreamEntries = Array.from(this.streams.entries())
            .filter(([key]) => this.activeStreams.has(key));
        const activeStreamKeys = activeStreamEntries.map(([key]) => key);

        this.freeLayoutStreams.clear();
        this.streamOrder = [];

        // Calculate positions based on current layout
        switch (this.currentLayout) {
            case 'pip':
                this.freezePipLayout(activeStreamEntries, previousLayout);
                break;
            case 'side':
                this.freezeSideBySideLayout(activeStreamKeys);
                break;
            case 'stack':
                this.freezeStackedLayout(activeStreamKeys);
                break;
            case 'grid2x2':
                this.freezeGrid2x2Layout(activeStreamKeys);
                break;
            case 'threeCols':
                this.freezeThreeColumnsLayout(activeStreamKeys);
                break;
            default:
                // Default: create cascading layout
                this.freezeDefaultLayout(activeStreamKeys);
        }

        if (this.streamOrder.length === 0) {
            this.streamOrder = [...activeStreamKeys];
        }

        // Switch to free layout
        this.currentLayout = 'free';
        this.applyLayout('free');
        this.refreshLayoutChips();

        this.showNotification('Freies Layout aktiviert', 'Sie k√∂nnen jetzt Streams frei positionieren und skalieren', 'info');
    }

    freezePipLayout(activeStreamEntries, previousLayout = new Map()) {
        if (!activeStreamEntries || activeStreamEntries.length === 0) {
            return;
        }

        const usableEntries = activeStreamEntries
            .filter(([key, stream]) => stream && this.activeStreams.has(key));

        if (usableEntries.length === 0) {
            return;
        }

        const usedKeys = new Set();

        const findEntry = (predicate) => usableEntries.find(predicate);

        let backgroundEntry = findEntry(([key]) => key.startsWith('screen')) || usableEntries[0];

        let overlayEntry = null;
        if (backgroundEntry && backgroundEntry[0] !== 'camera') {
            overlayEntry = findEntry(([key]) => key === 'camera');
        }
        if (!overlayEntry) {
            overlayEntry = findEntry(([key]) => key !== backgroundEntry[0]);
        }

        if (backgroundEntry) {
            const [bgKey] = backgroundEntry;
            this.freeLayoutStreams.set(bgKey, {
                x: 0,
                y: 0,
                width: this.canvas.width,
                height: this.canvas.height
            });
            usedKeys.add(bgKey);
        }

        if (overlayEntry && (!backgroundEntry || overlayEntry[0] !== backgroundEntry[0])) {
            const [overlayKey] = overlayEntry;
            const sizeRatio = Math.max(0.1, Math.min(1, this.pipSettings.size / 100));
            const pipWidth = Math.max(80, this.canvas.width * sizeRatio);
            const pipHeight = Math.max(80, this.canvas.height * sizeRatio);

            let x = this.pipSettings.x;
            let y = this.pipSettings.y;

            if (x === 0 && y === 0) {
                x = this.canvas.width - pipWidth - this.pipSettings.padding;
                y = this.pipSettings.padding;
            }

            x = Math.max(0, Math.min(this.canvas.width - pipWidth, x));
            y = Math.max(0, Math.min(this.canvas.height - pipHeight, y));

            this.freeLayoutStreams.set(overlayKey, {
                x,
                y,
                width: pipWidth,
                height: pipHeight
            });
            usedKeys.add(overlayKey);
        }

        let cascadeIndex = 0;
        for (const [key] of usableEntries) {
            if (usedKeys.has(key)) continue;

            const previous = previousLayout.get(key);
            if (previous) {
                this.freeLayoutStreams.set(key, { ...previous });
            } else {
                const offset = cascadeIndex * 30;
                const width = Math.min(this.canvas.width * 0.4, 320);
                const height = Math.min(this.canvas.height * 0.4, 180);
                this.freeLayoutStreams.set(key, {
                    x: this.pipSettings.padding + offset,
                    y: this.pipSettings.padding + offset,
                    width,
                    height
                });
                cascadeIndex++;
            }
        }

        const order = [];
        if (backgroundEntry) order.push(backgroundEntry[0]);
        if (overlayEntry && overlayEntry[0] !== backgroundEntry?.[0]) order.push(overlayEntry[0]);
        for (const [key] of usableEntries) {
            if (!order.includes(key)) {
                order.push(key);
            }
        }
        this.streamOrder = order;
    }

    freezeSideBySideLayout(streamKeys) {
        // Side by side: equal width columns
        const colWidth = Math.floor(this.canvas.width / streamKeys.length);
        streamKeys.forEach((key, index) => {
            this.freeLayoutStreams.set(key, {
                x: index * colWidth,
                y: 0,
                width: colWidth,
                height: this.canvas.height
            });
        });
    }

    freezeStackedLayout(streamKeys) {
        // Stacked: equal height rows
        const rowHeight = Math.floor(this.canvas.height / streamKeys.length);
        streamKeys.forEach((key, index) => {
            this.freeLayoutStreams.set(key, {
                x: 0,
                y: index * rowHeight,
                width: this.canvas.width,
                height: rowHeight
            });
        });
    }

    freezeGrid2x2Layout(streamKeys) {
        // 2x2 grid
        const halfWidth = Math.floor(this.canvas.width / 2);
        const halfHeight = Math.floor(this.canvas.height / 2);
        const positions = [
            { x: 0, y: 0 },
            { x: halfWidth, y: 0 },
            { x: 0, y: halfHeight },
            { x: halfWidth, y: halfHeight }
        ];

        streamKeys.forEach((key, index) => {
            const pos = positions[index] || { x: 0, y: 0 };
            this.freeLayoutStreams.set(key, {
                x: pos.x,
                y: pos.y,
                width: halfWidth,
                height: halfHeight
            });
        });
    }

    freezeThreeColumnsLayout(streamKeys) {
        // 3 columns
        const colWidth = Math.floor(this.canvas.width / 3);
        streamKeys.forEach((key, index) => {
            this.freeLayoutStreams.set(key, {
                x: index * colWidth,
                y: 0,
                width: colWidth,
                height: this.canvas.height
            });
        });
    }

    freezeDefaultLayout(streamKeys) {
        // Cascading default layout
        streamKeys.forEach((key, index) => {
            const offset = index * 50;
            this.freeLayoutStreams.set(key, {
                x: 50 + offset,
                y: 50 + offset,
                width: 400,
                height: 300
            });
        });
    }

    handleMouseMove(e) {
        if (this.isRecording) return;
        if (this.currentLayout !== 'free') return; // Only process in free layout

        if (this.isDragging && this.draggedStream) {
            // Calculate mouse movement delta in screen coordinates
            const deltaScreenX = e.clientX - this.dragStartMouseX;
            const deltaScreenY = e.clientY - this.dragStartMouseY;

            // Convert delta to canvas coordinates
            const rect = this.canvas.getBoundingClientRect();
            const scaleX = this.canvas.width / rect.width;
            const scaleY = this.canvas.height / rect.height;

            const deltaCanvasX = deltaScreenX * scaleX;
            const deltaCanvasY = deltaScreenY * scaleY;

            // Apply delta to stream position
            const streamData = this.freeLayoutStreams.get(this.draggedStream);
            streamData.x = this.dragStartStreamX + deltaCanvasX;
            streamData.y = this.dragStartStreamY + deltaCanvasY;
        } else if (this.isResizing && this.resizeStream) {
            const coords = this.getCanvasCoordinates(e);
            const streamData = this.freeLayoutStreams.get(this.resizeStream);
            const minSize = 50;

            if (this.resizeHandle === 'se') {
                streamData.width = Math.max(minSize, coords.x - streamData.x);
                streamData.height = Math.max(minSize, coords.y - streamData.y);
            }
        } else {
            // Update cursor based on hover
            const coords = this.getCanvasCoordinates(e);
            const hitTest = this.hitTestFreeLayout(coords.x, coords.y);
            this.canvas.style.cursor = hitTest ? hitTest.cursor : 'default';
        }
    }

    handleMouseUp(e) {
        this.isDragging = false;
        this.isResizing = false;
        this.draggedStream = null;
        this.resizeStream = null;
        this.resizeHandle = null;
        this.canvas.style.cursor = 'default';
        document.removeEventListener('mousemove', this.boundGlobalMouseMove);
        document.removeEventListener('mouseup', this.boundGlobalMouseUp);
    }

    handleTouchStart(e) {
        e.preventDefault();
        if (e.touches.length === 1) {
            const touch = e.touches[0];
            this.handleMouseDown({ clientX: touch.clientX, clientY: touch.clientY });
        }
    }

    handleTouchMove(e) {
        e.preventDefault();
        if (e.touches.length === 1) {
            const touch = e.touches[0];
            this.handleMouseMove({ clientX: touch.clientX, clientY: touch.clientY });
        }
    }

    handleTouchEnd(e) {
        e.preventDefault();
        this.handleMouseUp(e);
    }

    hitTestFreeLayout(x, y) {
        const keys = this.streamOrder.length > 0
            ? this.streamOrder.filter(key => this.freeLayoutStreams.has(key))
            : Array.from(this.freeLayoutStreams.keys());

        for (let i = keys.length - 1; i >= 0; i--) {
            const streamId = keys[i];
            const data = this.freeLayoutStreams.get(streamId);
            if (!data) continue;

            // Check resize handle (bottom-right corner)
            const handleSize = 15;
            if (x >= data.x + data.width - handleSize && x <= data.x + data.width &&
                y >= data.y + data.height - handleSize && y <= data.y + data.height) {
                return { type: 'resize', streamId, handle: 'se', cursor: 'se-resize' };
            }
            
            // Check stream area for dragging
            if (x >= data.x && x <= data.x + data.width &&
                y >= data.y && y <= data.y + data.height) {
                return { type: 'drag', streamId, cursor: 'move' };
            }
        }
        return null;
    }

    // Draw video with individual display mode
    drawVideoWithMode(video, streamId, x, y, width, height) {
        const mode = this.streamDisplayModes.get(streamId) || 'cover';
        const shouldMirror = this.streamMirror.get(streamId) || false;

        // Apply mirroring if needed
        if (shouldMirror) {
            this.ctx.save();
            this.ctx.translate(x + width, y);
            this.ctx.scale(-1, 1);
            // Adjust x for mirrored drawing
            x = 0;
        }

        switch (mode) {
            case 'cover':
                // VERZERRT: Streckt/staucht das Video um den Bereich komplett zu f√ºllen (kann verzerren)
                this.drawVideoCover(video, x, y, width, height);
                break;
            case 'contain':
                // EINGEPASST: Video passt komplett rein, beh√§lt Seitenverh√§ltnis (schwarze Balken m√∂glich)
                this.drawVideoContain(video, x, y, width, height);
                break;
            case 'fill':
                // ZUGESCHNITTEN: F√ºllt Bereich komplett, beh√§lt Seitenverh√§ltnis (schneidet ab wo n√∂tig)
                this.drawVideoFill(video, x, y, width, height);
                break;
            case 'crop':
                // ZENTRIERT ZUGESCHNITTEN: Wie "fill" aber schneidet gleichm√§√üig von allen Seiten ab
                this.drawVideoCrop(video, x, y, width, height);
                break;
            default:
                this.drawVideoCover(video, x, y, width, height);
        }

        // Restore context after mirroring
        if (shouldMirror) {
            this.ctx.restore();
        }
    }

    drawVideoFill(video, x, y, width, height) {
        // WICHTIG: IMMER das normale Video zeichnen
        // Green Screen Effekt wird in onSegmentationResults angewendet
        // Niemals das segmentationCanvas hier direkt zeichnen!
        if (false) { // Diese Bedingung absichtlich deaktiviert

            // Draw the segmentation canvas instead of the video
            const canvas = this.backgroundEffects.segmentationCanvas;
            const vw = canvas.width;
            const vh = canvas.height;
            const videoAspect = vw / vh;
            const canvasAspect = width / height;
            
            if (videoAspect > canvasAspect) {
                // Video is wider - fit height and crop width
                const drawWidth = height * videoAspect;
                const offsetX = (drawWidth - width) / 2;
                this.ctx.drawImage(canvas, offsetX, 0, width, height);
            } else {
                // Video is taller - fit width and crop height
                const drawHeight = width / videoAspect;
                const offsetY = (drawHeight - height) / 2;
                this.ctx.drawImage(canvas, 0, offsetY, width, height);
            }
            return;
        }
        
        // Normal video handling
        const vw = video.videoWidth || video.width || 16;
        const vh = video.videoHeight || video.height || 9;
        const videoAspect = vw / vh;
        const canvasAspect = width / height;
        
        if (videoAspect > canvasAspect) {
            // Video is wider - fit height and crop width
            const drawWidth = height * videoAspect;
            const offsetX = (drawWidth - width) / 2;
            this.ctx.drawImage(video, x - offsetX, y, drawWidth, height);
        } else {
            // Video is taller - fit width and crop height
            const drawHeight = width / videoAspect;
            const offsetY = (drawHeight - height) / 2;
            this.ctx.drawImage(video, x, y - offsetY, width, drawHeight);
        }
    }

    drawVideoCrop(video, x, y, width, height) {
        // Center crop - crop video to exact dimensions
        const videoAspect = video.videoWidth / video.videoHeight;
        const targetAspect = width / height;
        
        let sx = 0, sy = 0, sWidth = video.videoWidth, sHeight = video.videoHeight;
        
        if (videoAspect > targetAspect) {
            // Video is wider - crop horizontally
            sWidth = video.videoHeight * targetAspect;
            sx = (video.videoWidth - sWidth) / 2;
        } else {
            // Video is taller - crop vertically  
            sHeight = video.videoWidth / targetAspect;
            sy = (video.videoHeight - sHeight) / 2;
        }
        
        this.ctx.drawImage(video, sx, sy, sWidth, sHeight, x, y, width, height);
    }

    renderFreeLayout(streams) {
        // Only render streams that are both active AND in free layout
        const availableStreams = new Map(streams);

        // Remove streams from free layout that are no longer available
        for (const streamId of this.freeLayoutStreams.keys()) {
            if (!availableStreams.has(streamId)) {
                this.freeLayoutStreams.delete(streamId);
            }
        }

        // üéØ QUALITY OPTIMIZATION: Adaptive settings f√ºr Free Layout
        const streamCount = this.freeLayoutStreams.size;
        const qualitySettings = this.getAdaptiveRenderingSettings(streamCount);

        // üîÑ NEW: Render in order of streamOrder (left=back, right=front)
        // Use streamOrder if available, otherwise use freeLayoutStreams order
        const orderedKeys = this.streamOrder.length > 0
            ? this.streamOrder.filter(key => this.freeLayoutStreams.has(key))
            : Array.from(this.freeLayoutStreams.keys());

        // Render each stream in order
        for (const streamId of orderedKeys) {
            const stream = availableStreams.get(streamId);
            const streamData = this.freeLayoutStreams.get(streamId);
            
            if (!stream || !streamData) continue;

            const video = this.getVideoElementOptimized(streamId, stream);
            if (!video || video.readyState < 2) continue;

            // üöÄ Apply quality optimizations
            this.applyVideoQualitySettings(video, qualitySettings);

            // Draw stream using actual stored dimensions
            this.drawVideoWithMode(video, streamId,
                streamData.x,
                streamData.y,
                streamData.width,
                streamData.height);

            // Draw border (only when not recording)
            if (!this.isRecording) {
                this.ctx.strokeStyle = '#ffffff';
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(streamData.x, streamData.y, streamData.width, streamData.height);
            }

            // Draw resize handle (only when not recording)
            if (!this.isRecording) {
                const handleSize = 15;
                this.ctx.fillStyle = '#ffffff';
                this.ctx.fillRect(
                    streamData.x + streamData.width - handleSize, 
                    streamData.y + streamData.height - handleSize, 
                    handleSize, 
                    handleSize
                );
                
                // Draw resize handle lines
                this.ctx.strokeStyle = '#000000';
                this.ctx.lineWidth = 1;
                const hx = streamData.x + streamData.width - handleSize;
                const hy = streamData.y + streamData.height - handleSize;
                for (let i = 0; i < 3; i++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(hx + i * 5 + 5, hy + handleSize);
                    this.ctx.lineTo(hx + handleSize, hy + i * 5 + 5);
                    this.ctx.stroke();
                }
            }

            // Draw stream label (only when not recording)
            if (!this.isRecording) {
                this.ctx.fillStyle = '#000000';
                this.ctx.fillRect(streamData.x, streamData.y, 100, 20);
                this.ctx.fillStyle = '#ffffff';
                this.ctx.font = '12px Arial';
                const label = streamId === 'camera' ? 'Kamera' : streamId.startsWith('screen') ? `Bildschirm ${streamId.replace('screen', '')}` : streamId;
                this.ctx.fillText(label, streamData.x + 5, streamData.y + 14);
            }
        }
    }

    initializeFreeLayoutStream(streamId) {
        const existingCount = this.freeLayoutStreams.size;
        // 150% gr√∂√üere Anfangsgr√∂√üen (urspr√ºnglich 200x150, jetzt 300x225)
        const defaultWidth = 300;  // 200 * 1.5
        const defaultHeight = 225; // 150 * 1.5
        const margin = 20;
        
        // Calculate position to avoid overlaps (weniger Streams pro Reihe wegen gr√∂√üerer Gr√∂√üe)
        const streamsPerRow = Math.max(1, Math.floor((this.canvas.width - margin) / (defaultWidth + margin)));
        const x = margin + (existingCount % streamsPerRow) * (defaultWidth + margin);
        const y = margin + Math.floor(existingCount / streamsPerRow) * (defaultHeight + margin);
        
        // Ensure streams fit within canvas
        const finalX = Math.min(x, Math.max(0, this.canvas.width - defaultWidth - margin));
        const finalY = Math.min(y, Math.max(0, this.canvas.height - defaultHeight - margin));
        
        this.freeLayoutStreams.set(streamId, {
            x: finalX,
            y: finalY,
            width: defaultWidth,
            height: defaultHeight
        });
        
        console.log(`üéØ Stream ${streamId} f√ºr freies Layout initialisiert (Gr√∂√üe: ${defaultWidth}x${defaultHeight}, Position: ${finalX},${finalY})`);
    }

    handleThumbnailClick(streamId) {
        if (this.currentLayout === 'free') {
            // In free layout mode: add/remove stream from free layout (doesn't affect active status)
            if (!this.freeLayoutStreams.has(streamId)) {
                this.initializeFreeLayoutStream(streamId);
                this.updateThumbnailForFreeLayout(streamId, true);
                console.log(`‚ûï Stream ${streamId} zum freien Layout hinzugef√ºgt`);
            } else {
                // Remove from free layout if already there
                this.freeLayoutStreams.delete(streamId);
                this.updateThumbnailForFreeLayout(streamId, false);
                console.log(`‚ûñ Stream ${streamId} aus freiem Layout entfernt`);
            }
        } else {
            // In other layouts: toggle stream active/inactive
            this.toggleStream(streamId);
        }
    }

    updateThumbnailForFreeLayout(streamId, isInFreeLayout) {
        const thumbnail = document.getElementById(`thumbnail-${streamId}`);
        const statusIndicator = document.getElementById(`status-${streamId}`);
        
        if (thumbnail) {
            if (isInFreeLayout) {
                thumbnail.style.borderColor = '#007bff'; // Blue border for free layout
                if (statusIndicator) {
                    statusIndicator.style.backgroundColor = '#007bff';
                }
            } else {
                thumbnail.style.borderColor = '#6c757d'; // Gray border when not in free layout
                if (statusIndicator) {
                    statusIndicator.style.backgroundColor = '#6c757d';
                }
            }
        }
    }

    updateThumbnailsForLayoutChange() {
        // Update all thumbnail appearances based on current layout
        for (const streamId of this.streams.keys()) {
            const thumbnail = document.getElementById(`thumbnail-${streamId}`);
            const statusIndicator = document.getElementById(`status-${streamId}`);
            
            if (!thumbnail || !statusIndicator) continue;
            
            if (this.currentLayout === 'free') {
                // In free layout: show blue if in free layout, gray if not
                if (this.freeLayoutStreams.has(streamId)) {
                    thumbnail.style.borderColor = '#007bff'; // Blue
                    statusIndicator.style.backgroundColor = '#007bff';
                } else {
                    thumbnail.style.borderColor = '#6c757d'; // Gray
                    statusIndicator.style.backgroundColor = '#6c757d';
                }
            } else {
                // In other layouts: show green if active, yellow if inactive
                if (this.activeStreams.has(streamId)) {
                    thumbnail.style.borderColor = '#28a745'; // Green
                    statusIndicator.style.backgroundColor = '#28a745';
                } else {
                    thumbnail.style.borderColor = '#ffc107'; // Yellow
                    statusIndicator.style.backgroundColor = '#ffc107';
                }
            }
        }
    }

    removeStreamCompletely(streamId) {
        console.log(`üóëÔ∏è Stream ${streamId} wird komplett entfernt`);
        
        if (streamId === 'camera') {
            // Remove camera stream
            this.stopCamera();
        } else if (streamId.startsWith('screen')) {
            // Remove specific screen stream
            this.removeScreen(streamId);
        }
    }

    // üé§ Audio Level Monitoring
    setupAudioLevelMonitoring() {
        // Try to get audio from existing streams
        let audioStream = null;
        
        if (this.streams.has('camera')) {
            const cameraStream = this.streams.get('camera');
            const audioTracks = cameraStream.getAudioTracks();
            if (audioTracks.length > 0) {
                audioStream = new MediaStream(audioTracks);
            }
        }
        
        if (!audioStream) {
            // Get microphone directly
            navigator.mediaDevices.getUserMedia({ audio: true })
                .then(stream => {
                    this.startAudioLevelMonitoring(stream);
                })
                .catch(err => {
                    console.warn('Audio monitoring failed:', err);
                    this.updateAudioStatus('Mikrofon nicht verf√ºgbar');
                });
        } else {
            this.startAudioLevelMonitoring(audioStream);
        }
    }
    
    startAudioLevelMonitoring(audioStream) {
        try {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const source = this.audioContext.createMediaStreamSource(audioStream);
            this.audioAnalyser = this.audioContext.createAnalyser();
            this.audioAnalyser.fftSize = 256;
            
            // Create gain node for volume control
            this.audioGainNode = this.audioContext.createGain();
            source.connect(this.audioGainNode);
            this.audioGainNode.connect(this.audioAnalyser);
            
            // Set initial volume
            const volumeSlider = document.getElementById('microphoneVolume');
            if (volumeSlider) {
                this.setMicrophoneVolume(volumeSlider.value);
                volumeSlider.addEventListener('input', (e) => {
                    this.setMicrophoneVolume(e.target.value);
                });
            }
            
            this.monitorAudioLevelWithVolume();
            this.updateAudioStatus('Audio aktiv');
        } catch (error) {
            console.error('Audio level monitoring error:', error);
            this.updateAudioStatus('Audio-Fehler');
        }
    }
    
    monitorAudioLevel() {
        const bufferLength = this.audioAnalyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        
        const updateLevel = () => {
            if (!this.audioAnalyser) return;
            
            this.audioAnalyser.getByteFrequencyData(dataArray);
            
            let sum = 0;
            for (let i = 0; i < bufferLength; i++) {
                sum += dataArray[i];
            }
            const average = sum / bufferLength;
            const percentage = (average / 255) * 100;
            
            const levelFill = document.getElementById('audioLevelFill');
            if (levelFill) {
                levelFill.style.width = percentage + '%';
            }
            
            requestAnimationFrame(updateLevel);
        };
        
        updateLevel();
    }
    
    updateAudioStatus(message) {
        const statusEl = document.getElementById('audioStatus');
        if (statusEl) {
            statusEl.textContent = `Status: ${message}`;
        }
    }
    
    updateAudioStatusBadge(status) {
        const badge = document.getElementById('audioStatusBadge');
        if (badge) {
            const icon = badge.querySelector('i');
            if (icon) {
                // Remove all status classes
                icon.classList.remove('text-secondary', 'text-success', 'text-danger', 'text-warning');
                
                // Add appropriate status class
                switch(status) {
                    case 'success':
                        icon.classList.add('text-success');
                        console.log('üü¢ Audio Status Badge: GR√úN (success)');
                        break;
                    case 'danger':
                        icon.classList.add('text-danger');
                        console.log('üî¥ Audio Status Badge: ROT (danger)');
                        break;
                    case 'warning':
                        icon.classList.add('text-warning');
                        console.log('üü° Audio Status Badge: GELB (warning)');
                        break;
                    default:
                        icon.classList.add('text-secondary');
                        console.log('‚ö´ Audio Status Badge: GRAU (secondary)');
                }
                
                // Debug info
                console.log(`üîß Audio Badge Classes: ${icon.className}`);
            } else {
                console.error('‚ùå Audio Status Badge: Icon nicht gefunden');
            }
        } else {
            console.error('‚ùå Audio Status Badge: Element nicht gefunden');
        }
    }
    
    checkAudioStream() {
        const audioEnabled = document.getElementById('audioEnabled')?.checked;
        if (audioEnabled) {
            // Check if any stream has audio
            let hasAudioStream = false;
            
            for (const [streamId, stream] of this.streams) {
                if (stream && stream.getAudioTracks().length > 0) {
                    hasAudioStream = true;
                    break;
                }
            }
            
            if (hasAudioStream) {
                this.updateAudioStatusBadge('success');
                this.updateAudioStatus('Audio aktiv');
            } else {
                this.updateAudioStatusBadge('warning');
                this.updateAudioStatus('Warten auf Audio-Stream');
            }
        } else {
            this.updateAudioStatusBadge('secondary');
            this.updateAudioStatus('Audio deaktiviert');
        }
    }

    // Get audio constraints based on settings modal
    getAudioConstraints() {
        const audioEnabled = document.getElementById('audioEnabled')?.checked !== false;
        
        if (!audioEnabled) {
            return false;
        }

        // Get selected microphone device
        const microphoneSelect = document.getElementById('microphoneSelect');
        const audioDeviceId = microphoneSelect ? microphoneSelect.value : undefined;

        // Get audio processing settings from settings modal
        const agcEnabled = document.getElementById('settingsAGC')?.checked !== false;
        const noiseSuppressionEnabled = document.getElementById('settingsNoiseSuppression')?.checked !== false;
        const echoCancellationEnabled = document.getElementById('settingsEchoCancellation')?.checked !== false;

        const audioConstraints = {
            autoGainControl: agcEnabled,
            noiseSuppression: noiseSuppressionEnabled,
            echoCancellation: echoCancellationEnabled,
            sampleRate: 44100,
            channelCount: 2
        };
        
        // Add specific device if selected
        if (audioDeviceId) {
            audioConstraints.deviceId = { exact: audioDeviceId };
        }

        console.log('üéõÔ∏è Audio Constraints from Settings:', {
            agc: agcEnabled,
            noiseSuppression: noiseSuppressionEnabled,
            echoCancellation: echoCancellationEnabled,
            deviceId: audioDeviceId || 'default'
        });

        return audioConstraints;
    }

    setMicrophoneVolume(value) {
        if (this.audioGainNode) {
            // Convert 0-100 to 0-2 gain (allowing up to 2x amplification)
            const gainValue = (value / 100) * 2;
            this.audioGainNode.gain.setValueAtTime(gainValue, this.audioContext.currentTime);
            
            // Update display
            const volumeDisplay = document.getElementById('volumeDisplay');
            if (volumeDisplay) {
                volumeDisplay.textContent = `${value}%`;
            }
            
            console.log(`üé§ Mikrofonlautst√§rke gesetzt: ${value}% (Gain: ${gainValue.toFixed(2)})`);
        }
    }

    // Enhanced audio monitoring with volume visualization
    monitorAudioLevelWithVolume() {
        const bufferLength = this.audioAnalyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        
        const updateLevel = () => {
            if (!this.audioAnalyser) return;
            
            this.audioAnalyser.getByteFrequencyData(dataArray);
            
            let sum = 0;
            for (let i = 0; i < bufferLength; i++) {
                sum += dataArray[i];
            }
            const average = sum / bufferLength;
            
            // Apply volume scaling to visualization
            const volumeSlider = document.getElementById('microphoneVolume');
            const volumeMultiplier = volumeSlider ? (volumeSlider.value / 100) : 1;
            const adjustedAverage = Math.min(255, average * volumeMultiplier * 2);
            const percentage = (adjustedAverage / 255) * 100;
            
            const levelFill = document.getElementById('audioLevelFill');
            if (levelFill) {
                levelFill.style.width = percentage + '%';
                
                // Add visual feedback for volume changes
                if (percentage > 80) {
                    levelFill.style.background = 'linear-gradient(90deg, #28a745 0%, #ffc107 50%, #dc3545 100%)';
                } else if (percentage > 50) {
                    levelFill.style.background = 'linear-gradient(90deg, #28a745 0%, #ffc107 100%)';
                } else {
                    levelFill.style.background = '#28a745';
                }
            }
            
            requestAnimationFrame(updateLevel);
        };
        
        updateLevel();
    }

    // Quick Audio Recording functionality
    async setupQuickAudioRecording() {
        const recordBtn = document.getElementById('quickAudioRecordBtn');
        const volumeSlider = document.getElementById('quickMicrophoneVolume');
        const volumeDisplay = document.getElementById('quickVolumeDisplay');
        
        if (!recordBtn) return;

        // Initialize quick audio state
        this.quickAudioRecording = false;
        this.quickAudioRecorder = null;
        this.quickAudioChunks = [];

        recordBtn.addEventListener('click', () => this.toggleQuickAudioRecord());
        
        if (volumeSlider) {
            volumeSlider.addEventListener('input', (e) => {
                this.setQuickMicrophoneVolume(e.target.value);
            });
        }

        // Setup quick audio monitoring
        try {
            const constraints = this.getAudioConstraints();
            const stream = await navigator.mediaDevices.getUserMedia({ audio: constraints });
            this.quickAudioStream = stream;
            this.startAudioLevelMonitoring(stream);
            this.updateQuickAudioStatus('Bereit');
        } catch (error) {
            console.error('Quick audio setup failed:', error);
            this.updateQuickAudioStatus('Mikrofon nicht verf√ºgbar');
        }
    }

    async toggleQuickAudioRecord() {
        if (!this.quickAudioRecording) {
            await this.startQuickAudioRecord();
        } else {
            this.stopQuickAudioRecord();
        }
    }

    async startQuickAudioRecord() {
        try {
            if (!this.quickAudioStream) {
                const constraints = this.getAudioConstraints();
                this.quickAudioStream = await navigator.mediaDevices.getUserMedia({ audio: constraints });
            }

            // Get quality settings
            const qualitySelect = document.getElementById('quickAudioQuality');
            const quality = qualitySelect?.value || 'medium';
            
            const audioBitrate = {
                'high': 192000,
                'medium': 128000,
                'low': 96000
            }[quality] || 128000;

            const options = {
                mimeType: 'audio/webm;codecs=opus',
                audioBitsPerSecond: audioBitrate
            };

            this.quickAudioChunks = [];
            this.quickAudioRecorder = new MediaRecorder(this.quickAudioStream, options);

            this.quickAudioRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    this.quickAudioChunks.push(event.data);
                }
            };

            this.quickAudioRecorder.onstop = () => {
                this.handleQuickAudioRecordingComplete();
            };

            this.quickAudioRecorder.start();
            this.quickAudioRecording = true;

            // Update UI
            const recordBtn = document.getElementById('quickAudioRecordBtn');
            recordBtn.innerHTML = '<i class="fas fa-stop me-2"></i>Stop Record';
            recordBtn.classList.remove('btn-danger');
            recordBtn.classList.add('btn-success');

            this.updateQuickAudioStatus('Aufnahme l√§uft...');

        } catch (error) {
            console.error('Quick audio record start failed:', error);
            this.updateQuickAudioStatus('Aufnahme-Fehler');
        }
    }

    stopQuickAudioRecord() {
        if (this.quickAudioRecorder && this.quickAudioRecording) {
            this.quickAudioRecorder.stop();
            this.quickAudioRecording = false;

            // Update UI
            const recordBtn = document.getElementById('quickAudioRecordBtn');
            recordBtn.innerHTML = '<i class="fas fa-microphone me-2"></i>Audio Record';
            recordBtn.classList.remove('btn-success');
            recordBtn.classList.add('btn-danger');

            this.updateQuickAudioStatus('Aufnahme beendet');
        }
    }

    handleQuickAudioRecordingComplete() {
        if (this.quickAudioChunks.length > 0) {
            const blob = new Blob(this.quickAudioChunks, { type: 'audio/webm' });
            const url = URL.createObjectURL(blob);
            
            // Create download link
            const a = document.createElement('a');
            const filename = `quick_audio_${new Date().toISOString().slice(0, 19).replace(/[:.]/g, '-')}.webm`;
            a.href = url;
            a.download = filename;
            a.click();
            
            URL.revokeObjectURL(url);
            this.updateQuickAudioStatus(`Download: ${filename}`);
        }
    }

    setQuickMicrophoneVolume(value) {
        if (this.audioGainNode) {
            const gainValue = (value / 100) * 2;
            this.audioGainNode.gain.setValueAtTime(gainValue, this.audioContext.currentTime);
            
            const volumeDisplay = document.getElementById('quickVolumeDisplay');
            if (volumeDisplay) {
                volumeDisplay.textContent = `${value}%`;
            }
        }
    }

    updateQuickAudioStatus(message) {
        const statusEl = document.getElementById('quickAudioStatus');
        if (statusEl) {
            statusEl.textContent = `Status: ${message}`;
        }
    }
}

// Initialize when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        window.streamRecorder = new StreamRecorderOptimized();
        window.streamrecApp = window.streamRecorder; // Alias for button callbacks
        
        // Start audio monitoring after short delay
        setTimeout(() => {
            window.streamRecorder.setupAudioLevelMonitoring();
        }, 1000);
    });
} else {
    window.streamRecorder = new StreamRecorderOptimized();
    window.streamrecApp = window.streamRecorder; // Alias for button callbacks
    
    // Start audio monitoring and quick audio after short delay
    setTimeout(() => {
        window.streamRecorder.setupAudioLevelMonitoring();
        window.streamRecorder.setupQuickAudioRecording();
    }, 1000);
}

console.log('‚úÖ Performance Optimized StreamRec loaded');
</script>
{% endblock %}
