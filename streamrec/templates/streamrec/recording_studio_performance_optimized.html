{% extends 'base.html' %}
{% load static %}

{% block title %}StreamRec - Studio{% endblock %}

{% block page_css %}
<!-- PYTHONANYWHERE OPTIMIZED: Inline CSS for better loading -->
<style>
/* StreamRec Base Styles - Inline for PythonAnywhere */
:root {
    --streamrec-primary: #667eea;
    --streamrec-secondary: #764ba2;
    --streamrec-success: #28a745;
    --streamrec-warning: #ffc107;
    --streamrec-danger: #dc3545;
    --streamrec-info: #17a2b8;
    --streamrec-border-radius: 0.5rem;
    --streamrec-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);
    --streamrec-transition: all 0.2s ease-in-out;
}

.streamrec-btn {
    transition: var(--streamrec-transition);
    border-radius: var(--streamrec-border-radius);
    font-weight: 500;
}

.streamrec-btn:hover {
    transform: translateY(-1px);
    box-shadow: var(--streamrec-shadow);
}

.text-gradient {
    background: linear-gradient(135deg, var(--streamrec-primary) 0%, var(--streamrec-secondary) 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.recording-dot {
    width: 8px;
    height: 8px;
    background: #ffffff;
    border-radius: 50%;
    animation: recordPulse 1.5s ease-in-out infinite;
}

@keyframes recordPulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.3; }
}

/* System Info Grid */
.system-info-item {
    padding: 0.5rem;
    text-align: center;
}

.system-info-item small {
    display: block;
    margin-bottom: 0.25rem;
}
/* Performance Optimized Studio Styles */
.studio-container {
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    min-height: 100vh;
    padding: 2rem 0;
}

.studio-header {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
    color: #ffffff !important;
    padding: 2rem 0;
    margin-bottom: 2rem;
    border-radius: 0 0 2rem 2rem;
    box-shadow: 0 4px 20px rgba(102, 126, 234, 0.15);
}

.studio-header h1, .studio-header p, .studio-header i,
.studio-header .phase-indicator, .studio-header .stat-value,
.studio-header .stat-label {
    color: #ffffff !important;
}

.control-panel {
    background: white;
    border-radius: var(--streamrec-border-radius, 0.5rem);
    box-shadow: var(--streamrec-shadow, 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075));
    padding: 1.5rem;
    margin-bottom: 1.5rem;
    transition: var(--streamrec-transition, all 0.2s);
}

.control-panel:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 30px rgba(102, 126, 234, 0.2);
}

.preview-area {
    background: #1a1a1a;
    border-radius: var(--streamrec-border-radius, 0.5rem);
    padding: 1rem;
    box-shadow: var(--streamrec-shadow, 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075));
    min-height: calc(100vh - 180px);
    position: sticky;
    top: 1rem;
}

.phase-indicator {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    background: rgba(255, 255, 255, 0.2);
    padding: 0.5rem 1rem;
    border-radius: 2rem;
    font-size: 0.875rem;
}

.phase-badge {
    background: #ffffff !important;
    color: #4b3ba8 !important;
    padding: 0.25rem 0.75rem;
    border-radius: 1rem;
    font-weight: 600;
    font-size: 0.75rem;
}

/* Performance Indicator */
.performance-indicator {
    position: fixed;
    top: 80px;
    right: 10px;
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 0.5rem;
    border-radius: 0.5rem;
    font-size: 0.75rem;
    z-index: 9999;
    min-width: 200px;
}

.performance-good { border-left: 4px solid #28a745; }
.performance-warning { border-left: 4px solid #ffc107; }
.performance-critical { border-left: 4px solid #dc3545; }

/* CRITICAL FIX: Visibility */
.control-panel, .control-panel *, 
#recordingControlsContainer, #recordingControlsContainer * {
    color: #212529 !important;
    background-color: transparent !important;
}

.control-panel {
    background-color: #ffffff !important;
    border: 1px solid #dee2e6 !important;
}

/* Button fixes */
.btn-primary { background-color: #0d6efd !important; border-color: #0d6efd !important; color: #ffffff !important; }
.btn-success { background-color: #198754 !important; border-color: #198754 !important; color: #ffffff !important; }
.btn-danger { background-color: #dc3545 !important; border-color: #dc3545 !important; color: #ffffff !important; }
.btn-warning { background-color: #fd7e14 !important; border-color: #fd7e14 !important; color: #ffffff !important; }
.btn-info { background-color: #0dcaf0 !important; border-color: #0dcaf0 !important; color: #000000 !important; }
.btn-secondary { background-color: #6c757d !important; border-color: #6c757d !important; color: #ffffff !important; }

.form-select, .form-control { color: #212529 !important; background-color: #ffffff !important; border-color: #ced4da !important; }
</style>
{% endblock %}

{% block fullscreen_content %}
<div class="studio-container">
    <!-- Performance Indicator -->
    <div id="performanceIndicator" class="performance-indicator performance-good" style="display: none;">
        <div><strong>Performance</strong></div>
        <div>FPS: <span id="fpsCounter">30</span></div>
        <div>Frames: <span id="frameCounter">0</span></div>
        <div>Dropped: <span id="droppedCounter">0</span></div>
        <div>Render: <span id="renderTime">0ms</span></div>
    </div>

    <!-- Enhanced Header -->
    <div class="studio-header">
        <div class="container-fluid">
            <div class="row align-items-center">
                <div class="col-md-8">
                    <h1 class="display-5 fw-bold mb-2">
                        <i class="fas fa-video-camera me-3"></i>
                        StreamRec Studio
                    </h1>
                    <p class="lead mb-0">Ultra-schnelle Multi-Stream Video Aufnahme</p>
                    <div class="phase-indicator mt-3">
                        <i class="fas fa-rocket"></i>
                        <span>Performance Edition</span>
                        <div class="phase-badge">Anti-Freeze Technology</div>
                    </div>
                </div>
                <div class="col-md-4 text-md-end">
                    <div class="studio-stats">
                        <div class="row text-center">
                            <div class="col-4">
                                <div class="stat-value">3:00</div>
                                <div class="stat-label">Max. Dauer</div>
                            </div>
                            <div class="col-4">
                                <div class="stat-value">9:16</div>
                                <div class="stat-label">Format</div>
                            </div>
                            <div class="col-4">
                                <div class="stat-value" id="activeStreams">0</div>
                                <div class="stat-label">Streams</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="container-fluid">
        <div class="row">
            <!-- Left Column: All Controls -->
            <div class="col-12 col-lg-4 col-xl-3">
                <!-- Stream Controls -->
                <div class="control-panel">
                    <h5 class="mb-4">
                        <i class="fas fa-sliders-h me-2"></i>
                        Stream Kontrolle
                    </h5>
                    
                    <!-- Camera Section -->
                    <div class="mb-4">
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <h6 class="mb-0">
                                <i class="fas fa-camera text-success me-2"></i>Kamera
                            </h6>
                            <div class="status-indicator" id="cameraStatusBadge">
                                <i class="fas fa-circle text-secondary"></i>
                            </div>
                        </div>
                        <div class="d-grid gap-2">
                            <button id="startCameraBtn" class="btn btn-outline-success">
                                <i class="fas fa-play me-2"></i>Kamera starten
                            </button>
                            <button id="stopCameraBtn" class="btn btn-outline-danger" disabled>
                                <i class="fas fa-stop me-2"></i>Kamera stoppen
                            </button>
                        </div>
                        <small id="cameraStatus" class="text-muted d-block mt-2">Status: Nicht aktiv</small>
                    </div>

                    <!-- Screen Section -->
                    <div class="mb-4">
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <h6 class="mb-0">
                                <i class="fas fa-desktop text-info me-2"></i>Bildschirm
                            </h6>
                            <div class="status-indicator" id="screenStatusBadge">
                                <i class="fas fa-circle text-secondary"></i>
                            </div>
                        </div>
                        <div class="d-grid gap-2">
                            <button id="startScreenBtn" class="btn btn-outline-info">
                                <i class="fas fa-desktop me-2"></i>Bildschirm teilen
                            </button>
                            <button id="addScreenBtn" class="btn btn-outline-success" disabled>
                                <i class="fas fa-plus me-2"></i>Weiteren Bildschirm hinzuf√ºgen
                            </button>
                            <button id="stopAllScreensBtn" class="btn btn-outline-danger" disabled>
                                <i class="fas fa-stop me-2"></i>Alle Bildschirme stoppen
                            </button>
                        </div>
                        
                        <!-- Active Screen Streams List -->
                        <div id="activeScreens" class="mt-3" style="display: none;">
                            <h6 class="small text-muted mb-2">Aktive Bildschirme:</h6>
                            <div id="screenStreamsList" class="d-flex flex-column gap-1"></div>
                        </div>
                        <small id="screenStatus" class="text-muted d-block mt-2">Status: Nicht aktiv</small>
                    </div>

                    <!-- Layout-Schnellwahl -->
                    <div class="mt-4">
                        <div class="d-flex align-items-center justify-content-between mb-2">
                            <h6 class="mb-0">
                                <i class="fas fa-th-large text-info me-2"></i>Layout-Schnellwahl
                            </h6>
                            <small class="text-muted" id="layoutStreamCount">0 Streams</small>
                        </div>
                        <div id="layoutChips" class="d-flex flex-wrap gap-1"></div>
                    </div>

                </div>

                <!-- Phase 2: Layout Manager -->
                <div class="control-panel" id="layoutControls">
                    <h5 class="mb-4">
                        <i class="fas fa-th-large me-2"></i>
                        Layout Manager
                        <span class="badge bg-primary ms-2">Phase 2</span>
                    </h5>
                    <div id="layoutControlsContent">
                        <div class="alert alert-info" id="layoutManagerPlaceholder">
                            <i class="fas fa-info-circle me-2"></i>
                            Starten Sie Kamera oder Bildschirm-Sharing, um verf√ºgbare Layouts zu sehen
                        </div>
                    </div>
                </div>

                <!-- System Information -->
                <div class="control-panel">
                    <h5 class="mb-4">
                        <i class="fas fa-info-circle me-2"></i>
                        System Information
                    </h5>
                    <div class="row">
                        <div class="col-6">
                            <div class="system-info-item">
                                <small class="text-muted">Browser:</small>
                                <div id="browserInfo" class="fw-bold">-</div>
                            </div>
                        </div>
                        <div class="col-6">
                            <div class="system-info-item">
                                <small class="text-muted">WebRTC:</small>
                                <div id="webrtcSupport" class="fw-bold">-</div>
                            </div>
                        </div>
                        <div class="col-6">
                            <div class="system-info-item">
                                <small class="text-muted">Canvas:</small>
                                <div id="canvasSupport" class="fw-bold">-</div>
                            </div>
                        </div>
                        <div class="col-6">
                            <div class="system-info-item">
                                <small class="text-muted">Recording:</small>
                                <div id="mediaRecorderSupport" class="fw-bold">-</div>
                            </div>
                        </div>
                    </div>
                    <div id="performanceMetrics" class="mt-3 text-center">
                        <small class="text-muted">Performance wird √ºberwacht...</small>
                    </div>
                </div>

                <!-- Quick Actions -->
                <div class="control-panel">
                    <h5 class="mb-4">
                        <i class="fas fa-bolt me-2"></i>
                        Schnellaktionen
                    </h5>
                    <div class="d-grid gap-2">
                        <button class="btn btn-outline-primary" onclick="window.location.reload()">
                            <i class="fas fa-redo me-2"></i>Neu laden
                        </button>
                        <button class="btn btn-outline-secondary" data-bs-toggle="modal" data-bs-target="#settingsModal">
                            <i class="fas fa-cog me-2"></i>Einstellungen
                        </button>
                        <a href="{% url 'streamrec:dashboard' %}" class="btn btn-outline-info">
                            <i class="fas fa-arrow-left me-2"></i>Dashboard
                        </a>
                    </div>
                </div>

                <!-- Recording Controls -->
                <div class="control-panel" id="recordingControlsContainer">
                    <h5 class="mb-4">
                        <i class="fas fa-record-vinyl me-2 text-danger"></i>
                        Aufnahme Kontrolle
                    </h5>
                    
                    <div class="d-grid gap-2 mb-3">
                        <button id="recordBtn" class="btn btn-danger">
                            <i class="fas fa-circle me-2"></i>Aufnahme starten
                        </button>
                        <div class="d-flex gap-2">
                            <button id="pauseBtn" class="btn btn-warning flex-fill" disabled>
                                <i class="fas fa-pause me-2"></i>Pausieren
                            </button>
                            <button id="stopRecordBtn" class="btn btn-outline-danger flex-fill" disabled>
                                <i class="fas fa-stop me-2"></i>Stoppen
                            </button>
                        </div>
                    </div>
                    
                    <div class="text-center">
                        <div id="recordingStatus" class="small mb-2">Status: Bereit f√ºr Aufnahme</div>
                        <div class="progress mb-2" style="height: 8px;">
                            <div id="recordingProgress" class="progress-bar bg-danger" style="width: 0%"></div>
                        </div>
                        <div class="d-flex justify-content-between small text-muted">
                            <span id="recordingTime">00:00</span>
                            <span>03:00</span>
                        </div>
                        <div class="mt-2">
                            <span class="badge bg-secondary" id="recordingStateIndicator">
                                <i class="fas fa-stop me-1"></i>Gestoppt
                            </span>
                        </div>
                    </div>
                </div>

            </div>

            <!-- Right Column: Preview Area and Recording -->
            <div class="col-12 col-lg-8 col-xl-9">
                <div class="preview-area">
                    <!-- Preview Header -->
                    <div class="d-flex justify-content-between align-items-center mb-3">
                        <h5 class="text-white mb-0">
                            <i class="fas fa-eye me-2"></i>
                            Live Vorschau (Performance Optimized)
                        </h5>
                        <div class="preview-controls">
                            <button class="btn btn-sm btn-outline-light me-2" id="fullscreenBtn">
                                <i class="fas fa-expand"></i>
                            </button>
                            <div class="btn-group" role="group">
                                <button class="btn btn-sm btn-outline-light" id="gridToggle">
                                    <i class="fas fa-th"></i>
                                </button>
                                <button class="btn btn-sm btn-outline-light" id="zoomFit">
                                    <i class="fas fa-compress-arrows-alt"></i>
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Canvas Container -->
                    <div id="previewContainer" class="position-relative d-flex align-items-center justify-content-center" 
                         style="height: 600px; border-radius: 0.5rem; overflow: hidden;">
                        
                        <canvas id="compositionCanvas" 
                                width="360" 
                                height="640" 
                                class="border border-secondary"
                                style="max-width: 100%; max-height: 100%; object-fit: contain;">
                        </canvas>
                        
                        <!-- No Content Overlay -->
                        <div id="noContentOverlay" class="position-absolute top-50 start-50 translate-middle text-center text-white">
                            <div class="mb-4">
                                <i class="fas fa-video fa-4x mb-3 opacity-25"></i>
                                <h4>Keine Streams aktiv</h4>
                                <p class="text-muted">Starten Sie Kamera oder Bildschirm-Sharing um zu beginnen</p>
                            </div>
                            <div class="d-grid gap-2 d-md-flex justify-content-md-center">
                                <button class="btn btn-success" onclick="document.getElementById('startCameraBtn').click()">
                                    <i class="fas fa-camera me-2"></i>Kamera starten
                                </button>
                                <button class="btn btn-info" onclick="document.getElementById('startScreenBtn').click()">
                                    <i class="fas fa-desktop me-2"></i>Bildschirm teilen
                                </button>
                            </div>
                        </div>

                        <!-- Recording Indicator -->
                        <div id="recordingIndicator" class="position-absolute top-0 start-0 m-3" style="display: none;">
                            <div class="d-flex align-items-center bg-danger text-white px-3 py-2 rounded-pill">
                                <div class="recording-dot me-2"></div>
                                <span class="fw-bold">REC</span>
                                <span class="ms-2" id="recordingTimeIndicator">00:00</span>
                            </div>
                        </div>

                        <!-- Countdown Overlay -->
                        <div id="countdownOverlay" class="position-absolute top-50 start-50 translate-middle" style="display:none;">
                            <div class="bg-dark bg-opacity-75 text-white rounded px-5 py-4">
                                <div id="countdownNumber" class="display-3 fw-bold text-center">3</div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Stream Thumbnails -->
                    <div class="mt-4">
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <h6 class="text-white mb-0">Aktive Streams:</h6>
                            <div class="stream-controls-mini">
                                <button class="btn btn-sm btn-outline-light" id="syncStreams" title="Streams synchronisieren">
                                    <i class="fas fa-sync-alt"></i>
                                </button>
                                <button class="btn btn-sm btn-outline-light" data-bs-toggle="modal" data-bs-target="#settingsModal" title="Einstellungen">
                                    <i class="fas fa-cog"></i>
                                </button>
                            </div>
                        </div>
                        <div id="streamThumbnails" class="d-flex gap-3 flex-wrap">
                            <div id="noStreamsMessage" class="text-muted text-center flex-grow-1 py-4">
                                <i class="fas fa-info-circle me-2"></i>
                                Noch keine Streams erfasst
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Settings Modal -->
<div class="modal fade" id="settingsModal" tabindex="-1" aria-labelledby="settingsModalLabel">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header bg-primary text-white">
                <h5 class="modal-title" id="settingsModalLabel">
                    <i class="fas fa-cog me-2"></i>Performance Einstellungen
                </h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <div class="row">
                    <div class="col-md-6">
                        <h6>Video-Einstellungen</h6>
                        <div class="mb-3">
                            <label class="form-label">Aufl√∂sung:</label>
                            <select class="form-select" id="resolutionSetting">
                                <option value="720p" selected>720p (HD) - Empfohlen</option>
                                <option value="1080p">1080p (Full HD) - High-End PCs</option>
                                <option value="480p">480p (SD) - Langsame PCs</option>
                            </select>
                        </div>
                        <div class="mb-3">
                            <label class="form-label">Bitrate:</label>
                            <select class="form-select" id="bitrateSetting">
                                <option value="2000000" selected>2 Mbps (Ausgewogen)</option>
                                <option value="4000000">4 Mbps (Hohe Qualit√§t)</option>
                                <option value="1000000">1 Mbps (Sparsam)</option>
                                <option value="500000">0.5 Mbps (Minimum)</option>
                            </select>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <h6>Performance-Einstellungen</h6>
                        <div class="form-check mb-3">
                            <input class="form-check-input" type="checkbox" id="enableFrameSkipping" checked>
                            <label class="form-check-label" for="enableFrameSkipping">
                                Frame Skipping aktivieren (Anti-Freeze)
                            </label>
                        </div>
                        <div class="form-check mb-3">
                            <input class="form-check-input" type="checkbox" id="enablePerformanceMonitor">
                            <label class="form-check-label" for="enablePerformanceMonitor">
                                Performance Monitor anzeigen
                            </label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="enableErrorRecovery" checked>
                            <label class="form-check-label" for="enableErrorRecovery">
                                Automatische Fehlerkorrektur
                            </label>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Abbrechen</button>
                <button type="button" class="btn btn-primary" id="saveSettings">
                    <i class="fas fa-save me-2"></i>Speichern
                </button>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block page_js %}
<script>
console.log('üöÄ StreamRec Performance Optimized Version (PythonAnywhere Ready) wird geladen...');

/**
 * üöÄ PERFORMANCE OPTIMIZED StreamRec - PYTHONANYWHERE EDITION
 * Anti-Freeze Technology mit intelligenter Frame-Rate Kontrolle
 * Optimiert f√ºr Server-Deployment mit minimalen Abh√§ngigkeiten
 */
class StreamRecorderOptimized {
    constructor() {
        // Basic properties
        this.streams = new Map();
        this.activeStreams = new Set(); // Tracks which streams are currently active for rendering
        this.canvas = null;
        this.ctx = null;
        this.isComposing = false;
        this.animationFrame = null;
        this.currentLayout = 'pip';
        this.mediaRecorder = null;
        this.recordedChunks = [];
        this.isRecording = false;
        this.recordingStartTime = null;
        this.recordingTimer = null;
        this.maxDuration = 180000; // 3 minutes
        this.nextScreenId = 1; // Screen counter for multiple screens
        this.streamDisplayModes = new Map(); // Individual display modes for streams
        this.freeLayoutStreams = new Map(); // Free layout stream positions and sizes
        this.isDragging = false;
        this.isResizing = false;
        this.draggedStream = null;
        this.resizeStream = null;
        this.dragOffset = { x: 0, y: 0 };
        this.resizeHandle = null;
        
        // üöÄ PERFORMANCE OPTIMIZATIONS
        this.videoElements = new Map(); // Video Element Pool
        this.lastRenderTime = 0;
        this.targetFPS = 30;
        this.frameInterval = 1000 / this.targetFPS;
        this.skipFrameCount = 0;
        this.maxSkipFrames = 2;
        this.performanceMetrics = {
            droppedFrames: 0,
            totalFrames: 0,
            averageRenderTime: 0,
            lastFPS: 0
        };
        this.performanceBuffer = [];
        this.lastFPSUpdate = 0;
        this.enableFrameSkipping = true;
        this.enableErrorRecovery = true;
        this.renderTimeBuffer = [];
        
        this.init();
    }

    init() {
        this.canvas = document.getElementById('compositionCanvas');
        if (!this.canvas) {
            console.error('‚ùå Canvas nicht gefunden');
            return;
        }
        
        this.ctx = this.canvas.getContext('2d');
        this.setupEventListeners();
        this.setupCanvasInteraction();
        this.checkBrowserSupport();
        this.initPerformanceMonitoring();
        this.loadSettings();
        this.refreshLayoutChips();
        
        console.log('‚úÖ StreamRec Performance Optimized initialisiert');
    }

    setupEventListeners() {
        // Camera controls
        document.getElementById('startCameraBtn')?.addEventListener('click', () => this.startCamera());
        document.getElementById('stopCameraBtn')?.addEventListener('click', () => this.stopCamera());
        
        // Screen controls
        document.getElementById('startScreenBtn')?.addEventListener('click', () => this.startScreen());
        document.getElementById('addScreenBtn')?.addEventListener('click', () => this.addScreen());
        document.getElementById('stopAllScreensBtn')?.addEventListener('click', () => this.stopAllScreens());
        
        // Recording controls
        document.getElementById('recordBtn')?.addEventListener('click', () => this.startRecordingWithCountdown());
        document.getElementById('stopRecordBtn')?.addEventListener('click', () => this.stopRecording());
        document.getElementById('pauseBtn')?.addEventListener('click', () => this.togglePauseRecording());

        // Performance controls
        document.getElementById('fpsSelect')?.addEventListener('change', (e) => {
            this.targetFPS = parseInt(e.target.value);
            this.frameInterval = 1000 / this.targetFPS;
        });

        document.getElementById('qualitySelect')?.addEventListener('change', (e) => {
            this.applyQualitySettings(e.target.value);
        });

        document.getElementById('showPerformance')?.addEventListener('change', (e) => {
            this.togglePerformanceMonitor(e.target.checked);
        });

        // Settings
        document.getElementById('saveSettings')?.addEventListener('click', () => this.saveSettings());

        // Fullscreen
        document.getElementById('fullscreenBtn')?.addEventListener('click', () => {
            if (this.canvas.requestFullscreen) {
                this.canvas.requestFullscreen();
            }
        });

        // Layout Controls (delegierte Events f√ºr beide Bereiche)
        this.setupLayoutEventHandlers();
    }

    setupLayoutEventHandlers() {
        // Event Handler f√ºr Layout-Chips (kleine Buttons)
        document.getElementById('layoutChips')?.addEventListener('click', (e) => {
            const btn = e.target.closest('button[data-layout]');
            if (!btn) return;
            
            e.preventDefault();
            e.stopPropagation();
            const layout = btn.getAttribute('data-layout');
            this.selectLayout(layout);
        });

        // Event Handler f√ºr Layout Manager (gro√üe Cards) - nur Button clicks
        document.getElementById('layoutControlsContent')?.addEventListener('click', (e) => {
            // Nur auf Button-Klicks reagieren, nicht auf Card-Klicks
            const btn = e.target.closest('button[data-layout]');
            if (!btn) {
                // Fallback: Card-Klick (aber nicht Button-Bereich)
                const card = e.target.closest('.layout-preset-card[data-layout]');
                if (card && !e.target.closest('button')) {
                    const layout = card.getAttribute('data-layout');
                    this.selectLayout(layout);
                }
                return;
            }
            
            e.preventDefault();
            e.stopPropagation();
            const layout = btn.getAttribute('data-layout');
            this.selectLayout(layout);
        });
    }

    selectLayout(layout) {
        console.log(`üéØ Layout ausgew√§hlt: ${layout}`);
        
        // Layout anwenden
        this.applyLayout(layout);
        
        // Rendering starten falls nicht aktiv
        if (!this.isComposing) {
            this.startRenderLoop();
        }
        
        // UI aktualisieren
        this.updateLayoutUI(layout);
    }

    updateLayoutUI(layout) {
        // WICHTIG: Komplett neu rendern statt Klassen zu manipulieren
        // Das verhindert CSS-Klassen-Konflikte bei den Layout Cards
        
        // Aktuelle Stream-Anzahl ermitteln
        const count = this.streams.size;
        const layouts = this.getAvailableLayouts(count);
        
        // Neu rendern mit korrektem aktuellen Layout
        this.refreshLayoutChips();
        this.updateLayoutManager(layouts);
        
        console.log(`üé® Layout UI komplett neu gerendert f√ºr: ${layout}`);
    }

    checkBrowserSupport() {
        console.log('üîç Starting Browser Support Check...');
        
        const support = {
            getUserMedia: !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia),
            getDisplayMedia: !!(navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia),
            canvas: !!(this.canvas && this.ctx),
            mediaRecorder: !!(window.MediaRecorder)
        };
        
        // Mit setTimeout sicherstellen, dass DOM-Elemente bereit sind
        setTimeout(() => {
            try {
                // Browser Information
                const browserInfo = this.getBrowserInfo();
                const browserElement = document.getElementById('browserInfo');
                if (browserElement) {
                    browserElement.textContent = browserInfo;
                    console.log('‚úÖ Browser Info gesetzt:', browserInfo);
                } else {
                    console.error('‚ùå browserInfo Element nicht gefunden');
                }
                
                // WebRTC Support
                const webrtcStatus = support.getUserMedia && support.getDisplayMedia ? '‚úì Unterst√ºtzt' : '‚ùå Nicht verf√ºgbar';
                const webrtcElement = document.getElementById('webrtcSupport');
                if (webrtcElement) {
                    webrtcElement.textContent = webrtcStatus;
                    webrtcElement.className = `fw-bold ${support.getUserMedia && support.getDisplayMedia ? 'text-success' : 'text-danger'}`;
                    console.log('‚úÖ WebRTC Info gesetzt:', webrtcStatus);
                } else {
                    console.error('‚ùå webrtcSupport Element nicht gefunden');
                }
                
                // Canvas Support
                const canvasStatus = support.canvas ? '‚úì Verf√ºgbar' : '‚ùå Fehler';
                const canvasElement = document.getElementById('canvasSupport');
                if (canvasElement) {
                    canvasElement.textContent = canvasStatus;
                    canvasElement.className = `fw-bold ${support.canvas ? 'text-success' : 'text-danger'}`;
                    console.log('‚úÖ Canvas Info gesetzt:', canvasStatus);
                } else {
                    console.error('‚ùå canvasSupport Element nicht gefunden');
                }
                
                // MediaRecorder Support
                const recorderStatus = support.mediaRecorder ? '‚úì Verf√ºgbar' : '‚ùå Nicht unterst√ºtzt';
                const recorderElement = document.getElementById('mediaRecorderSupport');
                if (recorderElement) {
                    recorderElement.textContent = recorderStatus;
                    recorderElement.className = `fw-bold ${support.mediaRecorder ? 'text-success' : 'text-danger'}`;
                    console.log('‚úÖ Recorder Info gesetzt:', recorderStatus);
                } else {
                    console.error('‚ùå mediaRecorderSupport Element nicht gefunden');
                }
                
                console.log('üìä System Information erfolgreich aktualisiert');
            } catch (error) {
                console.error('‚ùå Fehler beim Aktualisieren der System Info:', error);
            }
        }, 100); // 100ms Verz√∂gerung f√ºr DOM-Bereitschaft
        
        console.log('üîç Browser Support:', support);
        return support;
    }
    
    getBrowserInfo() {
        const ua = navigator.userAgent;
        
        if (ua.includes('Firefox')) {
            const version = ua.match(/Firefox\/(\d+)/)?.[1];
            return `Firefox ${version || '?'}`;
        } else if (ua.includes('Chrome') && !ua.includes('Edge')) {
            const version = ua.match(/Chrome\/(\d+)/)?.[1];
            return `Chrome ${version || '?'}`;
        } else if (ua.includes('Safari') && !ua.includes('Chrome')) {
            const version = ua.match(/Safari\/(\d+)/)?.[1];
            return `Safari ${version || '?'}`;
        } else if (ua.includes('Edge')) {
            const version = ua.match(/Edge\/(\d+)/)?.[1];
            return `Edge ${version || '?'}`;
        } else {
            return 'Unbekannt';
        }
    }

    getBrowserInfo() {
        const ua = navigator.userAgent;
        if (ua.includes('Chrome')) return 'Chrome';
        if (ua.includes('Firefox')) return 'Firefox';
        if (ua.includes('Safari')) return 'Safari';
        if (ua.includes('Edge')) return 'Edge';
        return 'Unbekannt';
    }

    async startCamera() {
        try {
            this.updateStatus('camera', 'Kamera wird gestartet...', 'info');
            
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { 
                    width: { ideal: 1280 },
                    height: { ideal: 720 },
                    frameRate: { ideal: this.targetFPS }
                },
                audio: true
            });

            this.streams.set('camera', stream);
            this.activeStreams.add('camera');
            this.streamDisplayModes.set('camera', 'cover'); // Default for camera
            this.updateStatus('camera', 'Aktiv', 'success');
            this.updateButtons('camera', true);
            this.updateStatusBadge('camera', 'success');
            this.addStreamThumbnail('camera', stream);
            this.checkCompositionReady();
            this.updateActiveStreamsCount();
            this.refreshLayoutChips();

            console.log('‚úÖ Kamera-Stream erfolgreich gestartet');
        } catch (error) {
            console.error('‚ùå Kamera-Zugriff fehlgeschlagen:', error);
            this.updateStatus('camera', `Fehler: ${error.message}`, 'danger');
            this.updateStatusBadge('camera', 'danger');
        }
    }

    async startScreen() {
        this.nextScreenId = 1; // Initialize screen counter
        return this.addScreen();
    }

    async addScreen() {
        try {
            const screenId = `screen${this.nextScreenId}`;
            this.updateStatus('screen', 'Bildschirm-Sharing wird gestartet...', 'info');
            
            const stream = await navigator.mediaDevices.getDisplayMedia({
                video: {
                    width: { ideal: 1920 },
                    height: { ideal: 1080 },
                    frameRate: { ideal: this.targetFPS },
                    cursor: 'always'
                },
                audio: true
            });

            this.streams.set(screenId, stream);
            this.nextScreenId++;
            
            // Update UI based on number of screens
            const screenCount = Array.from(this.streams.keys()).filter(k => k.startsWith('screen')).length;
            this.updateStatus('screen', `${screenCount} Bildschirm(e) aktiv`, 'success');
            this.updateScreenButtons();
            this.updateStatusBadge('screen', 'success');
            this.addStreamThumbnail(screenId, stream);
            this.updateScreensList();
            this.checkCompositionReady();
            this.updateActiveStreamsCount();
            this.refreshLayoutChips();

            // Handle screen sharing end event
            stream.getVideoTracks()[0].addEventListener('ended', () => {
                this.removeScreen(screenId);
            });

            console.log(`‚úÖ Bildschirm-Stream ${screenId} erfolgreich gestartet`);
        } catch (error) {
            console.error('‚ùå Bildschirm-Capture fehlgeschlagen:', error);
            this.updateStatus('screen', `Fehler: ${error.message}`, 'danger');
            this.updateStatusBadge('screen', 'danger');
        }
    }

    stopCamera() {
        const stream = this.streams.get('camera');
        if (stream) {
            stream.getTracks().forEach(track => track.stop());
            this.streams.delete('camera');
            this.cleanupVideoElement('camera');
            this.updateStatus('camera', 'Nicht aktiv', 'secondary');
            this.updateButtons('camera', false);
            this.updateStatusBadge('camera', 'secondary');
            this.removeStreamThumbnail('camera');
            this.updateActiveStreamsCount();
            this.refreshLayoutChips();
            this.checkCompositionReady();
        }
    }

    removeScreen(screenId) {
        const stream = this.streams.get(screenId);
        if (stream) {
            stream.getTracks().forEach(track => track.stop());
            this.streams.delete(screenId);
            this.cleanupVideoElement(screenId);
            this.removeStreamThumbnail(screenId);
            this.updateScreenStatus();
            this.updateScreenButtons();
            this.updateScreensList();
            this.updateActiveStreamsCount();
            this.refreshLayoutChips();
            this.checkCompositionReady();
        }
    }

    stopAllScreens() {
        const screenIds = Array.from(this.streams.keys()).filter(k => k.startsWith('screen'));
        screenIds.forEach(screenId => this.removeScreen(screenId));
    }

    updateScreenStatus() {
        const screenCount = Array.from(this.streams.keys()).filter(k => k.startsWith('screen')).length;
        if (screenCount === 0) {
            this.updateStatus('screen', 'Nicht aktiv', 'secondary');
            this.updateStatusBadge('screen', 'secondary');
        } else {
            this.updateStatus('screen', `${screenCount} Bildschirm(e) aktiv`, 'success');
            this.updateStatusBadge('screen', 'success');
        }
    }

    updateScreenButtons() {
        const screenCount = Array.from(this.streams.keys()).filter(k => k.startsWith('screen')).length;
        const addBtn = document.getElementById('addScreenBtn');
        const stopAllBtn = document.getElementById('stopAllScreensBtn');
        
        if (addBtn) addBtn.disabled = false; // Always allow adding more screens
        if (stopAllBtn) stopAllBtn.disabled = screenCount === 0;
    }

    updateScreensList() {
        const screenIds = Array.from(this.streams.keys()).filter(k => k.startsWith('screen'));
        const activeScreensDiv = document.getElementById('activeScreens');
        const listDiv = document.getElementById('screenStreamsList');
        
        if (screenIds.length > 0) {
            activeScreensDiv.style.display = 'block';
            listDiv.innerHTML = screenIds.map(screenId => {
                const currentMode = this.streamDisplayModes.get(screenId) || 'cover';
                return `
                <div class="d-flex justify-content-between align-items-center small bg-light rounded p-2 mb-2">
                    <div class="d-flex align-items-center flex-grow-1">
                        <i class="fas fa-desktop me-2"></i>
                        <span class="me-3">${screenId === 'screen1' ? 'Bildschirm 1' : screenId.replace('screen', 'Bildschirm ')}</span>
                        
                        <select class="form-select form-select-sm me-2" style="width: auto; min-width: 140px;" 
                                onchange="streamrecApp.setStreamDisplayMode('${screenId}', this.value)">
                            <option value="cover" ${currentMode === 'cover' ? 'selected' : ''}>Verzerrt (f√ºllt komplett)</option>
                            <option value="contain" ${currentMode === 'contain' ? 'selected' : ''}>Eingepasst (schwarze Balken)</option>
                            <option value="fill" ${currentMode === 'fill' ? 'selected' : ''}>Zugeschnitten (keine Verzerrung)</option>
                            <option value="crop" ${currentMode === 'crop' ? 'selected' : ''}>Zentriert zugeschnitten</option>
                        </select>
                    </div>
                    
                    <button class="btn btn-sm btn-outline-danger" onclick="streamrecApp.removeScreen('${screenId}')">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                `;
            }).join('');
        } else {
            activeScreensDiv.style.display = 'none';
        }
    }

    startRenderLoop() {
        if (this.streams.size === 0) {
            console.log('‚è∏Ô∏è Keine Streams verf√ºgbar - warte auf Streams');
            return;
        }
        
        this.isComposing = true;
        this.renderComposition();
        console.log('‚úÖ Rendering Loop gestartet');
    }

    stopRenderLoop() {
        this.isComposing = false;
        
        if (this.animationFrame) {
            cancelAnimationFrame(this.animationFrame);
        }
        
        this.clearCanvas();
        console.log('üõë Rendering Loop gestoppt');
    }

    // üöÄ OPTIMIZED RENDERING ENGINE
    renderComposition() {
        if (!this.isComposing) return;

        const now = performance.now();
        const elapsed = now - this.lastRenderTime;
        
        // üéØ FRAME-RATE KONTROLLE: Nur rendern wenn Frame-Intervall erreicht
        if (elapsed >= this.frameInterval) {
            const renderStart = performance.now();
            
            // Frame Skip Logic bei Performance-Problemen
            if (!this.enableFrameSkipping || this.skipFrameCount < this.maxSkipFrames || elapsed >= this.frameInterval * 2) {
                this.clearCanvas();
                const hasValidStreams = this.renderCurrentLayout();
                
                // Nur rendern wenn g√ºltige Streams vorhanden
                if (hasValidStreams) {
                    this.updateRecordingIndicator();
                    this.skipFrameCount = 0;
                } else if (this.enableFrameSkipping) {
                    this.skipFrameCount++;
                }
                
                this.lastRenderTime = now;
                this.updatePerformanceMetrics(performance.now() - renderStart);
            } else if (this.enableFrameSkipping) {
                this.skipFrameCount++;
                this.performanceMetrics.droppedFrames++;
            }
        }
        
        this.animationFrame = requestAnimationFrame(() => this.renderComposition());
    }

    renderCurrentLayout() {
        // Only render active streams
        const allStreams = Array.from(this.streams.entries());
        const activeStreams = allStreams.filter(([type, stream]) => this.activeStreams.has(type));
        let hasValidStreams = false;
        
        // üîç Vorab-Check: Mindestens ein aktiver Stream bereit?
        for (const [type, stream] of activeStreams) {
            const video = this.getVideoElementOptimized(type, stream);
            if (video && video.readyState >= 2 && !video.paused) {
                hasValidStreams = true;
                break;
            }
        }
        
        if (!hasValidStreams) {
            return false; // Kein g√ºltiger Stream
        }
        
        try {
            switch (this.currentLayout) {
                case 'fullscreen':
                    this.renderFullscreen(activeStreams);
                    break;
                case 'pip':
                    this.renderPictureInPicture(activeStreams);
                    break;
                case 'side':
                    this.renderSideBySide(activeStreams);
                    break;
                case 'stack':
                    this.renderStacked(activeStreams);
                    break;
                case 'threeCols':
                    this.renderThreeColumns(activeStreams);
                    break;
                case 'leftBigRight2':
                    this.renderLeftBigRightTwo(activeStreams);
                    break;
                case 'grid2x2':
                    this.renderGrid2x2(activeStreams);
                    break;
                case 'free':
                    this.renderFreeLayout(activeStreams);
                    break;
                default:
                    // Default: Intelligente Auswahl basierend auf Stream-Anzahl
                    this.renderSmartDefault(activeStreams);
            }
            return true;
        } catch (error) {
            console.warn('‚ö†Ô∏è Render error:', error);
            if (this.enableErrorRecovery) {
                this.handleRenderError(error);
            }
            return false;
        }
    }

    renderPictureInPicture(streams) {
        if (streams.length < 2) {
            // Falls weniger als 2 Streams, Vollbild verwenden
            this.renderFullscreen(streams);
            return;
        }

        const map = new Map(streams);
        
        // Background: prefer any screen stream, fallback to first stream
        let bgEntry = null;
        // Find first screen stream (screen1, screen2, etc.)
        for (const [type, stream] of streams) {
            if (type.startsWith('screen')) {
                bgEntry = [type, stream];
                break;
            }
        }
        // If no screen stream found, use first stream
        if (!bgEntry) {
            bgEntry = streams[0];
        }
        
        // Draw background stream with its display mode
        if (bgEntry) {
            const [bgType, bgStream] = bgEntry;
            const bgVideo = this.getVideoElementOptimized(bgType, bgStream);
            if (bgVideo && bgVideo.readyState >= 2) {
                this.drawVideoWithMode(bgVideo, bgType, 0, 0, this.canvas.width, this.canvas.height);
            }
        }

        // Overlay: Find overlay stream (prefer camera, but exclude background stream)
        let overlayEntry = null;
        if (map.has('camera') && bgEntry[0] !== 'camera') {
            overlayEntry = ['camera', map.get('camera')];
        } else {
            // Use first stream that's not the background
            for (const [type, stream] of streams) {
                if (type !== bgEntry[0]) {
                    overlayEntry = [type, stream];
                    break;
                }
            }
        }

        // Draw overlay stream
        if (overlayEntry) {
            const [overlayType, overlayStream] = overlayEntry;
            const overlayVideo = this.getVideoElementOptimized(overlayType, overlayStream);
            if (overlayVideo && overlayVideo.readyState >= 2) {
                const size = 120;
                const x = this.canvas.width - size - 20;
                const y = 20;
                
                // White border
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = 3;
                this.ctx.strokeRect(x - 3, y - 3, size + 6, size + 6);
                
                // Draw overlay video with its display mode
                this.drawVideoWithMode(overlayVideo, overlayType, x, y, size, size);
            }
        }
    }

    renderSideBySide(streams) {
        const streamArray = Array.from(streams).slice(0, 2); // Nur 2 Streams
        const halfWidth = this.canvas.width / 2;
        
        streamArray.forEach(([type, stream], index) => {
            const video = this.getVideoElementOptimized(type, stream);
            if (!video || video.readyState < 2) return;
            
            const x = index * halfWidth;
            this.drawVideoWithMode(video, type, x, 0, halfWidth, this.canvas.height);
            
            // Draw separator
            if (index === 0 && streamArray.length > 1) {
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(halfWidth, 0);
                this.ctx.lineTo(halfWidth, this.canvas.height);
                this.ctx.stroke();
            }
        });
    }

    renderFullscreen(streams) {
        // Vollbild: Ersten verf√ºgbaren Stream verwenden
        const streamArray = Array.from(streams);
        if (streamArray.length === 0) return;
        
        const [type, stream] = streamArray[0];
        const video = this.getVideoElementOptimized(type, stream);
        if (video && video.readyState >= 2) {
            this.drawVideoWithMode(video, type, 0, 0, this.canvas.width, this.canvas.height);
        }
    }

    renderStacked(streams) {
        // Gestapelt: Streams √ºbereinander
        const streamArray = Array.from(streams).slice(0, 2);
        const halfHeight = this.canvas.height / 2;
        
        streamArray.forEach(([type, stream], index) => {
            const video = this.getVideoElementOptimized(type, stream);
            if (!video || video.readyState < 2) return;
            
            const y = index * halfHeight;
            this.drawVideoWithMode(video, type, 0, y, this.canvas.width, halfHeight);
            
            // Draw separator
            if (index === 0 && streamArray.length > 1) {
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(0, halfHeight);
                this.ctx.lineTo(this.canvas.width, halfHeight);
                this.ctx.stroke();
            }
        });
    }

    renderThreeColumns(streams) {
        // 3 Spalten Layout
        const streamArray = Array.from(streams).slice(0, 3);
        const colWidth = this.canvas.width / 3;
        
        streamArray.forEach(([type, stream], index) => {
            const video = this.getVideoElementOptimized(type, stream);
            if (!video || video.readyState < 2) return;
            
            const x = index * colWidth;
            this.drawVideoContain(video, x, 0, colWidth, this.canvas.height);
            
            // Draw separators
            if (index < streamArray.length - 1) {
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(x + colWidth, 0);
                this.ctx.lineTo(x + colWidth, this.canvas.height);
                this.ctx.stroke();
            }
        });
    }

    renderLeftBigRightTwo(streams) {
        // Links gro√ü, rechts zwei kleine
        const streamArray = Array.from(streams).slice(0, 3);
        if (streamArray.length === 0) return;
        
        const leftWidth = this.canvas.width * 0.6;
        const rightWidth = this.canvas.width * 0.4;
        const rightHalfHeight = this.canvas.height / 2;
        
        // Linker gro√üer Stream
        const [mainType, mainStream] = streamArray[0];
        const mainVideo = this.getVideoElementOptimized(mainType, mainStream);
        if (mainVideo && mainVideo.readyState >= 2) {
            this.drawVideoContain(mainVideo, 0, 0, leftWidth, this.canvas.height);
        }
        
        // Rechte zwei kleinere Streams
        streamArray.slice(1, 3).forEach(([type, stream], index) => {
            const video = this.getVideoElementOptimized(type, stream);
            if (!video || video.readyState < 2) return;
            
            const y = index * rightHalfHeight;
            this.drawVideoContain(video, leftWidth, y, rightWidth, rightHalfHeight);
        });
        
        // Separators
        this.ctx.strokeStyle = '#fff';
        this.ctx.lineWidth = 2;
        // Vertical separator
        this.ctx.beginPath();
        this.ctx.moveTo(leftWidth, 0);
        this.ctx.lineTo(leftWidth, this.canvas.height);
        this.ctx.stroke();
        // Horizontal separator (rechts)
        if (streamArray.length > 2) {
            this.ctx.beginPath();
            this.ctx.moveTo(leftWidth, rightHalfHeight);
            this.ctx.lineTo(this.canvas.width, rightHalfHeight);
            this.ctx.stroke();
        }
    }

    renderGrid2x2(streams) {
        // 2x2 Raster Layout
        const streamArray = Array.from(streams).slice(0, 4);
        const halfWidth = this.canvas.width / 2;
        const halfHeight = this.canvas.height / 2;
        
        const positions = [
            { x: 0, y: 0 },                    // Top-left
            { x: halfWidth, y: 0 },             // Top-right
            { x: 0, y: halfHeight },            // Bottom-left
            { x: halfWidth, y: halfHeight }     // Bottom-right
        ];
        
        streamArray.forEach(([type, stream], index) => {
            const video = this.getVideoElementOptimized(type, stream);
            if (!video || video.readyState < 2) return;
            
            const pos = positions[index];
            this.drawVideoContain(video, pos.x, pos.y, halfWidth, halfHeight);
        });
        
        // Draw grid separators
        this.ctx.strokeStyle = '#fff';
        this.ctx.lineWidth = 2;
        // Vertical separator
        this.ctx.beginPath();
        this.ctx.moveTo(halfWidth, 0);
        this.ctx.lineTo(halfWidth, this.canvas.height);
        this.ctx.stroke();
        // Horizontal separator
        this.ctx.beginPath();
        this.ctx.moveTo(0, halfHeight);
        this.ctx.lineTo(this.canvas.width, halfHeight);
        this.ctx.stroke();
    }

    renderSmartDefault(streams) {
        // Intelligente Standard-Auswahl basierend auf Stream-Anzahl
        const count = streams.length;
        
        if (count === 1) {
            this.renderFullscreen(streams);
        } else if (count === 2) {
            this.renderPictureInPicture(streams);
        } else if (count === 3) {
            this.renderLeftBigRightTwo(streams);
        } else if (count >= 4) {
            this.renderGrid2x2(streams);
        }
    }

    // üöÄ OPTIMIZED: Video Element Pool Management
    getVideoElementOptimized(type, stream) {
        // 1. Check pool first (Performance)
        if (this.videoElements.has(type)) {
            const video = this.videoElements.get(type);
            if (video.srcObject === stream && video.readyState >= 2) {
                return video;
            }
        }
        
        // 2. Check existing video element
        let video = document.getElementById(`video-${type}`);
        if (video && video.srcObject === stream) {
            if (video.readyState >= 2) {
                this.videoElements.set(type, video);
                return video;
            }
            return null; // Video not ready yet
        }
        
        // 3. Create new video element (last resort)
        if (!video) {
            video = document.createElement('video');
            video.id = `video-${type}`;
            video.autoplay = true;
            video.muted = true;
            video.playsInline = true;
            video.style.display = 'none';
            video.style.position = 'absolute';
            video.style.top = '-9999px';
            document.body.appendChild(video);
            
            // üéØ PERFORMANCE: Only set if necessary
            if (video.srcObject !== stream) {
                video.srcObject = stream;
            }
            
            // Optimized playback start
            const initVideo = async () => {
                try {
                    if (video.readyState >= 2) {
                        await video.play();
                        this.videoElements.set(type, video);
                    } else {
                        video.addEventListener('loadedmetadata', async () => {
                            try {
                                await video.play();
                                this.videoElements.set(type, video);
                            } catch (err) {
                                console.warn('Video play failed:', err);
                            }
                        }, { once: true });
                    }
                } catch (err) {
                    console.warn('Video init failed:', err);
                }
            };
            
            initVideo();
            return null; // Not ready immediately
        }
        
        return video.readyState >= 2 ? video : null;
    }

    cleanupVideoElement(type) {
        if (this.videoElements.has(type)) {
            this.videoElements.delete(type);
        }
        
        const video = document.getElementById(`video-${type}`);
        if (video) {
            video.srcObject = null;
            video.remove();
        }
    }

    // Helper: draw video preserving aspect ratio (contain)
    drawVideoContain(video, dx, dy, dw, dh) {
        const vw = video.videoWidth || 16;
        const vh = video.videoHeight || 9;
        const videoAspect = vw / vh;
        const targetAspect = dw / dh;
        
        let renderW, renderH, x, y;
        if (videoAspect > targetAspect) {
            renderW = dw;
            renderH = dw / videoAspect;
            x = dx;
            y = dy + (dh - renderH) / 2;
        } else {
            renderH = dh;
            renderW = dh * videoAspect;
            x = dx + (dw - renderW) / 2;
            y = dy;
        }
        
        this.ctx.drawImage(video, x, y, renderW, renderH);
    }

    // Helper: draw video covering target rect (cover) with cropping
    drawVideoCover(video, dx, dy, dw, dh) {
        const vw = video.videoWidth || 16;
        const vh = video.videoHeight || 9;
        const videoAspect = vw / vh;
        const targetAspect = dw / dh;
        
        let sx = 0, sy = 0, sw = vw, sh = vh;
        if (videoAspect > targetAspect) {
            sw = vh * targetAspect;
            sx = (vw - sw) / 2;
        } else {
            sh = vw / targetAspect;
            sy = (vh - sh) / 2;
        }
        
        this.ctx.drawImage(video, sx, sy, sw, sh, dx, dy, dw, dh);
    }

    clearCanvas() {
        // üöÄ PERFORMANCE: Only clear when necessary
        this.ctx.fillStyle = '#000000';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Show/hide no content overlay
        const hasStreams = this.streams.size > 0;
        document.getElementById('noContentOverlay').style.display = hasStreams ? 'none' : 'block';
    }

    // Recording Methods
    startRecordingWithCountdown() {
        if (!this.isComposing) {
            alert('Bitte starten Sie zuerst die Live-Komposition');
            return;
        }
        
        const overlay = document.getElementById('countdownOverlay');
        const num = document.getElementById('countdownNumber');
        if (!overlay || !num) return this.startRecording();
        
        let n = 3;
        num.textContent = n;
        overlay.style.display = 'block';
        
        const interval = setInterval(() => {
            n -= 1;
            if (n === 0) {
                clearInterval(interval);
                overlay.style.display = 'none';
                this.startRecording();
            } else {
                num.textContent = n;
            }
        }, 700);
    }

    startRecording() {
        if (!this.isComposing) {
            alert('Bitte starten Sie zuerst die Live-Komposition');
            return;
        }

        try {
            // üéØ OPTIMIZED: Adaptive frame rate based on browser
            const targetFPS = this.getBrowserOptimalFPS();
            const stream = this.canvas.captureStream(targetFPS);
            
            // üöÄ IMPROVED MediaRecorder configuration
            const options = this.getOptimalRecorderOptions();
            this.mediaRecorder = new MediaRecorder(stream, options);
            
            this.recordedChunks = [];
            this.pausedAccum = 0;
            this.pauseStart = null;

            console.log(`üìπ MediaRecorder gestartet: ${targetFPS}fps, ${options.videoBitsPerSecond}bps`);

            this.mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    this.recordedChunks.push(event.data);
                }
            };

            this.mediaRecorder.onstop = () => {
                const blob = new Blob(this.recordedChunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                this.showPreviewModal(url);
                this.resetRecordingUI();
            };

            this.mediaRecorder.start();
            this.isRecording = true;
            this.recordingStartTime = Date.now();
            
            document.getElementById('recordBtn').disabled = true;
            document.getElementById('stopRecordBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = false;
            document.getElementById('recordingStatus').textContent = 'Status: Aufnahme l√§uft';
            document.getElementById('recordingIndicator').style.display = 'block';
            
            this.startRecordingTimer();
            console.log('üìπ Recording gestartet');

        } catch (error) {
            console.error('‚ùå Recording Fehler:', error);
            alert('Aufnahme-Fehler: ' + error.message);
        }
    }

    stopRecording() {
        if (this.mediaRecorder && this.mediaRecorder.state === 'recording') {
            this.mediaRecorder.stop();
            this.isRecording = false;
            this.stopRecordingTimer();
            console.log('üìπ Recording gestoppt');
        }
    }

    togglePauseRecording() {
        if (!this.mediaRecorder) return;
        
        const btn = document.getElementById('pauseBtn');
        if (this.mediaRecorder.state === 'recording') {
            this.mediaRecorder.pause();
            this.pauseStart = Date.now();
            this.stopRecordingTimer();
            btn.innerHTML = '<i class="fas fa-play me-2"></i>Fortsetzen';
            document.getElementById('recordingStatus').textContent = 'Status: Aufnahme pausiert';
        } else if (this.mediaRecorder.state === 'paused') {
            this.mediaRecorder.resume();
            if (this.pauseStart) {
                this.pausedAccum += Date.now() - this.pauseStart;
                this.pauseStart = null;
            }
            this.startRecordingTimer();
            btn.innerHTML = '<i class="fas fa-pause me-2"></i>Pausieren';
            document.getElementById('recordingStatus').textContent = 'Status: Aufnahme l√§uft';
        }
    }

    startRecordingTimer() {
        this.recordingTimer = setInterval(() => {
            const elapsed = Date.now() - this.recordingStartTime - (this.pausedAccum || 0);
            const minutes = Math.floor(elapsed / 60000);
            const seconds = Math.floor((elapsed % 60000) / 1000);
            
            const timeStr = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('recordingTime').textContent = timeStr;
            document.getElementById('recordingTimeIndicator').textContent = timeStr;
            
            const progress = (elapsed / this.maxDuration) * 100;
            document.getElementById('recordingProgress').style.width = `${Math.min(progress, 100)}%`;
            
            // Auto-stop at max duration
            if (elapsed >= this.maxDuration) {
                this.stopRecording();
                alert('Aufnahme beendet - Maximale Aufnahmedauer erreicht (3 Minuten)');
            }
        }, 1000);
    }

    stopRecordingTimer() {
        if (this.recordingTimer) {
            clearInterval(this.recordingTimer);
            this.recordingTimer = null;
        }
    }

    resetRecordingUI() {
        const recordBtn = document.getElementById('recordBtn');
        const stopBtn = document.getElementById('stopRecordBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const status = document.getElementById('recordingStatus');
        const indicator = document.getElementById('recordingIndicator');
        const progress = document.getElementById('recordingProgress');
        const time = document.getElementById('recordingTime');
        
        if (recordBtn) recordBtn.disabled = false;
        if (stopBtn) stopBtn.disabled = true;
        if (pauseBtn) {
            pauseBtn.disabled = true;
            pauseBtn.innerHTML = '<i class="fas fa-pause me-2"></i>Pausieren';
        }
        if (status) status.textContent = 'Status: Bereit f√ºr Aufnahme';
        if (indicator) indicator.style.display = 'none';
        if (progress) progress.style.width = '0%';
        if (time) time.textContent = '00:00';
        
        document.getElementById('recordingStateIndicator').innerHTML = '<i class="fas fa-stop me-1"></i>Gestoppt';
    }

    updateRecordingIndicator() {
        const indicator = document.getElementById('recordingIndicator');
        if (indicator) {
            indicator.style.display = this.isRecording ? 'block' : 'none';
        }
    }

    // Preview Modal
    showPreviewModal(videoUrl) {
        const existing = document.getElementById('recordPreviewModal');
        if (existing) existing.remove();
        
        const html = `
            <div class="modal fade" id="recordPreviewModal" tabindex="-1">
                <div class="modal-dialog modal-lg">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title"><i class="fas fa-play me-2"></i>Aufnahme Vorschau</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                        </div>
                        <div class="modal-body text-center">
                            <video id="previewVideo" controls style="max-width:100%;max-height:400px;">
                                <source src="${videoUrl}" type="video/webm">
                                Ihr Browser unterst√ºtzt das Video-Element nicht.
                            </video>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Schlie√üen</button>
                            <button type="button" class="btn btn-success" id="downloadFromPreview">
                                <i class="fas fa-download me-2"></i>Herunterladen
                            </button>
                        </div>
                    </div>
                </div>
            </div>`;
        
        document.body.insertAdjacentHTML('beforeend', html);
        
        document.getElementById('downloadFromPreview')?.addEventListener('click', () => {
            const a = document.createElement('a');
            a.href = videoUrl;
            a.download = `streamrec-optimized-${Date.now()}.webm`;
            a.click();
        });
        
        if (window.bootstrap) {
            const modal = new bootstrap.Modal(document.getElementById('recordPreviewModal'));
            modal.show();
        }
    }

    // üöÄ PERFORMANCE OPTIMIZATION METHODS
    getBrowserOptimalFPS() {
        const ua = navigator.userAgent;
        
        // üöÄ PYTHONANYWHERE OPTIMIZED: Konservativere FPS f√ºr Server-Umgebung
        if (ua.includes('Chrome')) return Math.min(this.targetFPS, 25); // Reduziert von 30
        if (ua.includes('Firefox')) return Math.min(this.targetFPS, 20); // Reduziert von 25  
        if (ua.includes('Safari')) return Math.min(this.targetFPS, 15); // Reduziert von 20
        if (ua.includes('Edge')) return Math.min(this.targetFPS, 20);
        
        // Default f√ºr Server-Umgebung: Konservativ
        return Math.min(this.targetFPS, 20);
    }

    getOptimalRecorderOptions() {
        const quality = document.getElementById('qualitySelect')?.value || 'medium';
        const bitrate = document.getElementById('bitrateSetting')?.value || '1500000'; // Reduziert f√ºr Server
        
        // üöÄ PYTHONANYWHERE OPTIMIZED: Konservativere Bitrates
        let serverOptimizedBitrate = parseInt(bitrate);
        switch (quality) {
            case 'high':
                serverOptimizedBitrate = Math.min(serverOptimizedBitrate, 2000000); // Max 2 Mbps
                break;
            case 'medium':
                serverOptimizedBitrate = Math.min(serverOptimizedBitrate, 1500000); // Max 1.5 Mbps
                break;
            case 'low':
                serverOptimizedBitrate = Math.min(serverOptimizedBitrate, 800000);  // Max 0.8 Mbps
                break;
        }
        
        let options = {
            mimeType: 'video/webm;codecs=vp8',
            videoBitsPerSecond: serverOptimizedBitrate
        };
        
        // üõ°Ô∏è ROBUST FALLBACK f√ºr verschiedene Server-Umgebungen
        const supportedTypes = [
            'video/webm;codecs=vp8,opus',
            'video/webm;codecs=vp8',
            'video/webm',
            'video/mp4'
        ];
        
        for (const type of supportedTypes) {
            if (MediaRecorder.isTypeSupported(type)) {
                options.mimeType = type;
                break;
            }
        }
        
        console.log('üìπ Server-optimierte MediaRecorder Options:', options);
        return options;
    }

    applyQualitySettings(quality) {
        switch (quality) {
            case 'high':
                this.targetFPS = 30;
                this.maxSkipFrames = 1;
                break;
            case 'medium':
                this.targetFPS = 25;
                this.maxSkipFrames = 2;
                break;
            case 'low':
                this.targetFPS = 20;
                this.maxSkipFrames = 3;
                break;
        }
        this.frameInterval = 1000 / this.targetFPS;
    }

    handleRenderError(error) {
        console.warn('üîß Auto-recovery from render error:', error);
        
        // Reset problematic states
        this.skipFrameCount = 0;
        
        // Clear video element pool if corrupted
        if (error.message.includes('video') || error.message.includes('canvas')) {
            this.videoElements.clear();
        }
    }

    // Performance Monitoring
    initPerformanceMonitoring() {
        setInterval(() => {
            this.calculateFPS();
            this.updateSystemInfoMetrics();
        }, 1000);
    }
    
    updateSystemInfoMetrics() {
        const metricsElement = document.getElementById('performanceMetrics');
        if (!metricsElement) return;
        
        const fps = this.performanceMetrics.lastFPS || 0;
        const dropped = this.performanceMetrics.droppedFrames || 0;
        const total = this.performanceMetrics.totalFrames || 0;
        const dropRate = total > 0 ? ((dropped / total) * 100).toFixed(1) : '0.0';
        const renderTime = Math.round(this.performanceMetrics.averageRenderTime || 0);
        
        // Farbkodierung basierend auf Performance
        let statusClass = 'text-muted';
        let statusText = 'Bereit';
        
        // Nur bewerten wenn bereits Frames verarbeitet wurden
        if (total > 0) {
            if (fps >= 20 && dropRate <= 5) {
                statusClass = 'text-success';
                statusText = 'Gut';
            } else if (fps >= 15 && dropRate <= 10) {
                statusClass = 'text-warning';
                statusText = 'Mittel';
            } else {
                statusClass = 'text-danger';
                statusText = 'Schlecht';
            }
        }
        
        metricsElement.innerHTML = `
            <div class="row g-2 text-center">
                <div class="col-6">
                    <small class="text-muted d-block">FPS</small>
                    <span class="fw-bold ${statusClass}">${fps}</span>
                </div>
                <div class="col-6">
                    <small class="text-muted d-block">Frames</small>
                    <span class="fw-bold text-info">${total}</span>
                </div>
                <div class="col-6">
                    <small class="text-muted d-block">Dropped</small>
                    <span class="fw-bold ${dropRate > 5 ? 'text-warning' : 'text-success'}">${dropRate}%</span>
                </div>
                <div class="col-6">
                    <small class="text-muted d-block">Status</small>
                    <span class="fw-bold ${statusClass}">${statusText}</span>
                </div>
            </div>
        `;
    }

    updatePerformanceMetrics(renderTime) {
        this.performanceMetrics.totalFrames++;
        this.renderTimeBuffer.push(renderTime);
        
        // Keep buffer size manageable
        if (this.renderTimeBuffer.length > 60) {
            this.renderTimeBuffer.shift();
        }
        
        // Calculate average render time
        const avgRenderTime = this.renderTimeBuffer.reduce((a, b) => a + b, 0) / this.renderTimeBuffer.length;
        this.performanceMetrics.averageRenderTime = avgRenderTime;
    }

    calculateFPS() {
        const now = performance.now();
        const elapsed = now - this.lastFPSUpdate;
        
        if (elapsed >= 1000) {
            const fps = Math.round(this.performanceBuffer.length * 1000 / elapsed);
            this.performanceMetrics.lastFPS = fps;
            this.performanceBuffer = [];
            this.lastFPSUpdate = now;
            
            this.updatePerformanceDisplay();
        }
        
        this.performanceBuffer.push(now);
    }

    updatePerformanceDisplay() {
        const indicator = document.getElementById('performanceIndicator');
        if (!indicator || indicator.style.display === 'none') return;
        
        const fps = this.performanceMetrics.lastFPS;
        const dropped = this.performanceMetrics.droppedFrames;
        const renderTime = Math.round(this.performanceMetrics.averageRenderTime);
        
        document.getElementById('fpsCounter').textContent = fps;
        document.getElementById('frameCounter').textContent = this.performanceMetrics.totalFrames;
        document.getElementById('droppedCounter').textContent = dropped;
        document.getElementById('renderTime').textContent = renderTime + 'ms';
        
        // Color coding
        indicator.className = 'performance-indicator ';
        if (fps >= this.targetFPS * 0.8 && renderTime < 16) {
            indicator.className += 'performance-good';
        } else if (fps >= this.targetFPS * 0.6 && renderTime < 25) {
            indicator.className += 'performance-warning';
        } else {
            indicator.className += 'performance-critical';
        }
    }

    togglePerformanceMonitor(show) {
        const indicator = document.getElementById('performanceIndicator');
        if (indicator) {
            indicator.style.display = show ? 'block' : 'none';
        }
    }

    // Utility Methods
    updateStatus(type, message, variant) {
        const statusElement = document.getElementById(`${type}Status`);
        if (statusElement) {
            statusElement.textContent = `Status: ${message}`;
            statusElement.className = `text-${variant} d-block mt-2`;
        }
    }

    updateButtons(type, active) {
        const startBtn = document.getElementById(`start${type.charAt(0).toUpperCase() + type.slice(1)}Btn`);
        const stopBtn = document.getElementById(`stop${type.charAt(0).toUpperCase() + type.slice(1)}Btn`);
        
        if (startBtn) startBtn.disabled = active;
        if (stopBtn) stopBtn.disabled = !active;
        
    }

    updateStatusBadge(type, variant) {
        const badge = document.getElementById(`${type}StatusBadge`);
        if (badge) {
            const icon = badge.querySelector('i');
            if (icon) {
                icon.className = `fas fa-circle text-${variant}`;
            }
        }
    }

    updateActiveStreamsCount() {
        const counter = document.getElementById('activeStreams');
        if (counter) {
            counter.textContent = this.streams.size;
        }
    }

    checkCompositionReady() {
        const hasActiveStreams = this.activeStreams.size > 0;
        if (hasActiveStreams && !this.isComposing) {
            this.startRenderLoop();
        } else if (!hasActiveStreams && this.isComposing) {
            this.stopRenderLoop();
        }
    }

    // Settings Management
    loadSettings() {
        try {
            const stored = localStorage.getItem('streamrec-optimized-settings');
            if (stored) {
                const settings = JSON.parse(stored);
                if (settings.targetFPS) {
                    this.targetFPS = settings.targetFPS;
                    document.getElementById('fpsSelect').value = settings.targetFPS;
                }
                if (settings.enableFrameSkipping !== undefined) {
                    this.enableFrameSkipping = settings.enableFrameSkipping;
                    document.getElementById('enableFrameSkipping').checked = settings.enableFrameSkipping;
                }
                if (settings.enableErrorRecovery !== undefined) {
                    this.enableErrorRecovery = settings.enableErrorRecovery;
                    document.getElementById('enableErrorRecovery').checked = settings.enableErrorRecovery;
                }
                if (settings.showPerformance !== undefined) {
                    this.togglePerformanceMonitor(settings.showPerformance);
                    document.getElementById('enablePerformanceMonitor').checked = settings.showPerformance;
                }
            }
        } catch (e) {
            console.warn('Settings load error:', e);
        }
    }

    saveSettings() {
        try {
            const settings = {
                targetFPS: this.targetFPS,
                enableFrameSkipping: document.getElementById('enableFrameSkipping')?.checked ?? true,
                enableErrorRecovery: document.getElementById('enableErrorRecovery')?.checked ?? true,
                showPerformance: document.getElementById('enablePerformanceMonitor')?.checked ?? false,
                resolution: document.getElementById('resolutionSetting')?.value ?? '720p',
                bitrate: document.getElementById('bitrateSetting')?.value ?? '2000000'
            };
            
            localStorage.setItem('streamrec-optimized-settings', JSON.stringify(settings));
            
            // Apply settings
            this.enableFrameSkipping = settings.enableFrameSkipping;
            this.enableErrorRecovery = settings.enableErrorRecovery;
            this.togglePerformanceMonitor(settings.showPerformance);
            
            alert('Einstellungen gespeichert!');
            
            // Close modal
            const modalEl = document.getElementById('settingsModal');
            if (modalEl && window.bootstrap) {
                const modal = bootstrap.Modal.getInstance(modalEl) || new bootstrap.Modal(modalEl);
                modal.hide();
            }
        } catch (e) {
            console.error('Settings save error:', e);
            alert('Speichern fehlgeschlagen: ' + e.message);
        }
    }

    // üìê LAYOUT MANAGEMENT METHODS
    renderStacked(streams) {
        const streamArray = Array.from(streams);
        const height = this.canvas.height / streamArray.length;
        
        streamArray.forEach(([type, stream], index) => {
            const video = this.getVideoElementOptimized(type, stream);
            if (!video || video.readyState < 2) return;
            
            const y = index * height;
            this.drawVideoContain(video, 0, y, this.canvas.width, height);
            
            // Draw separator
            if (index > 0) {
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(0, y);
                this.ctx.lineTo(this.canvas.width, y);
                this.ctx.stroke();
            }
        });
    }

    renderGrid2x2(streams) {
        const items = Array.from(streams).slice(0, 4);
        const cols = 2, rows = 2;
        const cellW = Math.floor(this.canvas.width / cols);
        const cellH = Math.floor(this.canvas.height / rows);
        
        items.forEach(([type, stream], idx) => {
            const video = this.getVideoElementOptimized(type, stream);
            if (!video || video.readyState < 2) return;
            
            const col = idx % cols;
            const row = Math.floor(idx / cols);
            const dx = col * cellW;
            const dy = row * cellH;
            
            this.drawVideoContain(video, dx, dy, cellW, cellH);
            
            // Draw grid lines
            this.ctx.strokeStyle = '#fff';
            this.ctx.lineWidth = 2;
            if (col === 0) {
                this.ctx.beginPath();
                this.ctx.moveTo(cellW, 0);
                this.ctx.lineTo(cellW, this.canvas.height);
                this.ctx.stroke();
            }
            if (row === 0) {
                this.ctx.beginPath();
                this.ctx.moveTo(0, cellH);
                this.ctx.lineTo(this.canvas.width, cellH);
                this.ctx.stroke();
            }
        });
    }

    renderThreeColumns(streams) {
        const items = Array.from(streams).slice(0, 3);
        const colW = Math.floor(this.canvas.width / 3);
        
        items.forEach(([type, stream], idx) => {
            const video = this.getVideoElementOptimized(type, stream);
            if (!video || video.readyState < 2) return;
            
            const dx = idx * colW;
            this.drawVideoContain(video, dx, 0, colW, this.canvas.height);
            
            // Draw separators
            if (idx > 0) {
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(dx, 0);
                this.ctx.lineTo(dx, this.canvas.height);
                this.ctx.stroke();
            }
        });
    }

    renderLeftBigRightTwo(streams) {
        const streamArray = Array.from(streams);
        if (streamArray.length < 3) return this.renderStacked(streamArray);
        
        const left = streamArray[0];
        const right = streamArray.slice(1, 3);
        const leftW = Math.floor(this.canvas.width * 0.66);
        const rightW = this.canvas.width - leftW;
        const rightH = Math.floor(this.canvas.height / 2);
        
        // Left big
        const [lt, ls] = left;
        const lv = this.getVideoElementOptimized(lt, ls);
        if (lv && lv.readyState >= 2) {
            this.drawVideoContain(lv, 0, 0, leftW, this.canvas.height);
        }
        
        // Right stacked two
        right.forEach(([t, s], i) => {
            const v = this.getVideoElementOptimized(t, s);
            if (v && v.readyState >= 2) {
                const dx = leftW;
                const dy = i * rightH;
                this.drawVideoContain(v, dx, dy, rightW, rightH);
            }
        });
        
        // Separators
        this.ctx.strokeStyle = '#fff';
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.moveTo(leftW, 0);
        this.ctx.lineTo(leftW, this.canvas.height);
        this.ctx.moveTo(leftW, rightH);
        this.ctx.lineTo(this.canvas.width, rightH);
        this.ctx.stroke();
    }

    renderFullscreen(streams) {
        // Show first stream fullscreen
        const firstStream = Array.from(streams)[0];
        if (firstStream) {
            const [type, stream] = firstStream;
            const video = this.getVideoElementOptimized(type, stream);
            if (video && video.readyState >= 2) {
                this.drawVideoCover(video, 0, 0, this.canvas.width, this.canvas.height);
            }
        }
    }

    applyLayout(layout) {
        this.currentLayout = layout;
        console.log(`üìê Layout angewendet: ${layout}`);
        
        // Update thumbnail appearances for the new layout
        this.updateThumbnailsForLayoutChange();
        
        // Sofortige Aktualisierung der Komposition wenn aktiv
        if (this.isComposing) {
            this.renderCurrentLayout();
        }
    }

    // üéØ LAYOUT MANAGEMENT
    refreshLayoutChips() {
        const container = document.getElementById('layoutChips');
        const streamCountElement = document.getElementById('layoutStreamCount');
        
        if (!container) return;
        
        const count = this.activeStreams.size;
        const layouts = this.getAvailableLayouts(count);
        
        // Update stream count display
        if (streamCountElement) {
            streamCountElement.textContent = `${count} Stream${count !== 1 ? 's' : ''}`;
        }
        
        if (layouts.length === 0) {
            container.innerHTML = '<small class="text-muted">Starte Streams f√ºr Layouts</small>';
            this.updateLayoutManager([]); // Clear layout manager too
            return;
        }
        
        // Create layout chips (small buttons) with icons - always show layout name
        container.innerHTML = layouts.map(l => 
            `<button type="button" class="btn btn-sm ${this.currentLayout === l.id ? 'btn-primary' : 'btn-outline-primary'}" data-layout="${l.id}" title="${l.description}">
                <i class="${l.icon} me-1" style="font-size: 12px;"></i>${l.name}${this.currentLayout === l.id ? ' ‚úì' : ''}
            </button>`
        ).join(' ');
        
        // Update Layout Manager (large cards)
        this.updateLayoutManager(layouts);
        
        console.log(`üìê Layouts aktualisiert: ${count} Streams, ${layouts.length} Layouts verf√ºgbar`);
    }

    getAvailableLayouts(streamCount) {
        const layouts = [];
        
        if (streamCount >= 1) {
            layouts.push({ 
                id: 'fullscreen', 
                name: 'Vollbild', 
                description: 'Ein Stream im Vollbild',
                icon: 'fas fa-expand-arrows-alt'
            });
            layouts.push({ 
                id: 'free', 
                name: 'Freies Layout', 
                description: 'Streams frei positionieren und skalieren per Drag & Drop',
                icon: 'fas fa-arrows-alt'
            });
        }
        if (streamCount >= 2) {
            layouts.push({ 
                id: 'pip', 
                name: 'PiP', 
                description: 'Picture-in-Picture (Bildschirm + Kamera)',
                icon: 'fas fa-square'
            });
            layouts.push({ 
                id: 'side', 
                name: 'Nebeneinander', 
                description: 'Streams nebeneinander angeordnet',
                icon: 'fas fa-columns'
            });
            layouts.push({ 
                id: 'stack', 
                name: 'Gestapelt', 
                description: 'Streams √ºbereinander angeordnet',
                icon: 'fas fa-stream'
            });
        }
        if (streamCount >= 3) {
            layouts.push({ 
                id: 'threeCols', 
                name: '3 Spalten', 
                description: 'Drei gleichm√§√üige Spalten',
                icon: 'fas fa-grip-vertical'
            });
            layouts.push({ 
                id: 'leftBigRight2', 
                name: 'Links Gro√ü', 
                description: 'Links gro√ü, rechts zwei kleine',
                icon: 'fas fa-th-large'
            });
        }
        if (streamCount >= 4) {
            layouts.push({ 
                id: 'grid2x2', 
                name: '2x2 Grid', 
                description: '2x2 Raster Layout f√ºr 4 Streams',
                icon: 'fas fa-th'
            });
        }
        
        return layouts;
    }

    updateLayoutManager(layouts) {
        const container = document.getElementById('layoutControlsContent');
        const placeholder = document.getElementById('layoutManagerPlaceholder');
        
        if (!container) return;
        
        if (layouts.length === 0) {
            // Show placeholder message
            if (placeholder) {
                placeholder.style.display = 'block';
            } else {
                container.innerHTML = `
                    <div class="alert alert-info" id="layoutManagerPlaceholder">
                        <i class="fas fa-info-circle me-2"></i>
                        Starten Sie Kamera oder Bildschirm-Sharing, um verf√ºgbare Layouts zu sehen
                    </div>`;
            }
            return;
        }
        
        // Hide placeholder
        if (placeholder) {
            placeholder.style.display = 'none';
        }
        
        // Create layout cards with new icons and improved clarity
        const layoutCards = layouts.map(layout => `
            <div class="col-md-6 mb-3">
                <div class="layout-preset-card border rounded ${this.currentLayout === layout.id ? 'border-primary bg-primary bg-opacity-10' : 'border-light'} position-relative" 
                     style="cursor: pointer; transition: all 0.2s ease; padding: 1rem;" 
                     data-layout="${layout.id}"
                     data-card-id="${layout.id}"
                     title="${layout.description}">
                    ${this.currentLayout === layout.id ? '<div class="position-absolute top-0 end-0 m-2"><i class="fas fa-check-circle text-success" style="font-size: 18px;"></i></div>' : ''}
                    
                    <div class="d-flex align-items-center mb-2">
                        <div class="layout-icon me-3" style="width: 36px; height: 36px; background: ${this.currentLayout === layout.id ? '#0d6efd' : '#6c757d'}; border-radius: 8px; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                            <i class="${layout.icon} text-white" style="font-size: 16px;"></i>
                        </div>
                        <div class="flex-grow-1">
                            <h6 class="mb-0 fw-bold">${layout.name}</h6>
                            ${this.currentLayout === layout.id ? '<small class="text-success fw-semibold"><i class="fas fa-dot-circle me-1"></i>Aktives Layout</small>' : '<small class="text-muted">Verf√ºgbar</small>'}
                        </div>
                    </div>
                    
                    <p class="small text-muted mb-3 lh-sm">${layout.description}</p>
                    
                    <div class="d-grid">
                        <button class="btn btn-sm ${this.currentLayout === layout.id ? 'btn-success' : 'btn-outline-primary'}" data-layout="${layout.id}" data-button-id="${layout.id}" style="font-weight: 500;">
                            <i class="fas fa-${this.currentLayout === layout.id ? 'check' : 'play'} me-1"></i>
                            ${layout.name} ${this.currentLayout === layout.id ? '(Aktiv)' : ''}
                        </button>
                    </div>
                </div>
            </div>
        `).join('');
        
        container.innerHTML = `<div class="row">${layoutCards}</div>`;
        
        console.log(`üé® Layout Manager aktualisiert: ${layouts.length} Layouts mit verbesserter Klarheit`);
    }

    // Layout Icon Mapping (not needed anymore, using layout.icon directly)
    getLayoutIcon(layoutId) {
        // Legacy fallback, now using layout.icon from getAvailableLayouts
        const icons = {
            'fullscreen': 'expand-arrows-alt',
            'pip': 'square',
            'side': 'columns',
            'stack': 'stream',
            'threeCols': 'grip-vertical',
            'leftBigRight2': 'th-large',
            'grid2x2': 'th'
        };
        return icons[layoutId] || 'square';
    }

    // üñºÔ∏è STREAM THUMBNAIL MANAGEMENT
    addStreamThumbnail(type, stream) {
        const container = document.getElementById('streamThumbnails');
        if (!container) return;
        
        // Remove no streams message
        const noStreamsMsg = document.getElementById('noStreamsMessage');
        if (noStreamsMsg) noStreamsMsg.style.display = 'none';
        
        // Mark stream as active by default and set default display mode
        this.activeStreams.add(type);
        this.streamDisplayModes.set(type, 'cover'); // Default: cover (stretch to fill)
        
        // Create thumbnail
        const thumbnail = document.createElement('div');
        thumbnail.id = `thumbnail-${type}`;
        thumbnail.className = 'stream-thumbnail position-relative';
        thumbnail.style.cssText = 'width: 120px; height: 90px; border-radius: 0.5rem; overflow: hidden; border: 2px solid #28a745; cursor: pointer; transition: border-color 0.3s;';
        thumbnail.setAttribute('data-stream-id', type);
        
        // Add click handler for toggle or add to free layout
        thumbnail.addEventListener('click', () => this.handleThumbnailClick(type));
        
        const video = document.createElement('video');
        video.srcObject = stream;
        video.autoplay = true;
        video.muted = true;
        video.playsInline = true;
        video.style.cssText = 'width: 100%; height: 100%; object-fit: cover;';
        
        const label = document.createElement('div');
        label.className = 'position-absolute bottom-0 start-0 end-0 bg-dark bg-opacity-75 text-white text-center py-1';
        label.style.fontSize = '0.75rem';
        label.textContent = type === 'camera' ? 'Kamera' : type.startsWith('screen') ? (type === 'screen1' ? 'Bildschirm 1' : type.replace('screen', 'Bildschirm ')) : type;
        
        // Add status indicator
        const statusIndicator = document.createElement('div');
        statusIndicator.className = 'position-absolute top-0 end-0 m-1';
        statusIndicator.innerHTML = '<i class="fas fa-circle text-success" style="font-size: 8px;"></i>';
        statusIndicator.id = `status-${type}`;
        
        thumbnail.appendChild(video);
        thumbnail.appendChild(label);
        thumbnail.appendChild(statusIndicator);
        container.appendChild(thumbnail);
    }

    removeStreamThumbnail(type) {
        const thumbnail = document.getElementById(`thumbnail-${type}`);
        if (thumbnail) {
            thumbnail.remove();
        }
        
        // Remove from active streams and display modes
        this.activeStreams.delete(type);
        this.streamDisplayModes.delete(type);
        
        // Show no streams message if no thumbnails left
        const container = document.getElementById('streamThumbnails');
        if (container && container.children.length === 1) { // Only noStreamsMessage left
            const noStreamsMsg = document.getElementById('noStreamsMessage');
            if (noStreamsMsg) noStreamsMsg.style.display = 'block';
        }
    }

    toggleStream(streamId) {
        const thumbnail = document.getElementById(`thumbnail-${streamId}`);
        const statusIndicator = document.getElementById(`status-${streamId}`);
        
        if (!thumbnail) return;
        
        const isActive = this.activeStreams.has(streamId);
        
        if (isActive) {
            // Deactivate stream
            this.activeStreams.delete(streamId);
            thumbnail.style.borderColor = '#ffc107'; // Yellow border
            if (statusIndicator) {
                statusIndicator.innerHTML = '<i class="fas fa-circle text-warning" style="font-size: 8px;"></i>';
            }
            console.log(`üü° Stream ${streamId} deaktiviert`);
        } else {
            // Activate stream  
            this.activeStreams.add(streamId);
            thumbnail.style.borderColor = '#28a745'; // Green border
            if (statusIndicator) {
                statusIndicator.innerHTML = '<i class="fas fa-circle text-success" style="font-size: 8px;"></i>';
            }
            console.log(`üü¢ Stream ${streamId} aktiviert`);
        }
        
        // Update layout options based on active streams
        this.refreshLayoutChips();
    }

    setStreamDisplayMode(streamId, mode) {
        this.streamDisplayModes.set(streamId, mode);
        console.log(`üì∫ Display-Modus f√ºr ${streamId} ge√§ndert: ${mode}`);
        
        // Force re-render to apply new display mode
        if (this.isComposing) {
            this.renderComposition();
        }
    }

    setupCanvasInteraction() {
        if (!this.canvas) return;

        // Mouse events for drag and drop
        this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
        this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
        this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
        this.canvas.addEventListener('mouseleave', (e) => this.handleMouseUp(e));

        // Touch events for mobile
        this.canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e));
        this.canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e));
        this.canvas.addEventListener('touchend', (e) => this.handleTouchEnd(e));
    }

    getCanvasCoordinates(e) {
        const rect = this.canvas.getBoundingClientRect();
        const scaleX = this.canvas.width / rect.width;
        const scaleY = this.canvas.height / rect.height;
        
        return {
            x: (e.clientX - rect.left) * scaleX,
            y: (e.clientY - rect.top) * scaleY
        };
    }

    handleMouseDown(e) {
        if (this.currentLayout !== 'free' || this.isRecording) return;
        
        const coords = this.getCanvasCoordinates(e);
        const hitTest = this.hitTestFreeLayout(coords.x, coords.y);
        
        if (hitTest) {
            if (hitTest.type === 'resize') {
                this.isResizing = true;
                this.resizeStream = hitTest.streamId;
                this.resizeHandle = hitTest.handle;
            } else if (hitTest.type === 'drag') {
                this.isDragging = true;
                this.draggedStream = hitTest.streamId;
                const streamData = this.freeLayoutStreams.get(hitTest.streamId);
                this.dragOffset = {
                    x: coords.x - streamData.x,
                    y: coords.y - streamData.y
                };
            }
            this.canvas.style.cursor = hitTest.cursor;
        }
    }

    handleMouseMove(e) {
        if (this.currentLayout !== 'free' || this.isRecording) return;
        
        const coords = this.getCanvasCoordinates(e);
        
        if (this.isDragging && this.draggedStream) {
            const streamData = this.freeLayoutStreams.get(this.draggedStream);
            streamData.x = Math.max(0, Math.min(this.canvas.width - streamData.width, coords.x - this.dragOffset.x));
            streamData.y = Math.max(0, Math.min(this.canvas.height - streamData.height, coords.y - this.dragOffset.y));
        } else if (this.isResizing && this.resizeStream) {
            const streamData = this.freeLayoutStreams.get(this.resizeStream);
            const minSize = 50;
            
            if (this.resizeHandle === 'se') {
                streamData.width = Math.max(minSize, Math.min(this.canvas.width - streamData.x, coords.x - streamData.x));
                streamData.height = Math.max(minSize, Math.min(this.canvas.height - streamData.y, coords.y - streamData.y));
            }
        } else {
            // Update cursor based on hover
            const hitTest = this.hitTestFreeLayout(coords.x, coords.y);
            this.canvas.style.cursor = hitTest ? hitTest.cursor : 'default';
        }
    }

    handleMouseUp(e) {
        this.isDragging = false;
        this.isResizing = false;
        this.draggedStream = null;
        this.resizeStream = null;
        this.resizeHandle = null;
        this.canvas.style.cursor = 'default';
    }

    handleTouchStart(e) {
        e.preventDefault();
        if (e.touches.length === 1) {
            const touch = e.touches[0];
            this.handleMouseDown({ clientX: touch.clientX, clientY: touch.clientY });
        }
    }

    handleTouchMove(e) {
        e.preventDefault();
        if (e.touches.length === 1) {
            const touch = e.touches[0];
            this.handleMouseMove({ clientX: touch.clientX, clientY: touch.clientY });
        }
    }

    handleTouchEnd(e) {
        e.preventDefault();
        this.handleMouseUp(e);
    }

    hitTestFreeLayout(x, y) {
        for (const [streamId, data] of this.freeLayoutStreams.entries()) {
            // Check resize handle (bottom-right corner)
            const handleSize = 15;
            if (x >= data.x + data.width - handleSize && x <= data.x + data.width &&
                y >= data.y + data.height - handleSize && y <= data.y + data.height) {
                return { type: 'resize', streamId, handle: 'se', cursor: 'se-resize' };
            }
            
            // Check stream area for dragging
            if (x >= data.x && x <= data.x + data.width &&
                y >= data.y && y <= data.y + data.height) {
                return { type: 'drag', streamId, cursor: 'move' };
            }
        }
        return null;
    }

    // Draw video with individual display mode
    drawVideoWithMode(video, streamId, x, y, width, height) {
        const mode = this.streamDisplayModes.get(streamId) || 'cover';
        
        switch (mode) {
            case 'cover':
                // VERZERRT: Streckt/staucht das Video um den Bereich komplett zu f√ºllen (kann verzerren)
                this.drawVideoCover(video, x, y, width, height);
                break;
            case 'contain':
                // EINGEPASST: Video passt komplett rein, beh√§lt Seitenverh√§ltnis (schwarze Balken m√∂glich)
                this.drawVideoContain(video, x, y, width, height);
                break;
            case 'fill':
                // ZUGESCHNITTEN: F√ºllt Bereich komplett, beh√§lt Seitenverh√§ltnis (schneidet ab wo n√∂tig)
                this.drawVideoFill(video, x, y, width, height);
                break;
            case 'crop':
                // ZENTRIERT ZUGESCHNITTEN: Wie "fill" aber schneidet gleichm√§√üig von allen Seiten ab
                this.drawVideoCrop(video, x, y, width, height);
                break;
            default:
                this.drawVideoCover(video, x, y, width, height);
        }
    }

    drawVideoFill(video, x, y, width, height) {
        // Fill the area completely, maintaining aspect ratio (may crop)
        const videoAspect = video.videoWidth / video.videoHeight;
        const canvasAspect = width / height;
        
        if (videoAspect > canvasAspect) {
            // Video is wider - fit height and crop width
            const drawWidth = height * videoAspect;
            const offsetX = (drawWidth - width) / 2;
            this.ctx.drawImage(video, x - offsetX, y, drawWidth, height);
        } else {
            // Video is taller - fit width and crop height
            const drawHeight = width / videoAspect;
            const offsetY = (drawHeight - height) / 2;
            this.ctx.drawImage(video, x, y - offsetY, width, drawHeight);
        }
    }

    drawVideoCrop(video, x, y, width, height) {
        // Center crop - crop video to exact dimensions
        const videoAspect = video.videoWidth / video.videoHeight;
        const targetAspect = width / height;
        
        let sx = 0, sy = 0, sWidth = video.videoWidth, sHeight = video.videoHeight;
        
        if (videoAspect > targetAspect) {
            // Video is wider - crop horizontally
            sWidth = video.videoHeight * targetAspect;
            sx = (video.videoWidth - sWidth) / 2;
        } else {
            // Video is taller - crop vertically  
            sHeight = video.videoWidth / targetAspect;
            sy = (video.videoHeight - sHeight) / 2;
        }
        
        this.ctx.drawImage(video, sx, sy, sWidth, sHeight, x, y, width, height);
    }

    renderFreeLayout(streams) {
        // Only render streams that are both active AND in free layout
        const availableStreams = new Map(streams);
        
        // Remove streams from free layout that are no longer available
        for (const streamId of this.freeLayoutStreams.keys()) {
            if (!availableStreams.has(streamId)) {
                this.freeLayoutStreams.delete(streamId);
            }
        }

        // Render each stream that is in free layout
        for (const streamId of this.freeLayoutStreams.keys()) {
            const stream = availableStreams.get(streamId);
            const streamData = this.freeLayoutStreams.get(streamId);
            
            if (!stream || !streamData) continue;

            const video = this.getVideoElementOptimized(streamId, stream);
            if (!video || video.readyState < 2) continue;

            // Draw stream
            this.drawVideoWithMode(video, streamId, streamData.x, streamData.y, streamData.width, streamData.height);

            // Draw border (only when not recording)
            if (!this.isRecording) {
                this.ctx.strokeStyle = '#ffffff';
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(streamData.x, streamData.y, streamData.width, streamData.height);
            }

            // Draw resize handle (only when not recording)
            if (!this.isRecording) {
                const handleSize = 15;
                this.ctx.fillStyle = '#ffffff';
                this.ctx.fillRect(
                    streamData.x + streamData.width - handleSize, 
                    streamData.y + streamData.height - handleSize, 
                    handleSize, 
                    handleSize
                );
                
                // Draw resize handle lines
                this.ctx.strokeStyle = '#000000';
                this.ctx.lineWidth = 1;
                const hx = streamData.x + streamData.width - handleSize;
                const hy = streamData.y + streamData.height - handleSize;
                for (let i = 0; i < 3; i++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(hx + i * 5 + 5, hy + handleSize);
                    this.ctx.lineTo(hx + handleSize, hy + i * 5 + 5);
                    this.ctx.stroke();
                }
            }

            // Draw stream label (only when not recording)
            if (!this.isRecording) {
                this.ctx.fillStyle = '#000000';
                this.ctx.fillRect(streamData.x, streamData.y, 100, 20);
                this.ctx.fillStyle = '#ffffff';
                this.ctx.font = '12px Arial';
                const label = streamId === 'camera' ? 'Kamera' : streamId.startsWith('screen') ? `Bildschirm ${streamId.replace('screen', '')}` : streamId;
                this.ctx.fillText(label, streamData.x + 5, streamData.y + 14);
            }
        }
    }

    initializeFreeLayoutStream(streamId) {
        const existingCount = this.freeLayoutStreams.size;
        const defaultWidth = 200;
        const defaultHeight = 150;
        const margin = 20;
        
        // Calculate position to avoid overlaps
        const x = margin + (existingCount % 3) * (defaultWidth + margin);
        const y = margin + Math.floor(existingCount / 3) * (defaultHeight + margin);
        
        this.freeLayoutStreams.set(streamId, {
            x: Math.min(x, this.canvas.width - defaultWidth),
            y: Math.min(y, this.canvas.height - defaultHeight),
            width: defaultWidth,
            height: defaultHeight
        });
        
        console.log(`üéØ Stream ${streamId} f√ºr freies Layout initialisiert`);
    }

    handleThumbnailClick(streamId) {
        if (this.currentLayout === 'free') {
            // In free layout mode: add/remove stream from free layout (doesn't affect active status)
            if (!this.freeLayoutStreams.has(streamId)) {
                this.initializeFreeLayoutStream(streamId);
                this.updateThumbnailForFreeLayout(streamId, true);
                console.log(`‚ûï Stream ${streamId} zum freien Layout hinzugef√ºgt`);
            } else {
                // Remove from free layout if already there
                this.freeLayoutStreams.delete(streamId);
                this.updateThumbnailForFreeLayout(streamId, false);
                console.log(`‚ûñ Stream ${streamId} aus freiem Layout entfernt`);
            }
        } else {
            // In other layouts: toggle stream active/inactive
            this.toggleStream(streamId);
        }
    }

    updateThumbnailForFreeLayout(streamId, isInFreeLayout) {
        const thumbnail = document.getElementById(`thumbnail-${streamId}`);
        const statusIndicator = document.getElementById(`status-${streamId}`);
        
        if (thumbnail) {
            if (isInFreeLayout) {
                thumbnail.style.borderColor = '#007bff'; // Blue border for free layout
                if (statusIndicator) {
                    statusIndicator.innerHTML = '<i class="fas fa-circle text-primary" style="font-size: 8px;"></i>';
                }
            } else {
                thumbnail.style.borderColor = '#6c757d'; // Gray border when not in free layout
                if (statusIndicator) {
                    statusIndicator.innerHTML = '<i class="fas fa-circle text-secondary" style="font-size: 8px;"></i>';
                }
            }
        }
    }

    updateThumbnailsForLayoutChange() {
        // Update all thumbnail appearances based on current layout
        for (const streamId of this.streams.keys()) {
            const thumbnail = document.getElementById(`thumbnail-${streamId}`);
            const statusIndicator = document.getElementById(`status-${streamId}`);
            
            if (!thumbnail || !statusIndicator) continue;
            
            if (this.currentLayout === 'free') {
                // In free layout: show blue if in free layout, gray if not
                if (this.freeLayoutStreams.has(streamId)) {
                    thumbnail.style.borderColor = '#007bff'; // Blue
                    statusIndicator.innerHTML = '<i class="fas fa-circle text-primary" style="font-size: 8px;"></i>';
                } else {
                    thumbnail.style.borderColor = '#6c757d'; // Gray
                    statusIndicator.innerHTML = '<i class="fas fa-circle text-secondary" style="font-size: 8px;"></i>';
                }
            } else {
                // In other layouts: show green if active, yellow if inactive
                if (this.activeStreams.has(streamId)) {
                    thumbnail.style.borderColor = '#28a745'; // Green
                    statusIndicator.innerHTML = '<i class="fas fa-circle text-success" style="font-size: 8px;"></i>';
                } else {
                    thumbnail.style.borderColor = '#ffc107'; // Yellow
                    statusIndicator.innerHTML = '<i class="fas fa-circle text-warning" style="font-size: 8px;"></i>';
                }
            }
        }
    }
}

// Initialize when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        window.streamRecorder = new StreamRecorderOptimized();
        window.streamrecApp = window.streamRecorder; // Alias for button callbacks
    });
} else {
    window.streamRecorder = new StreamRecorderOptimized();
    window.streamrecApp = window.streamRecorder; // Alias for button callbacks
}

console.log('‚úÖ Performance Optimized StreamRec loaded');
</script>
{% endblock %}