{% extends 'base.html' %}
{% load static %}

{% block title %}StreamRec - Professionelles Aufnahme Studio{% endblock %}

{% block page_css %}
<link rel="stylesheet" href="{% static 'streamrec/css/streamrec.css' %}?v={% now 'U' %}&cache_bust=20250820">
<!-- SELF-CONTAINED VERSION: CSS LOADED -->
<style>
/* Enhanced Studio Styles */
.studio-container {
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    min-height: 100vh;
    padding: 2rem 0;
}

.studio-header {
    background: var(--streamrec-primary);
    color: white;
    padding: 2rem 0;
    margin-bottom: 2rem;
    border-radius: 0 0 2rem 2rem;
    box-shadow: var(--streamrec-shadow);
}

.control-panel {
    background: white;
    border-radius: var(--streamrec-border-radius);
    box-shadow: var(--streamrec-shadow);
    padding: 1.5rem;
    margin-bottom: 1.5rem;
    transition: var(--streamrec-transition);
}

.control-panel:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 30px rgba(102, 126, 234, 0.2);
}

.preview-area {
    background: #1a1a1a;
    border-radius: var(--streamrec-border-radius);
    padding: 1rem;
    box-shadow: var(--streamrec-shadow);
}

.phase-indicator {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    background: rgba(255, 255, 255, 0.2);
    padding: 0.5rem 1rem;
    border-radius: 2rem;
    font-size: 0.875rem;
}

.phase-badge {
    background: white;
    color: var(--streamrec-primary);
    padding: 0.25rem 0.75rem;
    border-radius: 1rem;
    font-weight: 600;
    font-size: 0.75rem;
}

/* Layout Manager Styles */
.layout-presets-fallback {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
}

.layout-chip {
    white-space: nowrap;
}

/* Recording Controls */
.recording-dot {
    width: 8px;
    height: 8px;
    background: currentColor;
    border-radius: 50%;
    animation: recording-pulse 1s infinite;
}

@keyframes recording-pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.3; }
}

/* CRITICAL FIX: Lesbarkeit - Wei√üer Text auf wei√üem Hintergrund vermeiden */

/* Control Panel Basis-Styling */
.control-panel {
    background-color: #ffffff !important;
    color: #212529 !important;
    border: 1px solid #dee2e6 !important;
}

/* Alle Text-Elemente in Control Panels */
.control-panel *,
.control-panel h1, .control-panel h2, .control-panel h3, 
.control-panel h4, .control-panel h5, .control-panel h6,
.control-panel p, .control-panel span, .control-panel div,
.control-panel small, .control-panel label,
.control-panel .text-muted,
.control-panel .form-label {
    color: #212529 !important;
    background-color: transparent !important;
}

/* Layout Controls spezifisch */
#layoutControls {
    background-color: #ffffff !important;
    color: #212529 !important;
}

/* Buttons - Outline Buttons behalten Farbigkeit */
.control-panel .btn-outline-primary {
    color: #0d6efd !important;
    background-color: transparent !important;
    border-color: #0d6efd !important;
}

.control-panel .btn-outline-success {
    color: #198754 !important;
    background-color: transparent !important;
    border-color: #198754 !important;
}

.control-panel .btn-outline-danger {
    color: #dc3545 !important;
    background-color: transparent !important;
    border-color: #dc3545 !important;
}

.control-panel .btn-outline-warning {
    color: #fd7e14 !important;
    background-color: transparent !important;
    border-color: #fd7e14 !important;
}

.control-panel .btn-outline-info {
    color: #0dcaf0 !important;
    background-color: transparent !important;
    border-color: #0dcaf0 !important;
}

/* Gef√ºllte Buttons - Vollst√§ndige Definition */
.control-panel .btn-primary,
#layoutControls .btn-primary,
#recordingControlsContainer .btn-primary {
    background-color: #0d6efd !important;
    border-color: #0d6efd !important;
    color: #ffffff !important;
}

.control-panel .btn-success,
#layoutControls .btn-success,
#recordingControlsContainer .btn-success {
    background-color: #198754 !important;
    border-color: #198754 !important;
    color: #ffffff !important;
}

.control-panel .btn-danger,
#layoutControls .btn-danger,
#recordingControlsContainer .btn-danger {
    background-color: #dc3545 !important;
    border-color: #dc3545 !important;
    color: #ffffff !important;
}

.control-panel .btn-warning,
#layoutControls .btn-warning,
#recordingControlsContainer .btn-warning {
    background-color: #fd7e14 !important;
    border-color: #fd7e14 !important;
    color: #ffffff !important;
}

.control-panel .btn-info,
#layoutControls .btn-info,
#recordingControlsContainer .btn-info {
    background-color: #0dcaf0 !important;
    border-color: #0dcaf0 !important;
    color: #000000 !important;
}

.control-panel .btn-light,
#layoutControls .btn-light,
#recordingControlsContainer .btn-light {
    background-color: #f8f9fa !important;
    border-color: #f8f9fa !important;
    color: #212529 !important;
}

.control-panel .btn-secondary,
#layoutControls .btn-secondary,
#recordingControlsContainer .btn-secondary {
    background-color: #6c757d !important;
    border-color: #6c757d !important;
    color: #ffffff !important;
}

.control-panel .btn-dark,
#layoutControls .btn-dark,
#recordingControlsContainer .btn-dark {
    background-color: #212529 !important;
    border-color: #212529 !important;
    color: #ffffff !important;
}

/* WICHTIG: Base Template Container nicht beeinflussen */
main.container .bg-white {
    background-color: #ffffff !important;
    color: #212529 !important;
    padding: 1.5rem 2rem !important;
    margin: 0 !important;
    border-radius: 0.5rem !important;
    box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075) !important;
    min-height: auto !important;
    max-width: none !important;
}

/* Form Elemente */
.control-panel .form-select,
.control-panel .form-control,
.control-panel select,
.control-panel input,
.control-panel textarea {
    color: #212529 !important;
    background-color: #ffffff !important;
    border-color: #ced4da !important;
}

/* Alerts */
.alert {
    color: #212529 !important;
}

.alert-warning {
    background-color: #fff3cd !important;
    border-color: #ffecb5 !important;
    color: #664d03 !important;
}

.alert-info {
    background-color: #d1ecf1 !important;
    border-color: #bee5eb !important;
    color: #0c5460 !important;
}
</style>
{% endblock %}

{% block fullscreen_content %}
<!-- StreamRec Self-Contained Version - √ºberschreibt fullscreen_content -->
<div class="studio-container">
    <!-- Enhanced Header -->
    <div class="studio-header">
        <div class="container-fluid">
            <div class="row align-items-center">
                <div class="col-md-8">
                    <h1 class="display-5 fw-bold mb-2">
                        <i class="fas fa-video-camera me-3"></i>
                        StreamRec Studio
                    </h1>
                    <p class="lead mb-0">Professionelle Multi-Stream Video Aufnahme</p>
                    <div class="phase-indicator mt-3">
                        <i class="fas fa-rocket"></i>
                        <span>Self-Contained Version</span>
                        <div class="phase-badge">Alle Features Inline</div>
                    </div>
                </div>
                <div class="col-md-4 text-md-end">
                    <div class="studio-stats">
                        <div class="row text-center">
                            <div class="col-4">
                                <div class="stat-value">3:00</div>
                                <div class="stat-label">Max. Dauer</div>
                            </div>
                            <div class="col-4">
                                <div class="stat-value">9:16</div>
                                <div class="stat-label">Format</div>
                            </div>
                            <div class="col-4">
                                <div class="stat-value" id="activeStreams">0</div>
                                <div class="stat-label">Streams</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="container-fluid">
        <div class="row">
            <!-- Enhanced Control Panel -->
            <div class="col-12 col-xl-4">
                <!-- Stream Controls -->
                <div class="control-panel">
                    <h5 class="text-gradient mb-4">
                        <i class="fas fa-sliders-h me-2"></i>
                        Stream Kontrolle
                    </h5>
                    
                    <!-- Camera Section -->
                    <div class="mb-4">
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <h6 class="mb-0">
                                <i class="fas fa-camera text-success me-2"></i>Kamera
                            </h6>
                            <div class="status-indicator" id="cameraStatusBadge">
                                <i class="fas fa-circle text-secondary"></i>
                            </div>
                        </div>
                        <div class="d-grid gap-2">
                            <button id="startCameraBtn" class="btn btn-outline-success streamrec-btn">
                                <i class="fas fa-play me-2"></i>Kamera starten
                            </button>
                            <button id="stopCameraBtn" class="btn btn-outline-danger streamrec-btn" disabled>
                                <i class="fas fa-stop me-2"></i>Kamera stoppen
                            </button>
                        </div>
                        <small id="cameraStatus" class="text-muted d-block mt-2">Status: Nicht aktiv</small>
                    </div>

                    <!-- Screen Section -->
                    <div class="mb-4">
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <h6 class="mb-0">
                                <i class="fas fa-desktop text-info me-2"></i>Bildschirm
                            </h6>
                            <div class="status-indicator" id="screenStatusBadge">
                                <i class="fas fa-circle text-secondary"></i>
                            </div>
                        </div>
                        <div class="d-grid gap-2">
                            <button id="startScreenBtn" class="btn btn-outline-info streamrec-btn">
                                <i class="fas fa-desktop me-2"></i>Bildschirm teilen
                            </button>
                            <button id="stopScreenBtn" class="btn btn-outline-danger streamrec-btn" disabled>
                                <i class="fas fa-stop me-2"></i>Bildschirm stoppen
                            </button>
                        </div>
                        <small id="screenStatus" class="text-muted d-block mt-2">Status: Nicht aktiv</small>
                    </div>

                    <!-- Composition Controls -->
                    <div class="mb-4">
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <h6 class="mb-0">
                                <i class="fas fa-palette text-warning me-2"></i>Komposition
                            </h6>
                            <div class="status-indicator" id="compositionStatusBadge">
                                <i class="fas fa-circle text-secondary"></i>
                            </div>
                        </div>
                        <div class="d-grid gap-2">
                            <button id="startCompositionBtn" class="btn btn-outline-warning streamrec-btn" disabled>
                                <i class="fas fa-layer-group me-2"></i>Komposition starten
                            </button>
                            <button id="stopCompositionBtn" class="btn btn-outline-danger streamrec-btn" disabled>
                                <i class="fas fa-stop me-2"></i>Komposition stoppen
                            </button>
                        </div>
                        <small id="compositionStatus" class="text-muted d-block mt-2">Status: Nicht aktiv</small>
                    </div>
                </div>

                <!-- Layout Manager (Self-Contained) -->
                <div class="control-panel" id="layoutControls">
                    <h5 class="text-gradient mb-4">
                        <i class="fas fa-th-large me-2"></i>
                        Layout Manager
                        <span class="badge bg-success ms-2">Self-Contained</span>
                    </h5>
                    <div class="layout-presets-fallback">
                        <button class="btn btn-outline-primary btn-sm me-2 mb-2" onclick="streamRecorder.applyLayout('pip')">
                            üì± Picture-in-Picture
                        </button>
                        <button class="btn btn-outline-primary btn-sm me-2 mb-2" onclick="streamRecorder.applyLayout('side')">
                            ‚ÜîÔ∏è Nebeneinander
                        </button>
                        <button class="btn btn-outline-primary btn-sm me-2 mb-2" onclick="streamRecorder.applyLayout('stack')">
                            ‚¨áÔ∏è Gestapelt
                        </button>
                        <button class="btn btn-outline-primary btn-sm me-2 mb-2" onclick="streamRecorder.applyLayout('fullscreen')">
                            üñ•Ô∏è Vollbild
                        </button>
                    </div>
                </div>

                <!-- Recording Controls (Self-Contained) -->
                <div class="control-panel">
                    <h5 class="text-gradient mb-4">
                        <i class="fas fa-record-vinyl me-2"></i>
                        Aufnahme Kontrolle
                        <span class="badge bg-success ms-2">Self-Contained</span>
                    </h5>
                    <div class="d-grid gap-2">
                        <button id="recordBtn" class="btn btn-danger streamrec-btn" onclick="streamRecorder.startRecording()">
                            <i class="fas fa-circle me-2"></i>Aufnahme starten
                        </button>
                        <button id="stopRecordBtn" class="btn btn-secondary streamrec-btn" disabled onclick="streamRecorder.stopRecording()">
                            <i class="fas fa-stop me-2"></i>Aufnahme stoppen
                        </button>
                    </div>
                    <small class="text-muted d-block mt-2" id="recordingStatus">
                        Status: Bereit f√ºr Aufnahme
                    </small>
                    <div class="mt-3">
                        <div class="progress" style="height: 5px;">
                            <div class="progress-bar bg-danger" id="recordingProgress" style="width: 0%"></div>
                        </div>
                        <small class="text-muted">Aufnahme-Progress</small>
                    </div>
                </div>

                <!-- System Information -->
                <div class="control-panel">
                    <h5 class="text-gradient mb-4">
                        <i class="fas fa-info-circle me-2"></i>
                        System Information
                    </h5>
                    <div class="row">
                        <div class="col-6">
                            <div class="system-info-item">
                                <small class="text-muted">Browser:</small>
                                <div id="browserInfo" class="fw-bold">-</div>
                            </div>
                        </div>
                        <div class="col-6">
                            <div class="system-info-item">
                                <small class="text-muted">WebRTC:</small>
                                <div id="webrtcSupport" class="fw-bold">-</div>
                            </div>
                        </div>
                        <div class="col-6">
                            <div class="system-info-item">
                                <small class="text-muted">Canvas:</small>
                                <div id="canvasSupport" class="fw-bold">-</div>
                            </div>
                        </div>
                        <div class="col-6">
                            <div class="system-info-item">
                                <small class="text-muted">Recording:</small>
                                <div id="mediaRecorderSupport" class="fw-bold">-</div>
                            </div>
                        </div>
                    </div>
                    <div id="performanceMetrics" class="mt-3 text-center">
                        <small class="text-muted">Performance wird √ºberwacht...</small>
                    </div>
                </div>
            </div>

            <!-- Enhanced Preview Area -->
            <div class="col-12 col-xl-8">
                <div class="preview-area">
                    <!-- Preview Header -->
                    <div class="d-flex justify-content-between align-items-center mb-3">
                        <h5 class="text-white mb-0">
                            <i class="fas fa-eye me-2"></i>
                            Live Vorschau (9:16)
                        </h5>
                        <div class="preview-controls">
                            <button class="btn btn-sm btn-outline-light me-2" id="fullscreenBtn">
                                <i class="fas fa-expand"></i>
                            </button>
                        </div>
                    </div>

                    <!-- Canvas Container -->
                    <div id="previewContainer" class="position-relative d-flex align-items-center justify-content-center" 
                         style="height: 600px; border-radius: var(--streamrec-border-radius); overflow: hidden;">
                        
                        <canvas id="compositionCanvas" 
                                width="360" 
                                height="640" 
                                class="border border-secondary"
                                style="max-width: 100%; max-height: 100%; object-fit: contain;">
                        </canvas>
                        
                        <!-- No Content Overlay -->
                        <div id="noContentOverlay" class="position-absolute top-50 start-50 translate-middle text-center text-white">
                            <div class="mb-4">
                                <i class="fas fa-video fa-4x mb-3 opacity-25"></i>
                                <h4>Keine Streams aktiv</h4>
                                <p class="text-muted">Starten Sie Kamera oder Bildschirm-Sharing um zu beginnen</p>
                            </div>
                            <div class="d-grid gap-2 d-md-flex justify-content-md-center">
                                <button class="btn btn-success" onclick="document.getElementById('startCameraBtn').click()">
                                    <i class="fas fa-camera me-2"></i>Kamera starten
                                </button>
                                <button class="btn btn-info" onclick="document.getElementById('startScreenBtn').click()">
                                    <i class="fas fa-desktop me-2"></i>Bildschirm teilen
                                </button>
                            </div>
                        </div>

                        <!-- Recording Indicator -->
                        <div id="recordingIndicator" class="position-absolute top-0 start-0 m-3" style="display: none;">
                            <div class="d-flex align-items-center bg-danger text-white px-3 py-2 rounded-pill">
                                <div class="recording-dot me-2"></div>
                                <span class="fw-bold">REC</span>
                                <span class="ms-2" id="recordingTime">00:00</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Stream Thumbnails -->
                    <div class="mt-4">
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <h6 class="text-white mb-0">Aktive Streams:</h6>
                        </div>
                        <div id="streamThumbnails" class="d-flex gap-3 flex-wrap">
                            <div id="noStreamsMessage" class="text-muted text-center flex-grow-1 py-4">
                                <i class="fas fa-info-circle me-2"></i>
                                Noch keine Streams erfasst
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block page_js %}
<!-- SELF-CONTAINED VERSION: All JavaScript Inline -->
<script>
console.log('üöÄ StreamRec Self-Contained Version wird geladen...');

/**
 * Self-Contained StreamRec - All Features Inline
 */
class StreamRecorderSelfContained {
    constructor() {
        this.streams = new Map();
        this.canvas = null;
        this.ctx = null;
        this.isComposing = false;
        this.animationFrame = null;
        this.currentLayout = 'pip';
        this.mediaRecorder = null;
        this.recordedChunks = [];
        this.isRecording = false;
        this.recordingStartTime = null;
        this.recordingTimer = null;
        this.maxDuration = 180000; // 3 minutes
        
        this.init();
    }

    init() {
        this.canvas = document.getElementById('compositionCanvas');
        if (!this.canvas) {
            console.error('‚ùå Canvas nicht gefunden');
            return;
        }
        
        this.ctx = this.canvas.getContext('2d');
        this.setupEventListeners();
        this.checkBrowserSupport();
        this.showNotification('success', 'StreamRec bereit', 'Self-Contained Version geladen');
        console.log('‚úÖ StreamRec Self-Contained initialisiert');
    }

    setupEventListeners() {
        // Camera controls
        document.getElementById('startCameraBtn')?.addEventListener('click', () => this.startCamera());
        document.getElementById('stopCameraBtn')?.addEventListener('click', () => this.stopCamera());
        
        // Screen controls
        document.getElementById('startScreenBtn')?.addEventListener('click', () => this.startScreen());
        document.getElementById('stopScreenBtn')?.addEventListener('click', () => this.stopScreen());
        
        // Composition controls
        document.getElementById('startCompositionBtn')?.addEventListener('click', () => this.startComposition());
        document.getElementById('stopCompositionBtn')?.addEventListener('click', () => this.stopComposition());

        // Fullscreen
        document.getElementById('fullscreenBtn')?.addEventListener('click', () => {
            if (this.canvas.requestFullscreen) {
                this.canvas.requestFullscreen();
            }
        });
    }

    checkBrowserSupport() {
        const support = {
            getUserMedia: !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia),
            getDisplayMedia: !!(navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia),
            canvas: !!(this.canvas && this.ctx),
            mediaRecorder: !!(window.MediaRecorder)
        };

        // Update UI
        document.getElementById('browserInfo').textContent = this.getBrowserInfo();
        document.getElementById('webrtcSupport').textContent = support.getUserMedia ? '‚úÖ' : '‚ùå';
        document.getElementById('canvasSupport').textContent = support.canvas ? '‚úÖ' : '‚ùå';
        document.getElementById('mediaRecorderSupport').textContent = support.mediaRecorder ? '‚úÖ' : '‚ùå';
        
        console.log('üîç Browser Support:', support);
        return support;
    }

    getBrowserInfo() {
        const ua = navigator.userAgent;
        if (ua.includes('Chrome')) return 'Chrome';
        if (ua.includes('Firefox')) return 'Firefox';
        if (ua.includes('Safari')) return 'Safari';
        return 'Unbekannt';
    }

    async startCamera() {
        try {
            this.updateStatus('camera', 'Kamera wird gestartet...', 'info');
            
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { 
                    width: { ideal: 1920 },
                    height: { ideal: 1080 },
                    frameRate: { ideal: 30 }
                },
                audio: true
            });

            this.streams.set('camera', stream);
            this.updateStatus('camera', 'Aktiv', 'success');
            this.updateButtons('camera', true);
            this.addStreamThumbnail('camera', stream);
            this.checkCompositionReady();
            this.updateActiveStreamsCount();
            this.updateStatusBadge('camera', 'success');
            this.showNotification('success', 'Kamera gestartet', 'Kamera-Stream ist nun aktiv');

            console.log('‚úÖ Kamera-Stream erfolgreich gestartet');
        } catch (error) {
            console.error('‚ùå Kamera-Zugriff fehlgeschlagen:', error);
            this.updateStatus('camera', `Fehler: ${error.message}`, 'danger');
            this.updateStatusBadge('camera', 'danger');
            this.showNotification('error', 'Kamera-Fehler', error.message);
        }
    }

    async startScreen() {
        try {
            this.updateStatus('screen', 'Bildschirm-Sharing wird gestartet...', 'info');
            
            const stream = await navigator.mediaDevices.getDisplayMedia({
                video: {
                    width: { ideal: 1920 },
                    height: { ideal: 1080 },
                    frameRate: { ideal: 30 },
                    cursor: 'always'
                },
                audio: true
            });

            this.streams.set('screen', stream);
            this.updateStatus('screen', 'Aktiv', 'success');
            this.updateButtons('screen', true);
            this.addStreamThumbnail('screen', stream);
            this.checkCompositionReady();
            this.updateActiveStreamsCount();
            this.updateStatusBadge('screen', 'success');
            this.showNotification('success', 'Bildschirm geteilt', 'Bildschirm-Stream ist nun aktiv');

            // Handle screen sharing end event
            stream.getVideoTracks()[0].addEventListener('ended', () => {
                this.stopScreen();
            });

            console.log('‚úÖ Bildschirm-Stream erfolgreich gestartet');
        } catch (error) {
            console.error('‚ùå Bildschirm-Capture fehlgeschlagen:', error);
            this.updateStatus('screen', `Fehler: ${error.message}`, 'danger');
            this.updateStatusBadge('screen', 'danger');
            this.showNotification('error', 'Bildschirm-Fehler', error.message);
        }
    }

    startComposition() {
        if (this.streams.size === 0) {
            this.showNotification('warning', 'Keine Streams', 'Bitte starten Sie zuerst Kamera oder Bildschirm-Sharing');
            return;
        }
        
        this.isComposing = true;
        this.updateStatus('composition', 'Aktiv', 'success');
        this.updateButtons('composition', true);
        this.updateStatusBadge('composition', 'warning');
        this.renderComposition();
        this.showNotification('info', 'Komposition aktiv', 'Live-Vorschau wird angezeigt');
        console.log('‚úÖ Live Composition gestartet');
    }

    renderComposition() {
        if (!this.isComposing) return;

        this.clearCanvas();
        this.renderCurrentLayout();
        this.updateRecordingIndicator();
        this.animationFrame = requestAnimationFrame(() => this.renderComposition());
    }

    renderCurrentLayout() {
        const streams = Array.from(this.streams.entries());
        
        switch (this.currentLayout) {
            case 'pip':
                this.renderPictureInPicture(streams);
                break;
            case 'side':
                this.renderSideBySide(streams);
                break;
            case 'stack':
                this.renderStacked(streams);
                break;
            case 'fullscreen':
                this.renderFullscreen(streams);
                break;
            default:
                this.renderPictureInPicture(streams);
        }
    }

    renderPictureInPicture(streams) {
        streams.forEach(([type, stream]) => {
            const video = this.getVideoElement(type, stream);
            if (!video || video.readyState < 2) return;

            if (type === 'screen') {
                this.ctx.drawImage(video, 0, 0, this.canvas.width, this.canvas.height);
            } else if (type === 'camera') {
                const size = 120;
                const x = this.canvas.width - size - 20;
                const y = 20;
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = 3;
                this.ctx.strokeRect(x - 3, y - 3, size + 6, size + 6);
                this.ctx.drawImage(video, x, y, size, size);
            }
        });
    }

    renderSideBySide(streams) {
        const streamArray = Array.from(streams);
        const halfWidth = this.canvas.width / 2;
        
        streamArray.forEach(([type, stream], index) => {
            const video = this.getVideoElement(type, stream);
            if (!video || video.readyState < 2) return;
            
            const x = index * halfWidth;
            this.ctx.drawImage(video, x, 0, halfWidth, this.canvas.height);
            
            // Draw separator
            if (index === 0) {
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(halfWidth, 0);
                this.ctx.lineTo(halfWidth, this.canvas.height);
                this.ctx.stroke();
            }
        });
    }

    renderStacked(streams) {
        const streamArray = Array.from(streams);
        const height = this.canvas.height / streamArray.length;
        
        streamArray.forEach(([type, stream], index) => {
            const video = this.getVideoElement(type, stream);
            if (!video || video.readyState < 2) return;
            
            const y = index * height;
            this.ctx.drawImage(video, 0, y, this.canvas.width, height);
            
            // Draw separator
            if (index > 0) {
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(0, y);
                this.ctx.lineTo(this.canvas.width, y);
                this.ctx.stroke();
            }
        });
    }

    renderFullscreen(streams) {
        // Show first stream fullscreen
        const firstStream = Array.from(streams)[0];
        if (firstStream) {
            const [type, stream] = firstStream;
            const video = this.getVideoElement(type, stream);
            if (video && video.readyState >= 2) {
                this.ctx.drawImage(video, 0, 0, this.canvas.width, this.canvas.height);
            }
        }
    }

    applyLayout(layout) {
        this.currentLayout = layout;
        this.showNotification('info', 'Layout ge√§ndert', `${layout} Layout aktiviert`);
        console.log(`üìê Layout angewendet: ${layout}`);
    }

    // Recording Methods
    startRecording() {
        if (!this.isComposing) {
            this.showNotification('warning', 'Komposition erforderlich', 'Bitte starten Sie zuerst die Live-Komposition');
            return;
        }

        try {
            const stream = this.canvas.captureStream(30);
            this.mediaRecorder = new MediaRecorder(stream);
            this.recordedChunks = [];

            this.mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    this.recordedChunks.push(event.data);
                }
            };

            this.mediaRecorder.onstop = () => {
                const blob = new Blob(this.recordedChunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `streamrec-recording-${Date.now()}.webm`;
                a.click();
                this.showNotification('success', 'Download', 'Video wurde heruntergeladen');
                this.resetRecordingUI();
            };

            this.mediaRecorder.start();
            this.isRecording = true;
            this.recordingStartTime = Date.now();
            
            document.getElementById('recordBtn').disabled = true;
            document.getElementById('stopRecordBtn').disabled = false;
            document.getElementById('recordingStatus').textContent = 'Status: Aufnahme l√§uft';
            document.getElementById('recordingIndicator').style.display = 'block';
            
            this.startRecordingTimer();
            this.showNotification('success', 'Aufnahme gestartet', 'Recording l√§uft');
            console.log('üìπ Recording gestartet');

        } catch (error) {
            console.error('‚ùå Recording Fehler:', error);
            this.showNotification('error', 'Aufnahme-Fehler', error.message);
        }
    }

    stopRecording() {
        if (this.mediaRecorder && this.mediaRecorder.state === 'recording') {
            this.mediaRecorder.stop();
            this.isRecording = false;
            this.stopRecordingTimer();
            console.log('üìπ Recording gestoppt');
        }
    }

    startRecordingTimer() {
        this.recordingTimer = setInterval(() => {
            const elapsed = Date.now() - this.recordingStartTime;
            const minutes = Math.floor(elapsed / 60000);
            const seconds = Math.floor((elapsed % 60000) / 1000);
            
            document.getElementById('recordingTime').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            // Update progress bar
            const progress = (elapsed / this.maxDuration) * 100;
            document.getElementById('recordingProgress').style.width = `${Math.min(progress, 100)}%`;
            
            // Auto-stop at max duration
            if (elapsed >= this.maxDuration) {
                this.stopRecording();
                this.showNotification('info', 'Aufnahme beendet', 'Maximale Aufnahmedauer erreicht (3 Minuten)');
            }
        }, 1000);
    }

    stopRecordingTimer() {
        if (this.recordingTimer) {
            clearInterval(this.recordingTimer);
            this.recordingTimer = null;
        }
    }

    resetRecordingUI() {
        document.getElementById('recordBtn').disabled = false;
        document.getElementById('stopRecordBtn').disabled = true;
        document.getElementById('recordingStatus').textContent = 'Status: Bereit f√ºr Aufnahme';
        document.getElementById('recordingIndicator').style.display = 'none';
        document.getElementById('recordingProgress').style.width = '0%';
        document.getElementById('recordingTime').textContent = '00:00';
    }

    updateRecordingIndicator() {
        const indicator = document.getElementById('recordingIndicator');
        if (indicator) {
            indicator.style.display = this.isRecording ? 'block' : 'none';
        }
    }

    // Helper Methods
    getVideoElement(type, stream) {
        let video = document.getElementById(`video-${type}`);
        if (!video) {
            video = document.createElement('video');
            video.id = `video-${type}`;
            video.srcObject = stream;
            video.autoplay = true;
            video.muted = true;
            video.playsInline = true;
            video.style.display = 'none';
            document.body.appendChild(video);
        }
        return video;
    }

    clearCanvas() {
        this.ctx.fillStyle = '#000000';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Show no content overlay if no streams
        const hasStreams = this.streams.size > 0;
        document.getElementById('noContentOverlay').style.display = hasStreams ? 'none' : 'block';
    }

    updateStatus(type, message, variant) {
        const statusElement = document.getElementById(`${type}Status`);
        if (statusElement) {
            statusElement.textContent = `Status: ${message}`;
            statusElement.className = `text-${variant} d-block mt-2`;
        }
    }

    updateButtons(type, active) {
        const startBtn = document.getElementById(`start${type.charAt(0).toUpperCase() + type.slice(1)}Btn`);
        const stopBtn = document.getElementById(`stop${type.charAt(0).toUpperCase() + type.slice(1)}Btn`);
        
        if (startBtn) startBtn.disabled = active;
        if (stopBtn) stopBtn.disabled = !active;
    }

    updateStatusBadge(type, variant) {
        const badge = document.getElementById(`${type}StatusBadge`);
        if (badge) {
            const icon = badge.querySelector('i');
            icon.className = `fas fa-circle text-${variant}`;
            
            if (variant === 'success' || variant === 'warning') {
                icon.classList.add('fa-pulse');
            } else {
                icon.classList.remove('fa-pulse');
            }
        }
    }

    addStreamThumbnail(type, stream) {
        const container = document.getElementById('streamThumbnails');
        const noStreamsMsg = document.getElementById('noStreamsMessage');
        if (noStreamsMsg) noStreamsMsg.style.display = 'none';

        const thumbnailDiv = document.createElement('div');
        thumbnailDiv.id = `thumbnail-${type}`;
        thumbnailDiv.className = 'stream-thumbnail position-relative';
        
        const video = document.createElement('video');
        video.srcObject = stream;
        video.autoplay = true;
        video.muted = true;
        video.playsInline = true;
        video.style.width = '80px';
        video.style.height = '60px';
        video.style.objectFit = 'cover';
        video.className = 'rounded border';
        
        const label = document.createElement('small');
        label.className = 'position-absolute bottom-0 start-0 bg-primary text-white px-1 rounded-end';
        label.textContent = type === 'camera' ? 'Kamera' : 'Bildschirm';
        
        thumbnailDiv.appendChild(video);
        thumbnailDiv.appendChild(label);
        if (container) container.appendChild(thumbnailDiv);
    }

    removeStreamThumbnail(type) {
        const thumbnail = document.getElementById(`thumbnail-${type}`);
        if (thumbnail) {
            thumbnail.remove();
        }
        
        const container = document.getElementById('streamThumbnails');
        const noStreamsMsg = document.getElementById('noStreamsMessage');
        
        if (container && noStreamsMsg && container.children.length === 1) {
            noStreamsMsg.style.display = 'block';
        }
    }

    updateActiveStreamsCount() {
        const count = this.streams.size;
        document.getElementById('activeStreams').textContent = count;
        
        // Update stream thumbnails display
        const noStreamsMsg = document.getElementById('noStreamsMessage');
        if (noStreamsMsg) {
            noStreamsMsg.style.display = count > 0 ? 'none' : 'block';
        }
    }

    checkCompositionReady() {
        const hasStreams = this.streams.size > 0;
        const compositionBtn = document.getElementById('startCompositionBtn');
        if (compositionBtn) {
            compositionBtn.disabled = !hasStreams;
        }
        
        if (!hasStreams && this.isComposing) {
            this.stopComposition();
        }
    }

    stopCamera() {
        const stream = this.streams.get('camera');
        if (stream) {
            stream.getTracks().forEach(track => track.stop());
            this.streams.delete('camera');
            this.updateStatus('camera', 'Nicht aktiv', 'muted');
            this.updateButtons('camera', false);
            this.removeStreamThumbnail('camera');
            this.checkCompositionReady();
            this.updateActiveStreamsCount();
            this.updateStatusBadge('camera', 'secondary');
            console.log('üõë Kamera-Stream gestoppt');
        }
    }

    stopScreen() {
        const stream = this.streams.get('screen');
        if (stream) {
            stream.getTracks().forEach(track => track.stop());
            this.streams.delete('screen');
            this.updateStatus('screen', 'Nicht aktiv', 'muted');
            this.updateButtons('screen', false);
            this.removeStreamThumbnail('screen');
            this.checkCompositionReady();
            this.updateActiveStreamsCount();
            this.updateStatusBadge('screen', 'secondary');
            console.log('üõë Bildschirm-Stream gestoppt');
        }
    }

    stopComposition() {
        this.isComposing = false;
        this.updateStatus('composition', 'Nicht aktiv', 'muted');
        this.updateButtons('composition', false);
        this.updateStatusBadge('composition', 'secondary');
        
        if (this.animationFrame) {
            cancelAnimationFrame(this.animationFrame);
        }
        
        this.clearCanvas();
        console.log('üõë Live Composition gestoppt');
    }

    showNotification(type, title, message) {
        console.log(`üì¢ ${type.toUpperCase()}: ${title} - ${message}`);
        
        // Create visual notification
        const alertType = type === 'error' ? 'danger' : type;
        const alertDiv = document.createElement('div');
        alertDiv.className = `alert alert-${alertType === 'success' ? 'success' : alertType === 'error' ? 'danger' : 'info'} alert-dismissible fade show position-fixed`;
        alertDiv.style.cssText = 'top: 20px; right: 20px; z-index: 9999; max-width: 350px;';
        alertDiv.innerHTML = `
            <strong>${title}</strong> ${message}
            <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
        `;
        document.body.appendChild(alertDiv);
        setTimeout(() => alertDiv.remove(), 5000);
    }
}

// Initialize StreamRecorder when page loads
document.addEventListener('DOMContentLoaded', () => {
    console.log('üöÄ StreamRec Self-Contained wird geladen...');
    window.streamRecorder = new StreamRecorderSelfContained();
    console.log('‚úÖ StreamRec Self-Contained erfolgreich geladen!');
});
</script>
{% endblock %}