{% extends 'base.html' %}
{% load static %}

{% block title %}{{ book.title }} - LearnLoom{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="{% static 'learnloom/css/learnloom.css' %}?v={% now 'U' %}">
<style>
    body { overflow: hidden; }
    .navbar, footer { display: none !important; }

    /* Loading Overlay */
    .loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(82, 86, 89, 0.95);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 3000;
    }
    .loading-spinner {
        width: 60px;
        height: 60px;
        border: 4px solid rgba(255,255,255,0.3);
        border-top: 4px solid #fff;
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    .loading-text {
        color: white;
        margin-top: 20px;
        font-size: 1.1rem;
    }
    .loading-progress {
        color: rgba(255,255,255,0.7);
        margin-top: 10px;
        font-size: 0.9rem;
    }

    /* Proper Text Layer Styling - PDF.js official */
    .pdf-page {
        position: relative;
        margin-bottom: 20px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        line-height: 0; /* Remove extra space below canvas */
    }
    .pdf-page canvas {
        display: block;
        margin: 0;
        padding: 0;
    }
    /* Text Layer for PDF.js 3.x */
    .textLayer {
        position: absolute;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        overflow: hidden;
        line-height: 1.0;
        -webkit-text-size-adjust: none;
        -moz-text-size-adjust: none;
        text-size-adjust: none;
        forced-color-adjust: none;
        transform-origin: 0 0;
        z-index: 2;
    }
    .textLayer > span {
        color: transparent;
        position: absolute;
        white-space: pre;
        cursor: text;
        transform-origin: 0% 0%;
    }
    .textLayer ::selection {
        background: rgba(0, 100, 255, 0.4);
    }

    /* Highlight Overlay */
    .highlight-overlay {
        position: absolute;
        background-color: rgba(255, 235, 59, 0.4);
        pointer-events: auto;
        cursor: pointer;
        z-index: 3;
        border-radius: 2px;
    }
    .highlight-overlay:hover {
        background-color: rgba(255, 235, 59, 0.6);
    }

    /* Selection Mode */
    .select-mode-active .pdf-canvas-container {
        cursor: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32'%3E%3Cline x1='16' y1='0' x2='16' y2='32' stroke='%23f39c12' stroke-width='2'/%3E%3Cline x1='0' y1='16' x2='32' y2='16' stroke='%23f39c12' stroke-width='2'/%3E%3Ccircle cx='16' cy='16' r='6' fill='none' stroke='%23f39c12' stroke-width='2'/%3E%3C/svg%3E") 16 16, crosshair !important;
    }
    .select-mode-active .pdf-canvas-container * {
        cursor: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32'%3E%3Cline x1='16' y1='0' x2='16' y2='32' stroke='%23f39c12' stroke-width='2'/%3E%3Cline x1='0' y1='16' x2='32' y2='16' stroke='%23f39c12' stroke-width='2'/%3E%3Ccircle cx='16' cy='16' r='6' fill='none' stroke='%23f39c12' stroke-width='2'/%3E%3C/svg%3E") 16 16, crosshair !important;
        user-select: none !important;
    }
    .selection-rect {
        position: fixed;
        border: 3px solid #f39c12;
        background: rgba(243, 156, 18, 0.25);
        pointer-events: none;
        z-index: 2000;
        display: none;
        box-shadow: 0 0 0 3px rgba(243, 156, 18, 0.4), inset 0 0 10px rgba(243, 156, 18, 0.2);
    }
    .select-mode-active .pdf-toolbar #toggleSelectMode {
        background: #0984e3 !important;
        color: white !important;
        border-color: #0984e3 !important;
    }
    .select-mode-hint {
        position: fixed;
        top: 70px;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(135deg, #0984e3, #6c5ce7);
        color: white;
        padding: 12px 24px;
        border-radius: 30px;
        font-size: 14px;
        font-weight: 500;
        z-index: 2100;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    }
</style>
{% endblock %}

{% block content %}
<!-- Loading Overlay -->
<div class="loading-overlay" id="loadingOverlay">
    <div class="loading-spinner"></div>
    <div class="loading-text">PDF wird geladen...</div>
    <div class="loading-progress" id="loadingProgress"></div>
</div>

<!-- Back Button -->
<a href="{% url 'learnloom:index' %}" class="btn btn-light position-fixed" style="top: 15px; left: 15px; z-index: 1200;">
    <i class="bi bi-arrow-left me-2"></i>Zurück
</a>

<!-- Title -->
<div class="position-fixed text-center" style="top: 15px; left: 50%; transform: translateX(-50%); z-index: 1200;">
    <h6 class="mb-0 text-white bg-dark bg-opacity-75 px-3 py-2 rounded">{{ book.title }}</h6>
</div>

<!-- PDF Viewer Container -->
<div class="pdf-viewer-container" id="pdfViewerContainer">
    <div class="pdf-canvas-container" id="pdfCanvasContainer">
        <!-- Pages will be rendered here -->
    </div>
</div>

<!-- Floating Toolbar -->
<div class="pdf-toolbar">
    <button class="btn btn-outline-secondary" id="prevPage" title="Vorherige Seite">
        <i class="bi bi-chevron-left"></i>
    </button>
    <span class="page-info">
        <span id="currentPage">1</span> / <span id="totalPages">-</span>
    </span>
    <button class="btn btn-outline-secondary" id="nextPage" title="Nächste Seite">
        <i class="bi bi-chevron-right"></i>
    </button>

    <div class="divider"></div>

    <button class="btn btn-outline-secondary" id="zoomOut" title="Verkleinern">
        <i class="bi bi-zoom-out"></i>
    </button>
    <span class="zoom-info" id="zoomLevel">100%</span>
    <button class="btn btn-outline-secondary" id="zoomIn" title="Vergrößern">
        <i class="bi bi-zoom-in"></i>
    </button>

    <div class="divider"></div>

    <button class="btn btn-outline-primary" id="toggleNotes" title="Notizen">
        <i class="bi bi-sticky"></i>
    </button>
    <button class="btn btn-info" id="toggleSelectMode" title="Rechteck-Auswahl (Bereich markieren)">
        <i class="bi bi-bounding-box"></i>
    </button>
    <a href="{% url 'learnloom:vocabulary' book.id %}" class="btn btn-success" title="Vokabelliste">
        <i class="bi bi-list-check"></i>
    </a>
</div>

<!-- Selection Rectangle (drawn directly on PDF container) -->
<div id="selectionRect" class="selection-rect"></div>

<!-- Selection Mode Hint -->
<div id="selectModeHint" class="select-mode-hint d-none">
    <i class="bi bi-bounding-box me-2"></i>Ziehe ein Rechteck um das Wort. ESC zum Abbrechen.
</div>

<!-- Notes Panel -->
<div class="notes-panel" id="notesPanel">
    <div class="notes-panel-header">
        <h5 class="mb-0"><i class="bi bi-sticky me-2"></i>Notizen</h5>
        <button class="btn btn-close" id="closeNotes"></button>
    </div>
    <div class="notes-panel-body" id="notesList">
        <!-- Notes will be loaded here -->
    </div>
    <div class="notes-panel-footer">
        <textarea class="form-control mb-2" id="newNoteContent" rows="3" placeholder="Neue Notiz schreiben..."></textarea>
        <div class="d-flex justify-content-between align-items-center">
            <small class="text-muted">Seite: <span id="notePageRef">{{ progress.current_page }}</span></small>
            <button class="btn btn-primary btn-sm" id="saveNote">
                <i class="bi bi-plus-lg me-1"></i>Hinzufügen
            </button>
        </div>
    </div>
</div>

<!-- Translation Popup (hidden by default) -->
<div class="translation-popup d-none" id="translationPopup">
    <div class="mb-2">
        <label class="form-label small text-muted mb-1">Originaltext (editierbar)</label>
        <input type="text" class="form-control form-control-sm" id="popupOriginalInput" placeholder="Text eingeben...">
    </div>
    <div class="d-flex gap-2 mb-2">
        <button class="btn btn-sm btn-primary flex-grow-1" id="retranslateBtn">
            <i class="bi bi-translate me-1"></i>Übersetzen
        </button>
        <button class="btn btn-sm btn-outline-secondary" id="speakOriginal" title="Englisch vorlesen">
            <i class="bi bi-volume-up"></i>
        </button>
    </div>
    <div class="mb-2">
        <label class="form-label small text-muted mb-1">Übersetzung</label>
        <div class="translated-text p-2 bg-light rounded" id="popupTranslation">
            <span class="text-muted">Klicke auf "Übersetzen"</span>
        </div>
    </div>
    <div class="popup-actions d-flex gap-2">
        <button class="btn btn-sm btn-outline-secondary" id="speakTranslation" title="Deutsch vorlesen">
            <i class="bi bi-volume-up"></i> DE
        </button>
        <button class="btn btn-sm btn-success flex-grow-1" id="saveHighlight">
            <i class="bi bi-bookmark-plus me-1"></i>Speichern
        </button>
        <button class="btn btn-sm btn-outline-secondary" id="closePopup">
            <i class="bi bi-x"></i>
        </button>
    </div>
</div>

<!-- Translate Button (appears on selection) -->
<button class="translate-btn-floating d-none" id="translateBtn">
    <i class="bi bi-translate me-1"></i>Übersetzen
</button>
{% endblock %}

{% block extra_js %}
<!-- PDF.js from CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>

<script>
// Configuration
const bookId = '{{ book.id }}';
const pdfUrl = '{% url "learnloom:api_serve_pdf" book.id %}';
const csrfToken = '{{ csrf_token }}';
let currentPage = {{ progress.current_page }};
let totalPages = {{ book.page_count }};
let scale = {{ progress.zoom_level }};
let pdfDoc = null;
let highlights = {{ highlights_json|safe }};
let isRendering = false;
let renderQueue = [];

// Initialize PDF.js
pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';


// Show/Hide Loading
function showLoading(text = 'PDF wird geladen...') {
    document.getElementById('loadingOverlay').style.display = 'flex';
    document.querySelector('.loading-text').textContent = text;
}

function hideLoading() {
    document.getElementById('loadingOverlay').style.display = 'none';
}

function updateLoadingProgress(current, total) {
    document.getElementById('loadingProgress').textContent = `Seite ${current} von ${total}`;
}

// Load PDF
async function loadPDF() {
    showLoading('PDF wird geladen...');

    try {
        const loadingTask = pdfjsLib.getDocument({
            url: pdfUrl,
            cMapUrl: 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/cmaps/',
            cMapPacked: true,
        });

        loadingTask.onProgress = function(progress) {
            if (progress.total > 0) {
                const percent = Math.round((progress.loaded / progress.total) * 100);
                document.getElementById('loadingProgress').textContent = `${percent}% geladen`;
            }
        };

        pdfDoc = await loadingTask.promise;
        totalPages = pdfDoc.numPages;
        document.getElementById('totalPages').textContent = totalPages;

        await renderAllPages();
        hideLoading();

    } catch (error) {
        console.error('Error loading PDF:', error);
        hideLoading();

        const container = document.getElementById('pdfCanvasContainer');
        container.innerHTML = `
            <div class="text-center text-white py-5">
                <i class="bi bi-exclamation-triangle" style="font-size: 4rem;"></i>
                <h4 class="mt-3">Fehler beim Laden des PDFs</h4>
                <p class="text-muted">${error.message || 'Unbekannter Fehler'}</p>
                <button class="btn btn-primary mt-3" onclick="location.reload()">
                    <i class="bi bi-arrow-clockwise me-2"></i>Erneut versuchen
                </button>
            </div>
        `;
    }
}

// Render all pages
async function renderAllPages() {
    if (isRendering) {
        console.log('Already rendering, skipping...');
        return;
    }

    isRendering = true;
    const container = document.getElementById('pdfCanvasContainer');
    container.innerHTML = '';

    showLoading('Seiten werden gerendert...');

    try {
        for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
            updateLoadingProgress(pageNum, totalPages);

            const pageDiv = document.createElement('div');
            pageDiv.className = 'pdf-page';
            pageDiv.dataset.page = pageNum;

            const canvas = document.createElement('canvas');
            pageDiv.appendChild(canvas);

            container.appendChild(pageDiv);

            await renderPage(pageNum, canvas);
        }

        // Scroll to saved position
        scrollToPage(currentPage);

        // Render saved highlights
        setTimeout(() => {
            renderAllHighlights();
        }, 100);

    } catch (error) {
        console.error('Error rendering pages:', error);
    } finally {
        isRendering = false;
        hideLoading();
    }
}

// Render single page
async function renderPage(pageNum, canvas) {
    try {
        const page = await pdfDoc.getPage(pageNum);
        const viewport = page.getViewport({ scale: scale });

        canvas.width = viewport.width;
        canvas.height = viewport.height;

        const ctx = canvas.getContext('2d');

        const renderContext = {
            canvasContext: ctx,
            viewport: viewport
        };

        await page.render(renderContext).promise;

        // Add text layer for selection
        try {
            const textContent = await page.getTextContent();
            const textLayer = document.createElement('div');
            textLayer.className = 'textLayer';

            // Set dimensions and scale factor for PDF.js 3.x
            textLayer.style.setProperty('--scale-factor', scale);
            textLayer.style.width = Math.floor(viewport.width) + 'px';
            textLayer.style.height = Math.floor(viewport.height) + 'px';

            canvas.parentElement.appendChild(textLayer);

            // Render text layer with PDF.js
            await pdfjsLib.renderTextLayer({
                textContentSource: textContent,
                container: textLayer,
                viewport: viewport
            }).promise;

        } catch (textError) {
            console.warn('Text layer error on page', pageNum, textError);
        }

    } catch (error) {
        console.error('Error rendering page', pageNum, error);
        canvas.width = 600;
        canvas.height = 800;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#f8d7da';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#721c24';
        ctx.font = '16px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(`Fehler beim Laden von Seite ${pageNum}`, canvas.width/2, canvas.height/2);
    }
}

// Scroll to page
function scrollToPage(pageNum) {
    const pageDiv = document.querySelector(`.pdf-page[data-page="${pageNum}"]`);
    if (pageDiv) {
        pageDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
}

// Update current page on scroll
document.getElementById('pdfCanvasContainer').addEventListener('scroll', function() {
    const pages = document.querySelectorAll('.pdf-page');
    const containerRect = this.getBoundingClientRect();

    for (const page of pages) {
        const pageRect = page.getBoundingClientRect();
        if (pageRect.top <= containerRect.top + 100 && pageRect.bottom > containerRect.top + 100) {
            currentPage = parseInt(page.dataset.page);
            document.getElementById('currentPage').textContent = currentPage;
            document.getElementById('notePageRef').textContent = currentPage;
            break;
        }
    }
});

// Navigation
document.getElementById('prevPage').addEventListener('click', () => {
    if (currentPage > 1) {
        scrollToPage(currentPage - 1);
    }
});

document.getElementById('nextPage').addEventListener('click', () => {
    if (currentPage < totalPages) {
        scrollToPage(currentPage + 1);
    }
});

// Zoom with debounce
let zoomTimeout = null;
function handleZoom(newScale) {
    scale = newScale;
    document.getElementById('zoomLevel').textContent = Math.round(scale * 100) + '%';

    // Debounce re-render
    if (zoomTimeout) clearTimeout(zoomTimeout);
    zoomTimeout = setTimeout(() => {
        renderAllPages();
    }, 300);
}

document.getElementById('zoomIn').addEventListener('click', () => {
    handleZoom(Math.min(scale + 0.25, 3));
});

document.getElementById('zoomOut').addEventListener('click', () => {
    handleZoom(Math.max(scale - 0.25, 0.5));
});

// Notes Panel
const notesPanel = document.getElementById('notesPanel');
document.getElementById('toggleNotes').addEventListener('click', () => {
    notesPanel.classList.toggle('open');
    if (notesPanel.classList.contains('open')) {
        loadNotes();
    }
});
document.getElementById('closeNotes').addEventListener('click', () => {
    notesPanel.classList.remove('open');
});

// Load Notes
async function loadNotes() {
    try {
        const response = await fetch(`/learnloom/api/notes/${bookId}/`);
        const data = await response.json();

        if (data.success) {
            const notesList = document.getElementById('notesList');
            if (data.notes.length === 0) {
                notesList.innerHTML = '<p class="text-muted text-center">Noch keine Notizen</p>';
            } else {
                notesList.innerHTML = data.notes.map(note => `
                    <div class="note-item" data-note-id="${note.id}">
                        <div class="note-content">${note.content}</div>
                        <div class="note-meta d-flex justify-content-between">
                            <span>${note.page_reference ? 'Seite ' + note.page_reference : ''}</span>
                            <button class="btn btn-sm btn-link text-danger p-0" onclick="deleteNote('${note.id}')">
                                <i class="bi bi-trash"></i>
                            </button>
                        </div>
                    </div>
                `).join('');
            }
        }
    } catch (error) {
        console.error('Error loading notes:', error);
    }
}

// Save Note
document.getElementById('saveNote').addEventListener('click', async () => {
    const content = document.getElementById('newNoteContent').value.trim();
    if (!content) return;

    try {
        const response = await fetch(`/learnloom/api/notes/${bookId}/save/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken
            },
            body: JSON.stringify({
                content: content,
                page_reference: currentPage
            })
        });

        const data = await response.json();
        if (data.success) {
            document.getElementById('newNoteContent').value = '';
            loadNotes();
        }
    } catch (error) {
        console.error('Error saving note:', error);
    }
});

// Delete Note
async function deleteNote(noteId) {
    if (!confirm('Notiz löschen?')) return;

    try {
        const response = await fetch(`/learnloom/api/notes/${noteId}/delete/`, {
            method: 'POST',
            headers: { 'X-CSRFToken': csrfToken }
        });

        const data = await response.json();
        if (data.success) {
            loadNotes();
        }
    } catch (error) {
        console.error('Error deleting note:', error);
    }
}

// Text Selection & Translation
const translateBtn = document.getElementById('translateBtn');
const translationPopup = document.getElementById('translationPopup');
const originalInput = document.getElementById('popupOriginalInput');
const translationDiv = document.getElementById('popupTranslation');
let selectedText = '';
let selectionPosition = {};
let currentTranslation = '';

// Hide translate button on click elsewhere
document.addEventListener('mousedown', (e) => {
    if (!translateBtn.contains(e.target) && !translationPopup.contains(e.target)) {
        // Don't hide immediately - wait to see if it's a selection
    }
});

document.addEventListener('mouseup', (e) => {
    // Ignore clicks inside the popup or on the translate button
    if (translationPopup.contains(e.target) || translateBtn.contains(e.target)) return;

    // Small delay to let selection complete
    setTimeout(() => {
        const selection = window.getSelection();
        const text = selection.toString().trim();

        if (text.length > 0 && text.length < 500) {
            selectedText = text;
            selectionPosition = { x: e.clientX, y: e.clientY };

            // Show translate button near the selection
            const btnX = Math.min(e.clientX, window.innerWidth - 150);
            const btnY = Math.max(e.clientY - 50, 10);
            translateBtn.style.left = btnX + 'px';
            translateBtn.style.top = btnY + 'px';
            translateBtn.classList.remove('d-none');
        } else {
            translateBtn.classList.add('d-none');
        }
    }, 10);
});

// Translate Button Click - Open popup with selected text
translateBtn.addEventListener('click', () => {
    translateBtn.classList.add('d-none');

    // Position popup
    const popupX = Math.min(selectionPosition.x, window.innerWidth - 320);
    const popupY = Math.min(selectionPosition.y, window.innerHeight - 250);
    translationPopup.style.left = popupX + 'px';
    translationPopup.style.top = popupY + 'px';
    translationPopup.classList.remove('d-none');

    // Set input value and reset translation
    originalInput.value = selectedText;
    translationDiv.innerHTML = '<span class="text-muted">Klicke auf "Übersetzen"</span>';
    currentTranslation = '';

    // Focus input for easy editing
    originalInput.focus();
    originalInput.select();
});

// Translate function
async function translateText() {
    const textToTranslate = originalInput.value.trim();
    if (!textToTranslate) {
        translationDiv.innerHTML = '<span class="text-danger">Bitte Text eingeben</span>';
        return;
    }

    translationDiv.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>Übersetze...';

    try {
        const response = await fetch('/learnloom/api/translate/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken
            },
            body: JSON.stringify({
                text: textToTranslate,
                source_lang: 'en',
                target_lang: 'de'
            })
        });

        const data = await response.json();
        if (data.success) {
            currentTranslation = data.translation;
            translationDiv.textContent = data.translation;
        } else {
            translationDiv.innerHTML = '<span class="text-danger">Fehler: ' + data.error + '</span>';
            currentTranslation = '';
        }
    } catch (error) {
        translationDiv.innerHTML = '<span class="text-danger">Übersetzungsfehler</span>';
        currentTranslation = '';
    }
}

// Retranslate button
document.getElementById('retranslateBtn').addEventListener('click', translateText);

// Enter key in input triggers translation
originalInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
        e.preventDefault();
        translateText();
    }
});

// Close Popup
document.getElementById('closePopup').addEventListener('click', () => {
    translationPopup.classList.add('d-none');
    currentTranslation = '';
});

// ============================================
// Rectangle Selection Mode
// ============================================
let selectMode = false;
let isDrawing = false;
let startX, startY;
const selectionRect = document.getElementById('selectionRect');
const selectModeHint = document.getElementById('selectModeHint');
const pdfContainer = document.getElementById('pdfCanvasContainer');

// Store page text content for extraction
const pageTextContents = {};

// Toggle selection mode
document.getElementById('toggleSelectMode').addEventListener('click', () => {
    selectMode = !selectMode;

    if (selectMode) {
        document.body.classList.add('select-mode-active');
        selectModeHint.classList.remove('d-none');
        console.log('Selection mode ON');
    } else {
        exitSelectMode();
    }
});

function exitSelectMode() {
    selectMode = false;
    isDrawing = false;
    document.body.classList.remove('select-mode-active');
    selectionRect.style.display = 'none';
    selectModeHint.classList.add('d-none');
    console.log('Selection mode OFF');
}

// ESC to exit selection mode
document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && selectMode) {
        exitSelectMode();
    }
});

// Drawing rectangle on PDF container
pdfContainer.addEventListener('mousedown', (e) => {
    if (!selectMode) return;
    e.preventDefault();

    isDrawing = true;
    startX = e.clientX;
    startY = e.clientY;

    selectionRect.style.left = startX + 'px';
    selectionRect.style.top = startY + 'px';
    selectionRect.style.width = '0';
    selectionRect.style.height = '0';
    selectionRect.style.display = 'block';

    console.log('Drawing started at', startX, startY);
});

document.addEventListener('mousemove', (e) => {
    if (!isDrawing || !selectMode) return;

    const currentX = e.clientX;
    const currentY = e.clientY;

    const width = Math.abs(currentX - startX);
    const height = Math.abs(currentY - startY);
    const left = Math.min(currentX, startX);
    const top = Math.min(currentY, startY);

    selectionRect.style.left = left + 'px';
    selectionRect.style.top = top + 'px';
    selectionRect.style.width = width + 'px';
    selectionRect.style.height = height + 'px';
});

document.addEventListener('mouseup', async (e) => {
    if (!isDrawing || !selectMode) return;
    isDrawing = false;

    const rect = {
        left: parseInt(selectionRect.style.left),
        top: parseInt(selectionRect.style.top),
        width: parseInt(selectionRect.style.width),
        height: parseInt(selectionRect.style.height)
    };

    console.log('Selection rectangle:', rect);

    // Minimum size check
    if (rect.width < 5 || rect.height < 5) {
        selectionRect.style.display = 'none';
        console.log('Rectangle too small');
        return;
    }

    // Extract text from the selected region
    try {
        const extractedText = await extractTextFromRegion(rect);
        console.log('Extracted text:', extractedText);

        // Exit select mode
        exitSelectMode();

        if (extractedText && extractedText.trim()) {
            openTranslationPopup(extractedText, rect.left + rect.width/2, rect.top + rect.height);
        } else {
            // Show popup with empty input for manual entry
            openTranslationPopup('', rect.left + rect.width/2, rect.top + rect.height);
            alert('Kein Text gefunden. Bitte manuell eingeben.');
        }
    } catch (error) {
        console.error('Error extracting text:', error);
        exitSelectMode();
        alert('Fehler bei der Textextraktion: ' + error.message);
    }
});

// Extract text from PDF region - find the SINGLE word closest to selection center
async function extractTextFromRegion(screenRect) {
    console.log('Extracting from screen rect:', screenRect);

    // Calculate center of selection rectangle
    const selCenterX = screenRect.left + screenRect.width / 2;
    const selCenterY = screenRect.top + screenRect.height / 2;

    console.log('Selection center:', selCenterX, selCenterY);

    // Find all text layer spans
    const allSpans = document.querySelectorAll('.textLayer span');
    let candidates = [];

    allSpans.forEach(span => {
        const text = span.textContent;
        if (!text || text.trim().length === 0) return;

        const spanRect = span.getBoundingClientRect();

        // Check if selection center is inside this span (with small margin)
        const margin = 5;
        const insideX = selCenterX >= spanRect.left - margin && selCenterX <= spanRect.right + margin;
        const insideY = selCenterY >= spanRect.top - margin && selCenterY <= spanRect.bottom + margin;

        if (insideX && insideY) {
            // Calculate distance from selection center to span center
            const spanCenterX = spanRect.left + spanRect.width / 2;
            const spanCenterY = spanRect.top + spanRect.height / 2;
            const distance = Math.sqrt(
                Math.pow(selCenterX - spanCenterX, 2) +
                Math.pow(selCenterY - spanCenterY, 2)
            );

            candidates.push({
                text: text.trim(),
                distance: distance,
                rect: spanRect
            });
        }
    });

    console.log('Candidates found:', candidates.length);

    // If we found candidates, pick the closest one
    if (candidates.length > 0) {
        candidates.sort((a, b) => a.distance - b.distance);
        const best = candidates[0];
        console.log('Best match:', best.text, 'distance:', best.distance);

        // If the span contains multiple words, try to extract just the word at cursor
        const words = best.text.split(/\s+/).filter(w => w.length > 0);
        if (words.length === 1) {
            return words[0];
        }

        // Multiple words in span - estimate which word the cursor is over
        const spanRect = best.rect;
        const relativeX = (selCenterX - spanRect.left) / spanRect.width;
        const wordIndex = Math.floor(relativeX * words.length);
        const clampedIndex = Math.max(0, Math.min(wordIndex, words.length - 1));

        console.log('Multiple words, picking index', clampedIndex, 'from', words);
        return words[clampedIndex];
    }

    // Fallback: find the closest span to selection center
    console.log('No direct hit, finding closest span...');
    let closest = null;
    let closestDistance = Infinity;

    allSpans.forEach(span => {
        const text = span.textContent;
        if (!text || text.trim().length === 0) return;

        const spanRect = span.getBoundingClientRect();
        const spanCenterX = spanRect.left + spanRect.width / 2;
        const spanCenterY = spanRect.top + spanRect.height / 2;
        const distance = Math.sqrt(
            Math.pow(selCenterX - spanCenterX, 2) +
            Math.pow(selCenterY - spanCenterY, 2)
        );

        // Only consider spans within reasonable distance (100px)
        if (distance < closestDistance && distance < 100) {
            closestDistance = distance;
            closest = { text: text.trim(), rect: spanRect };
        }
    });

    if (closest) {
        console.log('Closest span:', closest.text);
        // Extract single word if multiple words
        const words = closest.text.split(/\s+/).filter(w => w.length > 0);
        if (words.length === 1) {
            return words[0];
        }
        // Pick word closest to center
        const relativeX = (selCenterX - closest.rect.left) / closest.rect.width;
        const wordIndex = Math.floor(relativeX * words.length);
        const clampedIndex = Math.max(0, Math.min(wordIndex, words.length - 1));
        return words[clampedIndex];
    }

    return '';
}

// Open translation popup with text
function openTranslationPopup(text, x, y) {
    translationPopup.style.left = Math.min(x, window.innerWidth - 320) + 'px';
    translationPopup.style.top = Math.min(y + 10, window.innerHeight - 250) + 'px';
    translationPopup.style.transform = '';
    translationPopup.classList.remove('d-none');

    originalInput.value = text;
    translationDiv.innerHTML = '<span class="text-muted">Klicke auf "Übersetzen"</span>';
    currentTranslation = '';
    originalInput.focus();
    originalInput.select();
}

// Reset transform when closing popup
document.getElementById('closePopup').addEventListener('click', () => {
    translationPopup.style.transform = '';
});

// Save Highlight
document.getElementById('saveHighlight').addEventListener('click', async () => {
    const original = originalInput.value.trim();
    const translation = currentTranslation;

    if (!original || !translation) {
        alert('Bitte zuerst übersetzen');
        return;
    }

    try {
        const response = await fetch(`/learnloom/api/highlights/${bookId}/save/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken
            },
            body: JSON.stringify({
                original_text: original,
                translated_text: translation,
                page_number: currentPage,
                position_data: selectionPosition,
                add_to_vocabulary: true
            })
        });

        const data = await response.json();
        if (data.success) {
            translationPopup.classList.add('d-none');
            // Add to local highlights array and render
            highlights.push({
                id: data.highlight.id,
                original_text: original,
                translated_text: translation,
                page_number: currentPage,
                position_data: selectionPosition
            });
            // Re-render highlights for current page
            renderHighlightsForPage(currentPage);
        }
    } catch (error) {
        console.error('Error saving highlight:', error);
    }
});

// Render highlights for a specific page
function renderHighlightsForPage(pageNum) {
    const pageDiv = document.querySelector(`.pdf-page[data-page="${pageNum}"]`);
    if (!pageDiv) return;

    const textLayer = pageDiv.querySelector('.textLayer');
    if (!textLayer) return;

    // Remove existing highlight overlays
    pageDiv.querySelectorAll('.highlight-overlay').forEach(el => el.remove());

    // Get highlights for this page
    const pageHighlights = highlights.filter(h => h.page_number === pageNum);

    pageHighlights.forEach(highlight => {
        const searchText = highlight.original_text.toLowerCase().trim();
        const spans = textLayer.querySelectorAll('span');

        // Find span that contains this word and calculate exact position
        for (const span of spans) {
            const spanText = span.textContent;
            const spanTextLower = spanText.toLowerCase();
            const wordIndex = spanTextLower.indexOf(searchText);

            if (wordIndex !== -1) {
                // Found the word in this span - calculate exact position
                createWordHighlight(span, wordIndex, searchText.length, highlight, pageDiv);
                break; // Only highlight first occurrence
            }
        }
    });
}

// Create highlight for a specific word within a span
function createWordHighlight(span, charIndex, charLength, highlight, pageDiv) {
    const spanRect = span.getBoundingClientRect();
    const pageRect = pageDiv.getBoundingClientRect();
    const spanText = span.textContent;

    // Calculate relative position within span
    const textBefore = spanText.substring(0, charIndex);
    const targetText = spanText.substring(charIndex, charIndex + charLength);

    // Estimate character width (average)
    const avgCharWidth = spanRect.width / spanText.length;

    // Calculate word position and size
    const wordLeft = spanRect.left - pageRect.left + (textBefore.length * avgCharWidth);
    const wordWidth = targetText.length * avgCharWidth;
    const wordTop = spanRect.top - pageRect.top;
    const wordHeight = spanRect.height;

    // Create highlight overlay
    const overlay = document.createElement('div');
    overlay.className = 'highlight-overlay';
    overlay.style.left = wordLeft + 'px';
    overlay.style.top = wordTop + 'px';
    overlay.style.width = wordWidth + 'px';
    overlay.style.height = wordHeight + 'px';

    overlay.dataset.highlightId = highlight.id;
    overlay.title = `${highlight.original_text} → ${highlight.translated_text}`;

    // Add hover tooltip
    overlay.addEventListener('mouseenter', (e) => {
        showHighlightTooltip(e, highlight);
    });
    overlay.addEventListener('mouseleave', hideHighlightTooltip);

    pageDiv.appendChild(overlay);
}

// Tooltip for highlights
let highlightTooltip = null;

function showHighlightTooltip(e, highlight) {
    if (!highlightTooltip) {
        highlightTooltip = document.createElement('div');
        highlightTooltip.className = 'highlight-tooltip-popup';
        highlightTooltip.style.cssText = `
            position: fixed;
            background: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 13px;
            z-index: 2500;
            max-width: 300px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        `;
        document.body.appendChild(highlightTooltip);
    }

    highlightTooltip.innerHTML = `
        <div style="font-weight: 500; margin-bottom: 4px;">${highlight.original_text}</div>
        <div style="color: #74b9ff;">→ ${highlight.translated_text}</div>
    `;
    highlightTooltip.style.left = e.clientX + 10 + 'px';
    highlightTooltip.style.top = e.clientY + 10 + 'px';
    highlightTooltip.style.display = 'block';
}

function hideHighlightTooltip() {
    if (highlightTooltip) {
        highlightTooltip.style.display = 'none';
    }
}

// Render all highlights after pages are loaded
function renderAllHighlights() {
    for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
        renderHighlightsForPage(pageNum);
    }
}

// Text-to-Speech
function speak(text, lang) {
    const utterance = new SpeechSynthesisUtterance(text);
    utterance.lang = lang === 'en' ? 'en-US' : 'de-DE';
    utterance.rate = 0.9;
    window.speechSynthesis.speak(utterance);
}

document.getElementById('speakOriginal').addEventListener('click', () => {
    const text = originalInput.value.trim();
    if (text) speak(text, 'en');
});

document.getElementById('speakTranslation').addEventListener('click', () => {
    if (currentTranslation) {
        speak(currentTranslation, 'de');
    }
});

// Save progress on page unload
window.addEventListener('beforeunload', () => {
    fetch(`/learnloom/api/progress/${bookId}/save/`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrfToken
        },
        body: JSON.stringify({
            current_page: currentPage,
            zoom_level: scale
        }),
        keepalive: true
    });
});

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
    // Ignore if typing in textarea
    if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT') return;

    if (e.key === 'ArrowLeft') {
        document.getElementById('prevPage').click();
    } else if (e.key === 'ArrowRight') {
        document.getElementById('nextPage').click();
    } else if (e.key === '+' || e.key === '=') {
        document.getElementById('zoomIn').click();
    } else if (e.key === '-') {
        document.getElementById('zoomOut').click();
    } else if (e.key === 'Escape') {
        translationPopup.classList.add('d-none');
        translateBtn.classList.add('d-none');
        notesPanel.classList.remove('open');
    }
});

// Initialize
document.getElementById('zoomLevel').textContent = Math.round(scale * 100) + '%';
loadPDF();
</script>
{% endblock %}
