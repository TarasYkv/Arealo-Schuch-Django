{% extends 'base.html' %}
{% load static %}

{% block title %}{{ book.title }} - LearnLoom{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="{% static 'learnloom/css/learnloom.css' %}?v={% now 'U' %}">
<style>
    body { overflow: hidden; }
    .navbar, footer { display: none !important; }

    /* Loading Overlay */
    .loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(82, 86, 89, 0.95);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 3000;
    }
    .loading-spinner {
        width: 60px;
        height: 60px;
        border: 4px solid rgba(255,255,255,0.3);
        border-top: 4px solid #fff;
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    .loading-text {
        color: white;
        margin-top: 20px;
        font-size: 1.1rem;
    }
    .loading-progress {
        color: rgba(255,255,255,0.7);
        margin-top: 10px;
        font-size: 0.9rem;
    }

    /* Proper Text Layer Styling - PDF.js official */
    .pdf-page {
        position: relative;
        margin-bottom: 20px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        line-height: 0; /* Remove extra space below canvas */
    }
    .pdf-page canvas {
        display: block;
        margin: 0;
        padding: 0;
    }
    /* Text Layer for PDF.js 3.x */
    .textLayer {
        position: absolute;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        overflow: hidden;
        line-height: 1.0;
        -webkit-text-size-adjust: none;
        -moz-text-size-adjust: none;
        text-size-adjust: none;
        forced-color-adjust: none;
        transform-origin: 0 0;
        z-index: 2;
    }
    .textLayer > span {
        color: transparent;
        position: absolute;
        white-space: pre;
        cursor: text;
        transform-origin: 0% 0%;
    }
    .textLayer ::selection {
        background: rgba(0, 100, 255, 0.4);
    }

    /* Highlight Overlay - Translation (Yellow) */
    .highlight-overlay {
        position: absolute;
        background-color: rgba(255, 235, 59, 0.4);
        pointer-events: auto;
        cursor: pointer;
        z-index: 3;
        border-radius: 2px;
    }
    .highlight-overlay:hover {
        background-color: rgba(255, 235, 59, 0.6);
    }

    /* Explanation Overlay (Green) */
    .explanation-overlay {
        position: absolute;
        background-color: rgba(74, 222, 128, 0.4);
        pointer-events: auto;
        cursor: pointer;
        z-index: 3;
        border-radius: 2px;
    }
    .explanation-overlay:hover {
        background-color: rgba(74, 222, 128, 0.6);
    }

    /* Floating Action Buttons */
    .floating-action-btns {
        position: fixed;
        z-index: 1000;
        display: flex;
        gap: 8px;
    }
    .action-btn-floating {
        padding: 8px 16px;
        border-radius: 20px;
        border: none;
        font-size: 0.9rem;
        font-weight: 500;
        cursor: pointer;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        transition: all 0.2s ease;
    }
    .action-btn-floating:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.25);
    }
    .btn-translate {
        background: linear-gradient(135deg, #3b82f6, #2563eb);
        color: white;
    }
    .btn-explain {
        background: linear-gradient(135deg, #22c55e, #16a34a);
        color: white;
    }

    /* Explanation Popup - Advanced */
    .explanation-popup {
        position: fixed;
        z-index: 2000;
        background: white;
        border-radius: 12px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        width: 420px;
        max-height: 80vh;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        transition: all 0.3s ease;
    }
    .explanation-popup.fullscreen {
        width: 90vw !important;
        height: 90vh !important;
        max-height: 90vh !important;
        top: 5vh !important;
        left: 5vw !important;
        border-radius: 16px;
    }
    .explanation-popup-header {
        background: linear-gradient(135deg, #22c55e, #16a34a);
        color: white;
        padding: 12px 16px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: move;
        user-select: none;
    }
    .explanation-popup-header span {
        font-weight: 600;
        font-size: 1rem;
    }
    .explanation-popup-controls {
        display: flex;
        gap: 8px;
    }
    .btn-popup-control {
        background: rgba(255, 255, 255, 0.2);
        border: none;
        color: white;
        width: 28px;
        height: 28px;
        border-radius: 6px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background 0.2s;
    }
    .btn-popup-control:hover {
        background: rgba(255, 255, 255, 0.3);
    }
    .explanation-popup-body {
        flex: 1;
        overflow-y: auto;
        padding: 16px;
        display: flex;
        flex-direction: column;
        gap: 12px;
    }
    .explanation-selected-text-container {
        flex-shrink: 0;
    }
    .explanation-selected-text {
        background: #f0fdf4;
        border: 1px solid #bbf7d0;
        border-radius: 8px;
        padding: 10px;
        font-size: 0.9rem;
        max-height: 80px;
        overflow-y: auto;
        margin-top: 4px;
    }
    .explanation-chat-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        min-height: 150px;
        max-height: 350px;
        overflow-y: auto;
        gap: 10px;
        padding: 4px;
    }
    .explanation-popup.fullscreen .explanation-chat-container {
        max-height: none;
        flex: 1;
    }
    .chat-message {
        padding: 10px 14px;
        border-radius: 12px;
        font-size: 0.9rem;
        line-height: 1.5;
        max-width: 95%;
        word-wrap: break-word;
    }
    .chat-message.user {
        background: #dbeafe;
        color: #1e40af;
        align-self: flex-end;
        border-bottom-right-radius: 4px;
    }
    .chat-message.assistant {
        background: #f0fdf4;
        color: #166534;
        align-self: flex-start;
        border-bottom-left-radius: 4px;
    }
    .explanation-input-section {
        border-top: 1px solid #e5e7eb;
        padding-top: 12px;
        flex-shrink: 0;
    }
    .explanation-input-container {
        display: flex;
        gap: 8px;
    }
    .explanation-input-container input {
        flex: 1;
        border-radius: 20px;
        padding: 8px 16px;
        border: 1px solid #d1d5db;
        font-size: 0.9rem;
    }
    .explanation-input-container input:focus {
        outline: none;
        border-color: #22c55e;
        box-shadow: 0 0 0 3px rgba(34, 197, 94, 0.1);
    }
    .explanation-input-container button {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        padding: 0;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    .explanation-popup-footer {
        padding: 12px 16px;
        border-top: 1px solid #e5e7eb;
        display: flex;
        gap: 8px;
        background: #fafafa;
    }

    /* Selection Mode */
    .select-mode-active .pdf-canvas-container {
        cursor: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32'%3E%3Cline x1='16' y1='0' x2='16' y2='32' stroke='%23f39c12' stroke-width='2'/%3E%3Cline x1='0' y1='16' x2='32' y2='16' stroke='%23f39c12' stroke-width='2'/%3E%3Ccircle cx='16' cy='16' r='6' fill='none' stroke='%23f39c12' stroke-width='2'/%3E%3C/svg%3E") 16 16, crosshair !important;
    }
    .select-mode-active .pdf-canvas-container * {
        cursor: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32'%3E%3Cline x1='16' y1='0' x2='16' y2='32' stroke='%23f39c12' stroke-width='2'/%3E%3Cline x1='0' y1='16' x2='32' y2='16' stroke='%23f39c12' stroke-width='2'/%3E%3Ccircle cx='16' cy='16' r='6' fill='none' stroke='%23f39c12' stroke-width='2'/%3E%3C/svg%3E") 16 16, crosshair !important;
        user-select: none !important;
    }
    .selection-rect {
        position: fixed;
        border: 3px solid #f39c12;
        background: rgba(243, 156, 18, 0.25);
        pointer-events: none;
        z-index: 2000;
        display: none;
        box-shadow: 0 0 0 3px rgba(243, 156, 18, 0.4), inset 0 0 10px rgba(243, 156, 18, 0.2);
    }
    .select-mode-active .pdf-toolbar #toggleSelectMode {
        background: #0984e3 !important;
        color: white !important;
        border-color: #0984e3 !important;
    }
    .select-mode-hint {
        position: fixed;
        top: 70px;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(135deg, #0984e3, #6c5ce7);
        color: white;
        padding: 12px 24px;
        border-radius: 30px;
        font-size: 14px;
        font-weight: 500;
        z-index: 2100;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    }

    /* Marker Mode */
    .marker-mode-active .pdf-canvas-container {
        cursor: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24'%3E%3Cpath fill='%23e74c3c' d='M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z'/%3E%3C/svg%3E") 12 24, pointer !important;
    }
    .marker-mode-active .pdf-canvas-container * {
        cursor: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24'%3E%3Cpath fill='%23e74c3c' d='M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z'/%3E%3C/svg%3E") 12 24, pointer !important;
        user-select: none !important;
    }
    .marker-mode-active .pdf-toolbar #toggleMarkerMode {
        background: #e74c3c !important;
        color: white !important;
        border-color: #e74c3c !important;
    }
    .marker-mode-hint {
        position: fixed;
        top: 70px;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(135deg, #e74c3c, #c0392b);
        color: white;
        padding: 12px 24px;
        border-radius: 30px;
        font-size: 14px;
        font-weight: 500;
        z-index: 2100;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    }

    /* Note Markers on PDF */
    .note-marker {
        position: absolute;
        width: 24px;
        height: 24px;
        cursor: pointer;
        z-index: 10;
        filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
        transition: transform 0.2s;
    }
    .note-marker:hover {
        transform: scale(1.2);
    }
    .note-marker svg {
        width: 100%;
        height: 100%;
    }

    /* Modern Confirmation Modal */
    .confirm-modal-backdrop {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(4px);
        z-index: 9999;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        visibility: hidden;
        transition: all 0.2s ease;
    }
    .confirm-modal-backdrop.show {
        opacity: 1;
        visibility: visible;
    }
    .confirm-modal {
        background: white;
        border-radius: 16px;
        padding: 24px;
        max-width: 380px;
        width: 90%;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        transform: scale(0.9) translateY(20px);
        transition: all 0.2s ease;
    }
    .confirm-modal-backdrop.show .confirm-modal {
        transform: scale(1) translateY(0);
    }
    .confirm-modal-icon {
        width: 64px;
        height: 64px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 0 auto 16px;
        font-size: 28px;
    }
    .confirm-modal-icon.danger {
        background: #fee2e2;
        color: #dc2626;
    }
    .confirm-modal-icon.warning {
        background: #fef3c7;
        color: #d97706;
    }
    .confirm-modal-icon.info {
        background: #dbeafe;
        color: #2563eb;
    }
    .confirm-modal-title {
        font-size: 1.25rem;
        font-weight: 600;
        text-align: center;
        margin-bottom: 8px;
        color: #1f2937;
    }
    .confirm-modal-message {
        text-align: center;
        color: #6b7280;
        margin-bottom: 24px;
        line-height: 1.5;
    }
    .confirm-modal-buttons {
        display: flex;
        gap: 12px;
    }
    .confirm-modal-buttons button {
        flex: 1;
        padding: 12px 20px;
        border-radius: 10px;
        font-weight: 500;
        font-size: 0.95rem;
        cursor: pointer;
        transition: all 0.15s ease;
        border: none;
    }
    .confirm-modal-buttons .btn-cancel {
        background: #f3f4f6;
        color: #4b5563;
    }
    .confirm-modal-buttons .btn-cancel:hover {
        background: #e5e7eb;
    }
    .confirm-modal-buttons .btn-confirm {
        background: #dc2626;
        color: white;
    }
    .confirm-modal-buttons .btn-confirm:hover {
        background: #b91c1c;
    }
    .confirm-modal-buttons .btn-confirm.warning {
        background: #d97706;
    }
    .confirm-modal-buttons .btn-confirm.warning:hover {
        background: #b45309;
    }
    .confirm-modal-buttons .btn-confirm.info {
        background: #2563eb;
    }
    .confirm-modal-buttons .btn-confirm.info:hover {
        background: #1d4ed8;
    }

    /* Summary Panel (Right Side) */
    .summary-panel {
        position: fixed;
        top: 0;
        right: 0;
        width: 380px;
        height: 100vh;
        background: white;
        box-shadow: -4px 0 20px rgba(0,0,0,0.15);
        z-index: 1100;
        display: flex;
        flex-direction: column;
        transform: translateX(100%);
        transition: transform 0.3s ease;
    }
    .summary-panel.open {
        transform: translateX(0);
    }
    .summary-panel-header {
        background: linear-gradient(135deg, #3b82f6, #1d4ed8);
        color: white;
        padding: 15px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-shrink: 0;
    }
    .summary-panel-body {
        flex: 1;
        overflow-y: auto;
        padding: 16px;
    }
    .summary-loading {
        text-align: center;
        padding: 40px 20px;
        color: #6b7280;
    }
    .summary-text {
        line-height: 1.7;
        color: #374151;
        font-size: 0.95rem;
    }
    .summary-section {
        background: #f9fafb;
        border-radius: 8px;
        padding: 12px;
        margin-bottom: 12px;
        border-left: 3px solid #3b82f6;
        cursor: pointer;
        transition: all 0.2s;
    }
    .summary-section:hover {
        background: #f0f9ff;
        transform: translateX(2px);
    }
    .summary-section-title {
        font-weight: 600;
        color: #1f2937;
        margin-bottom: 6px;
    }
    .summary-section-pages {
        font-size: 0.8rem;
        color: #3b82f6;
        margin-bottom: 6px;
    }
    .summary-section-text {
        font-size: 0.9rem;
        color: #4b5563;
        line-height: 1.6;
        margin-top: 8px;
        padding: 10px;
        background: #f8fafc;
        border-radius: 6px;
        border-left: 3px solid #3b82f6;
    }
    .summary-section-actions {
        display: flex;
        align-items: center;
        gap: 8px;
    }
    .summarizing-spinner {
        font-size: 0.85rem;
        color: #6b7280;
    }
    .summary-generate-btn {
        width: 100%;
        padding: 12px;
        margin-top: 16px;
    }

    /* Docked Explanation Panel */
    .explanation-popup.docked {
        position: fixed !important;
        top: 0 !important;
        right: 0 !important;
        left: auto !important;
        width: 400px !important;
        height: 100vh !important;
        max-height: 100vh !important;
        border-radius: 0 !important;
        box-shadow: -4px 0 20px rgba(0,0,0,0.15) !important;
        transform: none !important;
    }
    .explanation-popup.docked .explanation-popup-body {
        flex: 1;
        max-height: none;
    }
    .explanation-popup.docked .explanation-chat-container {
        max-height: none;
        flex: 1;
    }

    /* Adjust PDF container when panels are open */
    .pdf-canvas-container.panel-open {
        margin-right: 380px !important;
        padding-left: 85px !important; /* 75 toolbar + 10 gap */
        padding-right: 10px !important; /* 10px gap zum Panel */
        transition: all 0.3s ease;
    }
</style>
{% endblock %}

{% block content %}
<!-- Loading Overlay -->
<div class="loading-overlay" id="loadingOverlay">
    <div class="loading-spinner"></div>
    <div class="loading-text">PDF wird geladen...</div>
    <div class="loading-progress" id="loadingProgress"></div>
</div>

<!-- Back Button -->
<a href="{% url 'learnloom:index' %}" class="btn btn-light position-fixed" style="top: 15px; left: 15px; z-index: 1200;">
    <i class="bi bi-arrow-left me-2"></i>Zurück
</a>

<!-- PDF Viewer Container -->
<div class="pdf-viewer-container" id="pdfViewerContainer">
    <div class="pdf-canvas-container" id="pdfCanvasContainer">
        <!-- Pages will be rendered here -->
    </div>
</div>

<!-- Floating Toolbar - Vertical Left -->
<div class="pdf-toolbar">
    <button class="btn btn-outline-secondary" id="prevPage" title="Vorherige Seite">
        <i class="bi bi-chevron-up"></i>
    </button>
    <span class="page-info">
        <span id="currentPage">1</span>/<span id="totalPages">-</span>
    </span>
    <button class="btn btn-outline-secondary" id="nextPage" title="Nächste Seite">
        <i class="bi bi-chevron-down"></i>
    </button>

    <div class="divider"></div>

    <button class="btn btn-outline-secondary" id="zoomOut" title="Verkleinern">
        <i class="bi bi-zoom-out"></i>
    </button>
    <input type="text" class="zoom-input" id="zoomLevel" value="100%" title="Zoom eingeben (z.B. 150)">
    <button class="btn btn-outline-secondary" id="zoomIn" title="Vergrößern">
        <i class="bi bi-zoom-in"></i>
    </button>

    <div class="divider"></div>

    <button class="btn btn-outline-dark" id="toggleFullscreen" title="Vollbild">
        <i class="bi bi-fullscreen"></i>
    </button>
    <button class="btn btn-outline-primary" id="toggleNotes" title="Notizen">
        <i class="bi bi-sticky"></i>
    </button>
    <button class="btn btn-outline-warning" id="toggleMarkerMode" title="Notiz-Marker setzen">
        <i class="bi bi-pin-map"></i>
    </button>
    <button class="btn btn-info" id="toggleSelectMode" title="Rechteck-Auswahl (Bereich markieren)">
        <i class="bi bi-bounding-box"></i>
    </button>

    <div class="divider"></div>

    <button class="btn btn-outline-warning" id="toggleReadingList" title="Leseliste">
        <i class="bi bi-list-check"></i>
    </button>
    <button class="btn btn-outline-info" id="toggleSummaryPanel" title="Zusammenfassung">
        <i class="bi bi-file-text"></i>
    </button>
</div>

<!-- Selection Rectangle (drawn directly on PDF container) -->
<div id="selectionRect" class="selection-rect"></div>

<!-- Selection Mode Hint -->
<div id="selectModeHint" class="select-mode-hint d-none">
    <i class="bi bi-bounding-box me-2"></i>Ziehe ein Rechteck um das Wort. ESC zum Abbrechen.
</div>

<!-- Marker Mode Hint -->
<div id="markerModeHint" class="marker-mode-hint d-none">
    <i class="bi bi-pin-map me-2"></i>Klicke auf die PDF um einen Marker zu setzen. ESC zum Abbrechen.
</div>

<!-- Notes Panel -->
<div class="notes-panel" id="notesPanel">
    <div class="notes-panel-header">
        <h5 class="mb-0"><i class="bi bi-sticky me-2"></i>Notizen</h5>
        <button class="btn btn-close" id="closeNotes"></button>
    </div>
    <div class="notes-panel-body" id="notesList">
        <!-- Notes will be loaded here -->
    </div>
    <div class="notes-panel-footer">
        <textarea class="form-control mb-2" id="newNoteContent" rows="3" placeholder="Neue Notiz schreiben..."></textarea>
        <div class="d-flex justify-content-between align-items-center mb-2">
            <small class="text-muted">
                Seite: <span id="notePageRef">{{ progress.current_page }}</span>
                <span id="markerInfo" class="ms-2 text-danger d-none">
                    <i class="bi bi-pin-map"></i> Marker gesetzt
                </span>
            </small>
            <button class="btn btn-outline-danger btn-sm" id="addMarkerBtn" title="Marker auf PDF setzen">
                <i class="bi bi-pin-map"></i>
            </button>
        </div>
        <div class="d-flex gap-2">
            <button class="btn btn-secondary btn-sm" id="clearMarker" style="display: none;">
                <i class="bi bi-x me-1"></i>Marker entfernen
            </button>
            <button class="btn btn-primary btn-sm flex-grow-1" id="saveNote">
                <i class="bi bi-plus-lg me-1"></i>Hinzufügen
            </button>
        </div>
    </div>
</div>

<!-- Reading List Panel -->
<div class="reading-list-panel" id="readingListPanel">
    <div class="reading-list-header">
        <h5 class="mb-0"><i class="bi bi-list-check me-2"></i>Leseliste</h5>
        <button class="btn btn-sm btn-light" id="closeReadingList">
            <i class="bi bi-x-lg"></i>
        </button>
    </div>

    <!-- Add New Item -->
    <div class="reading-list-add p-3 border-bottom">
        <div class="input-group mb-2">
            <input type="text" class="form-control form-control-sm" id="rlNewTitle" placeholder="Neue Quelle/ToDo...">
            <button class="btn btn-warning btn-sm" id="rlAddBtn">
                <i class="bi bi-plus"></i>
            </button>
        </div>
        <input type="text" class="form-control form-control-sm mb-2" id="rlNewUrl" placeholder="URL (optional)">
        <textarea class="form-control form-control-sm" id="rlNewNotes" rows="2" placeholder="Notizen (optional)"></textarea>
    </div>

    <!-- Filter -->
    <div class="reading-list-filter p-2 border-bottom bg-light">
        <div class="form-check form-switch">
            <input class="form-check-input" type="checkbox" id="rlShowCompleted">
            <label class="form-check-label small" for="rlShowCompleted">Erledigte anzeigen</label>
        </div>
        <small class="text-muted" id="rlStats"></small>
    </div>

    <!-- Items List -->
    <div class="reading-list-items" id="rlItems">
        <!-- Items loaded via JS -->
    </div>
</div>

<!-- Summary Panel -->
<div class="summary-panel" id="summaryPanel">
    <div class="summary-panel-header">
        <h5 class="mb-0"><i class="bi bi-file-text me-2"></i>Zusammenfassung</h5>
        <button class="btn btn-sm btn-light" id="closeSummaryPanel">
            <i class="bi bi-x-lg"></i>
        </button>
    </div>
    <div class="summary-panel-body" id="summaryPanelBody">
        <div class="summary-loading" id="summaryLoading">
            <i class="bi bi-hourglass-split" style="font-size: 2rem;"></i>
            <p class="mt-2">Lade Zusammenfassung...</p>
        </div>
        <div id="summaryContent" style="display: none;">
            <!-- Summary content loaded via JS -->
        </div>
        <div id="summaryEmpty" style="display: none;">
            <div class="text-center py-4">
                <i class="bi bi-file-earmark-text text-muted" style="font-size: 3rem;"></i>
                <p class="text-muted mt-3">Noch keine Zusammenfassung vorhanden.</p>
                {% if book.category != 'book' %}
                <button class="btn btn-primary summary-generate-btn" id="generateSummaryBtn">
                    <i class="bi bi-magic me-2"></i>Jetzt generieren
                </button>
                <p class="text-muted small mt-2">Dies kann 30-60 Sekunden dauern.</p>
                {% else %}
                <p class="text-muted small">Zusammenfassungen sind nur für Paper/Artikel verfügbar.</p>
                {% endif %}
            </div>
        </div>
    </div>
</div>

<!-- Translation Popup (hidden by default) -->
<div class="translation-popup d-none" id="translationPopup">
    <div class="mb-2">
        <label class="form-label small text-muted mb-1">Originaltext (editierbar)</label>
        <input type="text" class="form-control form-control-sm" id="popupOriginalInput" placeholder="Text eingeben...">
    </div>
    <div class="d-flex gap-2 mb-2">
        <button class="btn btn-sm btn-primary flex-grow-1" id="retranslateBtn">
            <i class="bi bi-translate me-1"></i>Übersetzen
        </button>
        <button class="btn btn-sm btn-outline-secondary" id="speakOriginal" title="Englisch vorlesen">
            <i class="bi bi-volume-up"></i>
        </button>
    </div>
    <div class="mb-2">
        <label class="form-label small text-muted mb-1">Übersetzung</label>
        <div class="translated-text p-2 bg-light rounded" id="popupTranslation">
            <span class="text-muted">Klicke auf "Übersetzen"</span>
        </div>
    </div>
    <div class="popup-actions d-flex gap-2">
        <button class="btn btn-sm btn-outline-secondary" id="speakTranslation" title="Deutsch vorlesen">
            <i class="bi bi-volume-up"></i> DE
        </button>
        <button class="btn btn-sm btn-success flex-grow-1" id="saveHighlight">
            <i class="bi bi-bookmark-plus me-1"></i>Speichern
        </button>
        <button class="btn btn-sm btn-outline-secondary" id="closePopup">
            <i class="bi bi-x"></i>
        </button>
    </div>
</div>

<!-- Action Buttons (appear on selection) -->
<div class="floating-action-btns d-none" id="actionButtons">
    <button class="action-btn-floating btn-translate" id="translateBtn">
        <i class="bi bi-translate me-1"></i>Übersetzen
    </button>
    <button class="action-btn-floating btn-explain" id="explainBtn">
        <i class="bi bi-lightbulb me-1"></i>Erklären
    </button>
</div>

<!-- Explanation Popup (Draggable & Expandable) -->
<div class="explanation-popup d-none" id="explanationPopup">
    <div class="explanation-popup-header" id="explanationPopupHeader">
        <span><i class="bi bi-lightbulb me-2 text-success"></i>Erklärung</span>
        <div class="explanation-popup-controls">
            <button class="btn-popup-control" id="dockExplanationBtn" title="Rechts andocken">
                <i class="bi bi-layout-sidebar-reverse"></i>
            </button>
            <button class="btn-popup-control" id="toggleFullscreenBtn" title="Vollbild">
                <i class="bi bi-arrows-fullscreen"></i>
            </button>
            <button class="btn-popup-control" id="closeExplanationPopup" title="Schließen">
                <i class="bi bi-x-lg"></i>
            </button>
        </div>
    </div>
    <div class="explanation-popup-body">
        <div class="explanation-selected-text-container">
            <small class="text-muted">Ausgewählter Text:</small>
            <div class="explanation-selected-text" id="explanationSelectedText"></div>
        </div>

        <!-- Single Chat Container -->
        <div class="explanation-chat-container" id="explanationChatContainer">
            <!-- All messages (initial explanation + follow-ups) go here -->
        </div>

        <!-- Input Section -->
        <div class="explanation-input-section">
            <div class="explanation-input-container">
                <input type="text" class="form-control" id="followupQuestion" placeholder="Weitere Frage stellen..." />
                <button class="btn btn-success" id="askFollowupBtn" title="Fragen">
                    <i class="bi bi-send"></i>
                </button>
            </div>
        </div>
    </div>
    <div class="explanation-popup-footer">
        <small class="text-muted" id="autoSaveHint" style="display: none;">
            <i class="bi bi-check-circle text-success"></i> Automatisch gespeichert
        </small>
    </div>
</div>

<!-- Modern Confirmation Modal -->
<div class="confirm-modal-backdrop" id="confirmModal">
    <div class="confirm-modal">
        <div class="confirm-modal-icon danger" id="confirmModalIcon">
            <i class="bi bi-trash"></i>
        </div>
        <h3 class="confirm-modal-title" id="confirmModalTitle">Löschen bestätigen</h3>
        <p class="confirm-modal-message" id="confirmModalMessage">Möchtest du dieses Element wirklich löschen?</p>
        <div class="confirm-modal-buttons">
            <button class="btn-cancel" id="confirmModalCancel">Abbrechen</button>
            <button class="btn-confirm" id="confirmModalConfirm">Löschen</button>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<!-- PDF.js from CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>

<script>
// Configuration
const bookId = '{{ book.id }}';
const pdfUrl = '{% url "learnloom:api_serve_pdf" book.id %}';
const csrfToken = '{{ csrf_token }}';
let currentPage = {{ progress.current_page }};
let totalPages = {{ book.page_count }};
let scale = {{ progress.zoom_level }};
let pdfDoc = null;
let highlights = {{ highlights_json|safe }};
let explanations = {{ explanations_json|safe }};
let isRendering = false;
let renderQueue = [];
let userHasZoomed = false; // Track if user manually zoomed

// Initialize PDF.js
pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

// ============================================
// Modern Confirmation Modal
// ============================================
function showConfirmModal(options = {}) {
    return new Promise((resolve) => {
        const modal = document.getElementById('confirmModal');
        const icon = document.getElementById('confirmModalIcon');
        const title = document.getElementById('confirmModalTitle');
        const message = document.getElementById('confirmModalMessage');
        const cancelBtn = document.getElementById('confirmModalCancel');
        const confirmBtn = document.getElementById('confirmModalConfirm');

        // Set content
        title.textContent = options.title || 'Bestätigen';
        message.textContent = options.message || 'Möchtest du fortfahren?';
        cancelBtn.textContent = options.cancelText || 'Abbrechen';
        confirmBtn.textContent = options.confirmText || 'Bestätigen';

        // Set type/style
        const type = options.type || 'danger';
        icon.className = `confirm-modal-icon ${type}`;
        confirmBtn.className = `btn-confirm ${type}`;

        // Set icon
        const icons = {
            danger: 'bi-trash',
            warning: 'bi-exclamation-triangle',
            info: 'bi-question-circle'
        };
        icon.innerHTML = `<i class="bi ${icons[type] || icons.danger}"></i>`;

        // Show modal
        modal.classList.add('show');

        // Handle clicks
        const handleConfirm = () => {
            cleanup();
            resolve(true);
        };

        const handleCancel = () => {
            cleanup();
            resolve(false);
        };

        const handleBackdrop = (e) => {
            if (e.target === modal) {
                handleCancel();
            }
        };

        const handleEscape = (e) => {
            if (e.key === 'Escape') {
                handleCancel();
            }
        };

        const cleanup = () => {
            modal.classList.remove('show');
            confirmBtn.removeEventListener('click', handleConfirm);
            cancelBtn.removeEventListener('click', handleCancel);
            modal.removeEventListener('click', handleBackdrop);
            document.removeEventListener('keydown', handleEscape);
        };

        confirmBtn.addEventListener('click', handleConfirm);
        cancelBtn.addEventListener('click', handleCancel);
        modal.addEventListener('click', handleBackdrop);
        document.addEventListener('keydown', handleEscape);
    });
}

// Show/Hide Loading
function showLoading(text = 'PDF wird geladen...') {
    document.getElementById('loadingOverlay').style.display = 'flex';
    document.querySelector('.loading-text').textContent = text;
}

function hideLoading() {
    document.getElementById('loadingOverlay').style.display = 'none';
}

function updateLoadingProgress(current, total) {
    document.getElementById('loadingProgress').textContent = `Seite ${current} von ${total}`;
}

// Load PDF
async function loadPDF() {
    showLoading('PDF wird geladen...');

    try {
        const loadingTask = pdfjsLib.getDocument({
            url: pdfUrl,
            cMapUrl: 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/cmaps/',
            cMapPacked: true,
        });

        loadingTask.onProgress = function(progress) {
            if (progress.total > 0) {
                const percent = Math.round((progress.loaded / progress.total) * 100);
                document.getElementById('loadingProgress').textContent = `${percent}% geladen`;
            }
        };

        pdfDoc = await loadingTask.promise;
        totalPages = pdfDoc.numPages;
        document.getElementById('totalPages').textContent = totalPages;

        // Check if user has a custom zoom saved (not the default 1.75)
        const savedZoom = {{ progress.zoom_level }};
        const isDefaultZoom = Math.abs(savedZoom - 1.75) < 0.01;
        
        if (isDefaultZoom) {
            // First time or default: calculate optimal fit-to-width
            await calculateOptimalScale();
        } else {
            // User has custom zoom saved: use it and mark as manually zoomed
            scale = savedZoom;
            userHasZoomed = true;
            document.getElementById('zoomLevel').value = Math.round(scale * 100) + '%';
        }

        await renderAllPages();
        hideLoading();

    } catch (error) {
        console.error('Error loading PDF:', error);
        hideLoading();

        const container = document.getElementById('pdfCanvasContainer');
        container.innerHTML = `
            <div class="text-center text-white py-5">
                <i class="bi bi-exclamation-triangle" style="font-size: 4rem;"></i>
                <h4 class="mt-3">Fehler beim Laden des PDFs</h4>
                <p class="text-muted">${error.message || 'Unbekannter Fehler'}</p>
                <button class="btn btn-primary mt-3" onclick="location.reload()">
                    <i class="bi bi-arrow-clockwise me-2"></i>Erneut versuchen
                </button>
            </div>
        `;
    }
}

// Calculate optimal scale to fit PDF width to container
async function calculateOptimalScale() {
    try {
        const firstPage = await pdfDoc.getPage(1);
        const defaultViewport = firstPage.getViewport({ scale: 1.0 });

        // Check if any panel is open
        const summaryOpen = document.getElementById('summaryPanel')?.classList.contains('open');
        const explanationDocked = document.getElementById('explanationPopup')?.classList.contains('docked');
        let panelWidth = 0;
        if (summaryOpen) panelWidth = 380;
        if (explanationDocked) panelWidth = 400;

        // DIREKT den Container messen
        const container = document.getElementById('pdfCanvasContainer');
        const style = getComputedStyle(container);
        const containerWidth = container.clientWidth;
        const paddingLeft = parseFloat(style.paddingLeft) || 0;
        const paddingRight = parseFloat(style.paddingRight) || 0;
        
        // Verfügbare Breite = clientWidth minus Padding
        const availableWidth = containerWidth - paddingLeft - paddingRight;

        console.log('calculateOptimalScale:', {
            viewportWidth,
            panelWidth,
            availableWidth, 
            pdfNaturalWidth: defaultViewport.width
        });

        // Calculate scale to fit width
        const optimalScale = availableWidth / defaultViewport.width;

        // Clamp between 0.5 and 4
        scale = Math.min(4, Math.max(0.5, optimalScale));

        // Update zoom display
        document.getElementById('zoomLevel').value = Math.round(scale * 100) + '%';

        console.log('Scale set to:', Math.round(scale * 100) + '%');
    } catch (error) {
        console.error('Error calculating optimal scale:', error);
        scale = 1.75;
    }
}

// Render all pages
async function renderAllPages() {
    if (isRendering) {
        console.log('Already rendering, skipping...');
        return;
    }

    isRendering = true;
    const container = document.getElementById('pdfCanvasContainer');
    container.innerHTML = '';

    showLoading('Seiten werden gerendert...');

    try {
        for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
            updateLoadingProgress(pageNum, totalPages);

            const pageDiv = document.createElement('div');
            pageDiv.className = 'pdf-page';
            pageDiv.dataset.page = pageNum;

            const canvas = document.createElement('canvas');
            pageDiv.appendChild(canvas);

            container.appendChild(pageDiv);

            await renderPage(pageNum, canvas);
        }

        // Scroll to saved position
        scrollToPage(currentPage);

        // Render saved highlights, explanations and markers
        setTimeout(() => {
            renderAllHighlights();
            renderAllExplanations();
            loadNotes(); // This will also render markers
        }, 100);

    } catch (error) {
        console.error('Error rendering pages:', error);
    } finally {
        isRendering = false;
        hideLoading();
    }
}

// Render single page
async function renderPage(pageNum, canvas) {
    try {
        const page = await pdfDoc.getPage(pageNum);
        const viewport = page.getViewport({ scale: scale });

        canvas.width = viewport.width;
        canvas.height = viewport.height;

        const ctx = canvas.getContext('2d');

        const renderContext = {
            canvasContext: ctx,
            viewport: viewport
        };

        await page.render(renderContext).promise;

        // Add text layer for selection
        try {
            const textContent = await page.getTextContent();
            const textLayer = document.createElement('div');
            textLayer.className = 'textLayer';

            // Set dimensions and scale factor for PDF.js 3.x
            textLayer.style.setProperty('--scale-factor', scale);
            textLayer.style.width = Math.floor(viewport.width) + 'px';
            textLayer.style.height = Math.floor(viewport.height) + 'px';

            canvas.parentElement.appendChild(textLayer);

            // Render text layer with PDF.js
            await pdfjsLib.renderTextLayer({
                textContentSource: textContent,
                container: textLayer,
                viewport: viewport
            }).promise;

        } catch (textError) {
            console.warn('Text layer error on page', pageNum, textError);
        }

    } catch (error) {
        console.error('Error rendering page', pageNum, error);
        canvas.width = 600;
        canvas.height = 800;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#f8d7da';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#721c24';
        ctx.font = '16px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(`Fehler beim Laden von Seite ${pageNum}`, canvas.width/2, canvas.height/2);
    }
}

// Scroll to page
function scrollToPage(pageNum) {
    const pageDiv = document.querySelector(`.pdf-page[data-page="${pageNum}"]`);
    if (pageDiv) {
        pageDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
}

// Update current page on scroll
document.getElementById('pdfCanvasContainer').addEventListener('scroll', function() {
    const pages = document.querySelectorAll('.pdf-page');
    const containerRect = this.getBoundingClientRect();

    for (const page of pages) {
        const pageRect = page.getBoundingClientRect();
        if (pageRect.top <= containerRect.top + 100 && pageRect.bottom > containerRect.top + 100) {
            currentPage = parseInt(page.dataset.page);
            document.getElementById('currentPage').textContent = currentPage;
            document.getElementById('notePageRef').textContent = currentPage;
            break;
        }
    }
});

// Navigation
document.getElementById('prevPage').addEventListener('click', () => {
    if (currentPage > 1) {
        scrollToPage(currentPage - 1);
    }
});

document.getElementById('nextPage').addEventListener('click', () => {
    if (currentPage < totalPages) {
        scrollToPage(currentPage + 1);
    }
});

// Zoom with debounce
let zoomTimeout = null;
const zoomInput = document.getElementById('zoomLevel');

function handleZoom(newScale) {
    scale = Math.min(4, Math.max(0.25, newScale)); // Clamp between 25% and 400%
    zoomInput.value = Math.round(scale * 100) + '%';
    userHasZoomed = true; // User manually changed zoom

    // Debounce re-render
    if (zoomTimeout) clearTimeout(zoomTimeout);
    zoomTimeout = setTimeout(() => {
        renderAllPages();
    }, 300);
}

document.getElementById('zoomIn').addEventListener('click', () => {
    handleZoom(scale + 0.25);
});

document.getElementById('zoomOut').addEventListener('click', () => {
    handleZoom(scale - 0.25);
});

// Custom zoom input
zoomInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
        e.preventDefault();
        applyCustomZoom();
        zoomInput.blur();
    }
});

zoomInput.addEventListener('blur', () => {
    applyCustomZoom();
});

function applyCustomZoom() {
    const value = zoomInput.value.replace('%', '').trim();
    const parsed = parseInt(value, 10);

    if (!isNaN(parsed) && parsed >= 25 && parsed <= 400) {
        handleZoom(parsed / 100);
    } else {
        // Reset to current scale if invalid
        zoomInput.value = Math.round(scale * 100) + '%';
    }
}

// Fullscreen Toggle
document.getElementById('toggleFullscreen').addEventListener('click', () => {
    const icon = document.querySelector('#toggleFullscreen i');

    if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().then(() => {
            icon.className = 'bi bi-fullscreen-exit';
        }).catch(err => {
            console.error('Fullscreen error:', err);
        });
    } else {
        document.exitFullscreen().then(() => {
            icon.className = 'bi bi-fullscreen';
        });
    }
});

// Update icon when fullscreen changes (e.g., via ESC key)
document.addEventListener('fullscreenchange', () => {
    const icon = document.querySelector('#toggleFullscreen i');
    if (document.fullscreenElement) {
        icon.className = 'bi bi-fullscreen-exit';
    } else {
        icon.className = 'bi bi-fullscreen';
    }
});

// Notes Panel
const notesPanel = document.getElementById('notesPanel');
let notesData = []; // Store notes for marker rendering
let pendingMarker = null; // Marker waiting to be saved with note

document.getElementById('toggleNotes').addEventListener('click', () => {
    notesPanel.classList.toggle('open');
    if (notesPanel.classList.contains('open')) {
        loadNotes();
    }
});
document.getElementById('closeNotes').addEventListener('click', () => {
    notesPanel.classList.remove('open');
});

// Reading List Panel
const readingListPanel = document.getElementById('readingListPanel');
document.getElementById('toggleReadingList').addEventListener('click', () => {
    readingListPanel.classList.toggle('open');
    if (readingListPanel.classList.contains('open')) {
        loadReadingListPDF();
    }
});
document.getElementById('closeReadingList').addEventListener('click', () => {
    readingListPanel.classList.remove('open');
});
document.getElementById('rlShowCompleted').addEventListener('change', loadReadingListPDF);
document.getElementById('rlAddBtn').addEventListener('click', addReadingListItemPDF);

// Enter key to add item
document.getElementById('rlNewTitle').addEventListener('keypress', (e) => {
    if (e.key === 'Enter') addReadingListItemPDF();
});

async function loadReadingListPDF() {
    const showCompleted = document.getElementById('rlShowCompleted').checked;
    try {
        const response = await fetch(`/learnloom/api/reading-list/?show_completed=${showCompleted}`);
        const data = await response.json();

        if (data.success) {
            renderReadingListPDF(data.items);
            document.getElementById('rlStats').textContent =
                `${data.stats.todo} offen, ${data.stats.done} erledigt`;
        }
    } catch (error) {
        console.error('Error loading reading list:', error);
    }
}

function renderReadingListPDF(items) {
    const container = document.getElementById('rlItems');

    if (items.length === 0) {
        container.innerHTML = `
            <div class="text-center text-muted py-4">
                <i class="bi bi-inbox" style="font-size: 2rem;"></i>
                <p class="mt-2 mb-0">Keine Einträge</p>
            </div>
        `;
        return;
    }

    container.innerHTML = items.map(item => `
        <div class="reading-list-item ${item.status === 'done' ? 'done' : ''}" data-id="${item.id}">
            <div class="item-title">${escapeHtmlRL(item.title)}</div>
            ${item.url ? `<a href="${escapeHtmlRL(item.url)}" target="_blank" class="item-url"><i class="bi bi-link-45deg"></i>${escapeHtmlRL(item.url)}</a>` : ''}
            ${item.notes ? `<div class="item-notes">${escapeHtmlRL(item.notes)}</div>` : ''}
            <div class="item-date">${new Date(item.created_at).toLocaleDateString('de-DE')}</div>
            <div class="item-actions">
                ${item.status === 'todo'
                    ? `<button class="btn btn-success btn-sm" onclick="toggleRLStatus('${item.id}', 'done')" title="Als erledigt markieren">
                         <i class="bi bi-check-lg"></i>
                       </button>`
                    : `<button class="btn btn-warning btn-sm" onclick="toggleRLStatus('${item.id}', 'todo')" title="Wieder öffnen">
                         <i class="bi bi-arrow-counterclockwise"></i>
                       </button>`
                }
                <button class="btn btn-outline-danger btn-sm" onclick="deleteRLItem('${item.id}')" title="Löschen">
                    <i class="bi bi-trash"></i>
                </button>
            </div>
        </div>
    `).join('');
}

function escapeHtmlRL(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

async function addReadingListItemPDF() {
    const title = document.getElementById('rlNewTitle').value.trim();
    const url = document.getElementById('rlNewUrl').value.trim();
    const notes = document.getElementById('rlNewNotes').value.trim();

    if (!title) {
        alert('Bitte einen Titel eingeben');
        return;
    }

    try {
        const response = await fetch('/learnloom/api/reading-list/add/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken,
            },
            body: JSON.stringify({ title, url, notes })
        });

        const data = await response.json();
        if (data.success) {
            document.getElementById('rlNewTitle').value = '';
            document.getElementById('rlNewUrl').value = '';
            document.getElementById('rlNewNotes').value = '';
            loadReadingListPDF();
        } else {
            alert('Fehler: ' + data.error);
        }
    } catch (error) {
        alert('Fehler beim Hinzufügen: ' + error.message);
    }
}

async function toggleRLStatus(itemId, newStatus) {
    try {
        const response = await fetch(`/learnloom/api/reading-list/${itemId}/update/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken,
            },
            body: JSON.stringify({ status: newStatus })
        });

        const data = await response.json();
        if (data.success) {
            loadReadingListPDF();
        }
    } catch (error) {
        alert('Fehler: ' + error.message);
    }
}

async function deleteRLItem(itemId) {
    if (!confirm('Eintrag wirklich löschen?')) return;

    try {
        const response = await fetch(`/learnloom/api/reading-list/${itemId}/delete/`, {
            method: 'POST',
            headers: { 'X-CSRFToken': csrfToken }
        });

        const data = await response.json();
        if (data.success) {
            loadReadingListPDF();
        }
    } catch (error) {
        alert('Fehler: ' + error.message);
    }
}

// Load Notes
async function loadNotes() {
    try {
        const response = await fetch(`/learnloom/api/notes/${bookId}/`);
        const data = await response.json();

        if (data.success) {
            notesData = data.notes; // Store for marker rendering
            const notesList = document.getElementById('notesList');
            if (data.notes.length === 0) {
                notesList.innerHTML = '<p class="text-muted text-center">Noch keine Notizen</p>';
            } else {
                // Reverse order: oldest first, newest at bottom
                const sortedNotes = [...data.notes].reverse();
                notesList.innerHTML = sortedNotes.map(note => `
                    <div class="note-item" data-note-id="${note.id}">
                        <div class="note-content">${note.content}</div>
                        <div class="note-meta d-flex justify-content-between align-items-center">
                            <span>
                                ${note.page_reference ? 'Seite ' + note.page_reference : ''}
                                ${note.marker_position ? '<i class="bi bi-pin-map text-danger ms-1" title="Hat Marker"></i>' : ''}
                            </span>
                            <div class="d-flex gap-1">
                                ${note.marker_position ? `<button class="btn btn-sm btn-outline-primary" onclick="goToMarker('${note.id}')" title="Zum Marker springen"><i class="bi bi-geo-alt me-1"></i>Marker</button>` : ''}
                                <button class="btn btn-sm btn-outline-danger" onclick="deleteNote('${note.id}')" title="Löschen">
                                    <i class="bi bi-trash"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                `).join('');
            }
            // Render markers on PDF
            renderAllMarkers();
        }
    } catch (error) {
        console.error('Error loading notes:', error);
    }
}

// Save Note
document.getElementById('saveNote').addEventListener('click', async () => {
    const content = document.getElementById('newNoteContent').value.trim();
    if (!content) return;

    try {
        const response = await fetch(`/learnloom/api/notes/${bookId}/save/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken
            },
            body: JSON.stringify({
                content: content,
                page_reference: currentPage,
                marker_position: pendingMarker
            })
        });

        const data = await response.json();
        if (data.success) {
            document.getElementById('newNoteContent').value = '';
            clearPendingMarker();
            loadNotes();
        }
    } catch (error) {
        console.error('Error saving note:', error);
    }
});

// ============================================
// Marker Mode
// ============================================
let markerMode = false;
const markerModeHint = document.getElementById('markerModeHint');

document.getElementById('toggleMarkerMode').addEventListener('click', () => {
    markerMode = !markerMode;
    if (markerMode) {
        document.body.classList.add('marker-mode-active');
        markerModeHint.classList.remove('d-none');
        // Open notes panel
        notesPanel.classList.add('open');
        loadNotes();
    } else {
        exitMarkerMode();
    }
});

document.getElementById('addMarkerBtn').addEventListener('click', () => {
    markerMode = true;
    document.body.classList.add('marker-mode-active');
    markerModeHint.classList.remove('d-none');
});

function exitMarkerMode() {
    markerMode = false;
    document.body.classList.remove('marker-mode-active');
    markerModeHint.classList.add('d-none');
}

// ESC to exit marker mode
document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && markerMode) {
        exitMarkerMode();
    }
});

// Note: pdfContainer click handler for markers is defined later after pdfContainer is initialized

function showTempMarker(pageDiv, relX, relY) {
    // Remove existing temp marker
    document.querySelectorAll('.temp-marker').forEach(m => m.remove());

    const marker = createMarkerElement();
    marker.classList.add('temp-marker');
    marker.style.left = (relX * 100) + '%';
    marker.style.top = (relY * 100) + '%';
    marker.style.transform = 'translate(-50%, -100%)';
    marker.style.opacity = '0.7';
    pageDiv.appendChild(marker);
}

function clearPendingMarker() {
    pendingMarker = null;
    document.getElementById('markerInfo').classList.add('d-none');
    document.getElementById('clearMarker').style.display = 'none';
    document.querySelectorAll('.temp-marker').forEach(m => m.remove());
}

document.getElementById('clearMarker').addEventListener('click', clearPendingMarker);

// Create marker SVG element
function createMarkerElement() {
    const marker = document.createElement('div');
    marker.className = 'note-marker';
    marker.innerHTML = `<svg viewBox="0 0 24 24"><path fill="#e74c3c" d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/></svg>`;
    return marker;
}

// Render all markers on PDF
function renderAllMarkers() {
    // Remove existing markers
    document.querySelectorAll('.note-marker:not(.temp-marker)').forEach(m => m.remove());

    notesData.forEach(note => {
        if (note.marker_position) {
            const pos = note.marker_position;
            const pageDiv = document.querySelector(`.pdf-page[data-page="${pos.page}"]`);
            if (pageDiv) {
                const marker = createMarkerElement();
                marker.style.left = (pos.x * 100) + '%';
                marker.style.top = (pos.y * 100) + '%';
                marker.style.transform = 'translate(-50%, -100%)';
                marker.dataset.noteId = note.id;
                marker.title = note.content.substring(0, 50) + (note.content.length > 50 ? '...' : '');

                marker.addEventListener('click', (e) => {
                    e.stopPropagation();
                    showNotePopup(note, e);
                });

                pageDiv.appendChild(marker);
            }
        }
    });
}

// Show note popup when clicking marker
function showNotePopup(note, event) {
    // Open notes panel and highlight the note
    notesPanel.classList.add('open');
    loadNotes().then(() => {
        const noteItem = document.querySelector(`.note-item[data-note-id="${note.id}"]`);
        if (noteItem) {
            noteItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
            noteItem.style.backgroundColor = '#fff3cd';
            setTimeout(() => {
                noteItem.style.backgroundColor = '';
            }, 2000);
        }
    });
}

// Go to marker from notes list
function goToMarker(noteId) {
    const note = notesData.find(n => n.id === noteId);
    if (note && note.marker_position) {
        scrollToPage(note.marker_position.page);
        // Flash the marker
        setTimeout(() => {
            const marker = document.querySelector(`.note-marker[data-note-id="${noteId}"]`);
            if (marker) {
                marker.style.transform = 'translate(-50%, -100%) scale(1.5)';
                setTimeout(() => {
                    marker.style.transform = 'translate(-50%, -100%)';
                }, 500);
            }
        }, 300);
    }
}

// Delete Note
async function deleteNote(noteId) {
    const confirmed = await showConfirmModal({
        type: 'danger',
        title: 'Notiz löschen',
        message: 'Möchtest du diese Notiz wirklich löschen? Der zugehörige Marker wird ebenfalls entfernt.',
        confirmText: 'Löschen',
        cancelText: 'Abbrechen'
    });

    if (!confirmed) return;

    try {
        const response = await fetch(`/learnloom/api/notes/${noteId}/delete/`, {
            method: 'POST',
            headers: { 'X-CSRFToken': csrfToken }
        });

        const data = await response.json();
        if (data.success) {
            loadNotes();
        }
    } catch (error) {
        console.error('Error deleting note:', error);
    }
}

// Text Selection & Translation/Explanation
const actionButtons = document.getElementById('actionButtons');
const translateBtn = document.getElementById('translateBtn');
const explainBtn = document.getElementById('explainBtn');
const translationPopup = document.getElementById('translationPopup');
const explanationPopup = document.getElementById('explanationPopup');
const originalInput = document.getElementById('popupOriginalInput');
const translationDiv = document.getElementById('popupTranslation');
const explanationSelectedText = document.getElementById('explanationSelectedText');
const explanationChatContainer = document.getElementById('explanationChatContainer');
let selectedText = '';
let selectionPosition = {};
let currentTranslation = '';
let currentExplanation = '';
let contextBefore = '';
let contextAfter = '';

// Get surrounding context from selection
function getSelectionContext() {
    const selection = window.getSelection();
    if (!selection.rangeCount) return { before: '', after: '' };

    const range = selection.getRangeAt(0);
    const container = range.commonAncestorContainer;

    // Get the text content of the parent element
    let parentElement = container;
    if (container.nodeType === Node.TEXT_NODE) {
        parentElement = container.parentElement;
    }

    // Try to get the page container for broader context
    const pageContainer = parentElement.closest('.pdf-page');
    if (pageContainer) {
        const fullText = pageContainer.textContent || '';
        const selectedStr = selection.toString();
        const idx = fullText.indexOf(selectedStr);
        if (idx > -1) {
            return {
                before: fullText.substring(Math.max(0, idx - 300), idx),
                after: fullText.substring(idx + selectedStr.length, idx + selectedStr.length + 300)
            };
        }
    }

    return { before: '', after: '' };
}

// Hide action buttons on click elsewhere
document.addEventListener('mousedown', (e) => {
    if (!actionButtons.contains(e.target) && !translationPopup.contains(e.target) && !explanationPopup.contains(e.target)) {
        // Don't hide immediately - wait to see if it's a selection
    }
});

document.addEventListener('mouseup', (e) => {
    // Ignore clicks inside popups or action buttons
    if (translationPopup.contains(e.target) || explanationPopup.contains(e.target) ||
        actionButtons.contains(e.target)) return;

    // Small delay to let selection complete
    setTimeout(() => {
        const selection = window.getSelection();
        const text = selection.toString().trim();

        if (text.length > 0 && text.length < 1000) {
            selectedText = text;
            selectionPosition = { x: e.clientX, y: e.clientY };

            // Get surrounding context
            const ctx = getSelectionContext();
            contextBefore = ctx.before;
            contextAfter = ctx.after;

            // Show action buttons near the selection
            const btnX = Math.min(e.clientX, window.innerWidth - 250);
            const btnY = Math.max(e.clientY - 50, 10);
            actionButtons.style.left = btnX + 'px';
            actionButtons.style.top = btnY + 'px';
            actionButtons.classList.remove('d-none');
        } else {
            actionButtons.classList.add('d-none');
        }
    }, 10);
});

// Translate Button Click - Open translation popup
translateBtn.addEventListener('click', () => {
    actionButtons.classList.add('d-none');
    explanationPopup.classList.add('d-none');

    // Position popup
    const popupX = Math.min(selectionPosition.x, window.innerWidth - 320);
    const popupY = Math.min(selectionPosition.y, window.innerHeight - 250);
    translationPopup.style.left = popupX + 'px';
    translationPopup.style.top = popupY + 'px';
    translationPopup.classList.remove('d-none');

    // Set input value and reset translation
    originalInput.value = selectedText;
    translationDiv.innerHTML = '<span class="text-muted">Klicke auf "Übersetzen"</span>';
    currentTranslation = '';

    // Focus input for easy editing
    originalInput.focus();
    originalInput.select();
});

// Explain Button Click - Open explanation popup and fetch immediately
explainBtn.addEventListener('click', () => {
    actionButtons.classList.add('d-none');
    translationPopup.classList.add('d-none');

    // Reset fullscreen state
    explanationPopup.classList.remove('fullscreen');
    const fullscreenIcon = document.querySelector('#toggleFullscreenBtn i');
    if (fullscreenIcon) fullscreenIcon.className = 'bi bi-arrows-fullscreen';

    // Position popup
    const popupX = Math.min(selectionPosition.x, window.innerWidth - 440);
    const popupY = Math.min(selectionPosition.y, window.innerHeight - 400);
    explanationPopup.style.left = Math.max(10, popupX) + 'px';
    explanationPopup.style.top = Math.max(10, popupY) + 'px';
    explanationPopup.classList.remove('d-none');

    // Set selected text
    explanationSelectedText.textContent = selectedText;
    document.getElementById('autoSaveHint').style.display = 'none';

    // Clear follow-up input
    const followupInp = document.getElementById('followupQuestion');
    if (followupInp) followupInp.value = '';

    // Immediately fetch explanation
    fetchExplanation(selectedText);
});

// Translate function
async function translateText() {
    const textToTranslate = originalInput.value.trim();
    if (!textToTranslate) {
        translationDiv.innerHTML = '<span class="text-danger">Bitte Text eingeben</span>';
        return;
    }

    translationDiv.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>Übersetze...';

    try {
        const response = await fetch('/learnloom/api/translate/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken
            },
            body: JSON.stringify({
                text: textToTranslate,
                source_lang: 'en',
                target_lang: 'de'
            })
        });

        const data = await response.json();
        if (data.success) {
            currentTranslation = data.translation;
            translationDiv.textContent = data.translation;
        } else {
            translationDiv.innerHTML = '<span class="text-danger">Fehler: ' + data.error + '</span>';
            currentTranslation = '';
        }
    } catch (error) {
        translationDiv.innerHTML = '<span class="text-danger">Übersetzungsfehler</span>';
        currentTranslation = '';
    }
}

// Retranslate button
document.getElementById('retranslateBtn').addEventListener('click', translateText);

// Enter key in input triggers translation
originalInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
        e.preventDefault();
        translateText();
    }
});

// Close Popup
document.getElementById('closePopup').addEventListener('click', () => {
    translationPopup.classList.add('d-none');
    currentTranslation = '';
});

// ============================================
// Explanation Functions (Draggable, Fullscreen, Follow-up)
// ============================================

const followupInput = document.getElementById('followupQuestion');
let conversationHistory = []; // Store conversation for context

// Make popup draggable
let isDragging = false;
let dragStartX, dragStartY, popupStartX, popupStartY;

const explanationHeader = document.getElementById('explanationPopupHeader');

explanationHeader.addEventListener('mousedown', (e) => {
    if (e.target.closest('.btn-popup-control')) return; // Don't drag when clicking buttons
    isDragging = true;
    dragStartX = e.clientX;
    dragStartY = e.clientY;
    const rect = explanationPopup.getBoundingClientRect();
    popupStartX = rect.left;
    popupStartY = rect.top;
    explanationPopup.style.transition = 'none';
});

document.addEventListener('mousemove', (e) => {
    if (!isDragging) return;
    const deltaX = e.clientX - dragStartX;
    const deltaY = e.clientY - dragStartY;
    explanationPopup.style.left = (popupStartX + deltaX) + 'px';
    explanationPopup.style.top = (popupStartY + deltaY) + 'px';
});

document.addEventListener('mouseup', () => {
    isDragging = false;
    explanationPopup.style.transition = 'all 0.3s ease';
});

// Fullscreen toggle
document.getElementById('toggleFullscreenBtn').addEventListener('click', () => {
    explanationPopup.classList.toggle('fullscreen');
    const icon = document.querySelector('#toggleFullscreenBtn i');
    if (explanationPopup.classList.contains('fullscreen')) {
        icon.className = 'bi bi-fullscreen-exit';
    } else {
        icon.className = 'bi bi-arrows-fullscreen';
    }
});

// Fetch Explanation (with auto-save)
async function fetchExplanation(textToExplain) {
    if (!textToExplain) {
        explanationChatContainer.innerHTML = '<div class="text-danger text-center py-3">Kein Text ausgewählt</div>';
        return;
    }

    // Show loading in chat container
    explanationChatContainer.innerHTML = '<div class="chat-message assistant"><span class="spinner-border spinner-border-sm me-2"></span>Analysiere...</div>';
    conversationHistory = []; // Reset conversation

    try {
        const response = await fetch('/learnloom/api/explain/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken
            },
            body: JSON.stringify({
                selected_text: textToExplain,
                context_before: contextBefore,
                context_after: contextAfter,
                provider: 'openai'
            })
        });

        const data = await response.json();
        if (data.success) {
            currentExplanation = data.explanation;

            // Show explanation as first chat message
            explanationChatContainer.innerHTML = '';
            const explanationMsg = document.createElement('div');
            explanationMsg.className = 'chat-message assistant';
            explanationMsg.textContent = data.explanation;
            explanationChatContainer.appendChild(explanationMsg);

            // Store initial explanation in conversation
            conversationHistory.push({
                role: 'user',
                content: `Erkläre: "${textToExplain}"`
            });
            conversationHistory.push({
                role: 'assistant',
                content: data.explanation
            });

            // Auto-save explanation
            await autoSaveExplanation(textToExplain, data.explanation);
        } else {
            explanationChatContainer.innerHTML = '<div class="text-danger text-center py-3">Fehler: ' + data.error + '</div>';
            currentExplanation = '';
        }
    } catch (error) {
        explanationChatContainer.innerHTML = '<div class="text-danger text-center py-3">Erklärungsfehler</div>';
        currentExplanation = '';
    }
}

// Auto-save explanation to database
async function autoSaveExplanation(textToSave, explanationText) {
    try {
        const response = await fetch(`/learnloom/api/explanations/${bookId}/save/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken
            },
            body: JSON.stringify({
                selected_text: textToSave,
                explanation: explanationText,
                context_before: contextBefore,
                context_after: contextAfter,
                page_number: currentPage,
                position_data: {},
                provider: 'openai'
            })
        });

        const data = await response.json();
        if (data.success) {
            // Add to local explanations array
            explanations.push({
                id: data.explanation.id,
                selected_text: data.explanation.selected_text,
                explanation: data.explanation.explanation,
                page_number: data.explanation.page_number,
                position_data: {},
                type: 'explanation'
            });

            // Render explanation highlights
            renderAllExplanations();

            // Show saved hint
            document.getElementById('autoSaveHint').style.display = 'inline';

            console.log('Erklärung automatisch gespeichert');
        }
    } catch (error) {
        console.error('Fehler beim Auto-Speichern:', error);
    }
}

// Ask Follow-up Question
async function askFollowup() {
    const question = followupInput.value.trim();
    if (!question || !currentExplanation) return;

    // Add user message to chat
    const userMsg = document.createElement('div');
    userMsg.className = 'chat-message user';
    userMsg.textContent = question;
    explanationChatContainer.appendChild(userMsg);

    // Clear input
    followupInput.value = '';

    // Add loading message
    const loadingMsg = document.createElement('div');
    loadingMsg.className = 'chat-message assistant';
    loadingMsg.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>';
    explanationChatContainer.appendChild(loadingMsg);

    // Scroll to bottom
    explanationChatContainer.scrollTop = explanationChatContainer.scrollHeight;

    // Store question in conversation
    conversationHistory.push({ role: 'user', content: question });

    try {
        // Build conversation context
        const conversationContext = conversationHistory.map(msg =>
            `${msg.role === 'user' ? 'Frage' : 'Antwort'}: ${msg.content}`
        ).join('\n\n');

        const response = await fetch('/learnloom/api/explain/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken
            },
            body: JSON.stringify({
                selected_text: question,
                context_before: `Vorherige Unterhaltung:\n${conversationContext}\n\nUrsprünglicher Text: "${explanationSelectedText.textContent}"`,
                context_after: contextAfter,
                provider: 'openai'
            })
        });

        const data = await response.json();
        if (data.success) {
            loadingMsg.textContent = data.explanation;
            conversationHistory.push({ role: 'assistant', content: data.explanation });
        } else {
            loadingMsg.innerHTML = '<span class="text-danger">Fehler: ' + data.error + '</span>';
        }
    } catch (error) {
        loadingMsg.innerHTML = '<span class="text-danger">Fehler beim Antworten</span>';
    }

    // Scroll to bottom
    explanationChatContainer.scrollTop = explanationChatContainer.scrollHeight;
}

document.getElementById('askFollowupBtn').addEventListener('click', askFollowup);

// Enter key for follow-up
followupInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
        e.preventDefault();
        askFollowup();
    }
});

// Close Explanation Popup
function closeExplanationPopup() {
    explanationPopup.classList.add('d-none');
    explanationPopup.classList.remove('fullscreen');
    document.querySelector('#toggleFullscreenBtn i').className = 'bi bi-arrows-fullscreen';
    currentExplanation = '';
    conversationHistory = [];
    explanationChatContainer.innerHTML = '';
    document.getElementById('autoSaveHint').style.display = 'none';
}

document.getElementById('closeExplanationPopup').addEventListener('click', closeExplanationPopup);

// Close explanation popup when clicking outside
document.addEventListener('click', (e) => {
    if (explanationPopup.classList.contains('d-none')) return;

    // Check if click is outside the popup
    if (!explanationPopup.contains(e.target) &&
        !actionButtons.contains(e.target) &&
        !e.target.closest('#explainBtn')) {
        closeExplanationPopup();
    }
});

// ============================================
// Rectangle Selection Mode
// ============================================
let selectMode = false;
let isDrawing = false;
let startX, startY;
const selectionRect = document.getElementById('selectionRect');
const selectModeHint = document.getElementById('selectModeHint');
const pdfContainer = document.getElementById('pdfCanvasContainer');

// Store page text content for extraction
const pageTextContents = {};

// Toggle selection mode
document.getElementById('toggleSelectMode').addEventListener('click', () => {
    selectMode = !selectMode;

    if (selectMode) {
        document.body.classList.add('select-mode-active');
        selectModeHint.classList.remove('d-none');
        console.log('Selection mode ON');
    } else {
        exitSelectMode();
    }
});

function exitSelectMode() {
    selectMode = false;
    isDrawing = false;
    document.body.classList.remove('select-mode-active');
    selectionRect.style.display = 'none';
    selectModeHint.classList.add('d-none');
    console.log('Selection mode OFF');
}

// ESC to exit selection mode
document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && selectMode) {
        exitSelectMode();
    }
});

// Drawing rectangle on PDF container
pdfContainer.addEventListener('mousedown', (e) => {
    if (!selectMode) return;
    e.preventDefault();

    isDrawing = true;
    startX = e.clientX;
    startY = e.clientY;

    selectionRect.style.left = startX + 'px';
    selectionRect.style.top = startY + 'px';
    selectionRect.style.width = '0';
    selectionRect.style.height = '0';
    selectionRect.style.display = 'block';

    console.log('Drawing started at', startX, startY);
});

document.addEventListener('mousemove', (e) => {
    if (!isDrawing || !selectMode) return;

    const currentX = e.clientX;
    const currentY = e.clientY;

    const width = Math.abs(currentX - startX);
    const height = Math.abs(currentY - startY);
    const left = Math.min(currentX, startX);
    const top = Math.min(currentY, startY);

    selectionRect.style.left = left + 'px';
    selectionRect.style.top = top + 'px';
    selectionRect.style.width = width + 'px';
    selectionRect.style.height = height + 'px';
});

document.addEventListener('mouseup', async (e) => {
    if (!isDrawing || !selectMode) return;
    isDrawing = false;

    const rect = {
        left: parseInt(selectionRect.style.left),
        top: parseInt(selectionRect.style.top),
        width: parseInt(selectionRect.style.width),
        height: parseInt(selectionRect.style.height)
    };

    console.log('Selection rectangle:', rect);

    // Minimum size check
    if (rect.width < 5 || rect.height < 5) {
        selectionRect.style.display = 'none';
        console.log('Rectangle too small');
        return;
    }

    // Extract text from the selected region
    try {
        const extractedText = await extractTextFromRegion(rect);
        console.log('Extracted text:', extractedText);

        // Exit select mode
        exitSelectMode();

        if (extractedText && extractedText.trim()) {
            openTranslationPopup(extractedText, rect.left + rect.width/2, rect.top + rect.height);
        } else {
            // Show popup with empty input for manual entry
            openTranslationPopup('', rect.left + rect.width/2, rect.top + rect.height);
            alert('Kein Text gefunden. Bitte manuell eingeben.');
        }
    } catch (error) {
        console.error('Error extracting text:', error);
        exitSelectMode();
        alert('Fehler bei der Textextraktion: ' + error.message);
    }
});

// Extract text from PDF region - find the SINGLE word closest to selection center
async function extractTextFromRegion(screenRect) {
    console.log('Extracting from screen rect:', screenRect);

    const selLeft = screenRect.left;
    const selRight = screenRect.left + screenRect.width;
    const selTop = screenRect.top;
    const selBottom = screenRect.top + screenRect.height;
    const selCenterX = screenRect.left + screenRect.width / 2;

    // Find all text layer spans that overlap with selection
    const allSpans = document.querySelectorAll('.textLayer span');
    let bestWord = null;
    let bestDistance = Infinity;

    allSpans.forEach(span => {
        const text = span.textContent;
        if (!text || text.trim().length === 0) return;

        const spanRect = span.getBoundingClientRect();

        // Check if span overlaps with selection vertically
        const overlapY = spanRect.top < selBottom && spanRect.bottom > selTop;
        if (!overlapY) return;

        // Check if span overlaps with selection horizontally
        const overlapX = spanRect.left < selRight && spanRect.right > selLeft;
        if (!overlapX) return;

        // Get font for accurate measurement
        const computedStyle = window.getComputedStyle(span);
        const font = `${computedStyle.fontSize} ${computedStyle.fontFamily}`;
        const scaleX = spanRect.width / measureTextWidth(text, font) || 1;

        // Find which word in this span is under the selection
        const words = text.split(/(\s+)/); // Keep spaces for position calc
        let currentX = spanRect.left;

        for (const word of words) {
            if (word.trim().length === 0) {
                currentX += measureTextWidth(word, font) * scaleX;
                continue;
            }

            const wordWidth = measureTextWidth(word, font) * scaleX;
            const wordLeft = currentX;
            const wordRight = currentX + wordWidth;
            const wordCenterX = wordLeft + wordWidth / 2;

            // Check if this word overlaps with selection
            if (wordRight > selLeft && wordLeft < selRight) {
                const distance = Math.abs(wordCenterX - selCenterX);
                if (distance < bestDistance) {
                    bestDistance = distance;
                    bestWord = word.trim();
                }
            }

            currentX += wordWidth;
        }
    });

    console.log('Best word found:', bestWord);
    return bestWord || '';
}

// Open translation popup with text
function openTranslationPopup(text, x, y) {
    translationPopup.style.left = Math.min(x, window.innerWidth - 320) + 'px';
    translationPopup.style.top = Math.min(y + 10, window.innerHeight - 250) + 'px';
    translationPopup.style.transform = '';
    translationPopup.classList.remove('d-none');

    originalInput.value = text;
    translationDiv.innerHTML = '<span class="text-muted">Klicke auf "Übersetzen"</span>';
    currentTranslation = '';
    originalInput.focus();
    originalInput.select();
}

// Reset transform when closing popup
document.getElementById('closePopup').addEventListener('click', () => {
    translationPopup.style.transform = '';
});

// ============================================
// Marker Mode - Click handler (pdfContainer now defined)
// ============================================
pdfContainer.addEventListener('click', (e) => {
    if (!markerMode) return;

    // Find which page was clicked
    const pages = document.querySelectorAll('.pdf-page');
    let targetPage = null;
    let pageNum = 1;

    for (const page of pages) {
        const pageRect = page.getBoundingClientRect();
        if (e.clientY >= pageRect.top && e.clientY <= pageRect.bottom &&
            e.clientX >= pageRect.left && e.clientX <= pageRect.right) {
            targetPage = page;
            pageNum = parseInt(page.dataset.page);
            break;
        }
    }

    if (!targetPage) return;

    const pageRect = targetPage.getBoundingClientRect();

    // Calculate relative position (0-1 range for portability)
    const relX = (e.clientX - pageRect.left) / pageRect.width;
    const relY = (e.clientY - pageRect.top) / pageRect.height;

    // Store pending marker
    pendingMarker = {
        page: pageNum,
        x: relX,
        y: relY
    };

    // Update UI
    document.getElementById('markerInfo').classList.remove('d-none');
    document.getElementById('clearMarker').style.display = 'inline-block';
    document.getElementById('notePageRef').textContent = pageNum;

    // Show temporary marker
    showTempMarker(targetPage, relX, relY);

    // Exit marker mode
    exitMarkerMode();

    // Focus on note input
    document.getElementById('newNoteContent').focus();
});

// Save Highlight
document.getElementById('saveHighlight').addEventListener('click', async () => {
    const original = originalInput.value.trim();
    const translation = currentTranslation;

    if (!original || !translation) {
        alert('Bitte zuerst übersetzen');
        return;
    }

    try {
        const response = await fetch(`/learnloom/api/highlights/${bookId}/save/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken
            },
            body: JSON.stringify({
                original_text: original,
                translated_text: translation,
                page_number: currentPage,
                position_data: selectionPosition,
                add_to_vocabulary: true
            })
        });

        const data = await response.json();
        if (data.success) {
            translationPopup.classList.add('d-none');
            // Add to local highlights array and render
            highlights.push({
                id: data.highlight.id,
                original_text: original,
                translated_text: translation,
                page_number: currentPage,
                position_data: selectionPosition
            });
            // Re-render highlights for ALL pages
            renderAllHighlights();
        }
    } catch (error) {
        console.error('Error saving highlight:', error);
    }
});

// Render highlights for a specific page
function renderHighlightsForPage(pageNum) {
    const pageDiv = document.querySelector(`.pdf-page[data-page="${pageNum}"]`);
    if (!pageDiv) return;

    const textLayer = pageDiv.querySelector('.textLayer');
    if (!textLayer) return;

    // Remove existing highlight overlays
    pageDiv.querySelectorAll('.highlight-overlay').forEach(el => el.remove());

    // Search ALL highlights on this page (not just highlights saved on this page)
    highlights.forEach(highlight => {
        const searchText = highlight.original_text.toLowerCase().trim().replace(/\s+/g, ' ');
        const spans = textLayer.querySelectorAll('span');

        // Find ALL occurrences and highlight them
        for (const span of spans) {
            const spanText = span.textContent;
            const spanTextLower = spanText.toLowerCase();
            let searchIndex = 0;

            // Find all occurrences in this span
            while ((searchIndex = spanTextLower.indexOf(searchText, searchIndex)) !== -1) {
                createWordHighlight(span, searchIndex, searchText.length, highlight, pageDiv);
                searchIndex += searchText.length;
            }
        }
    });
}

// Measure text width accurately using canvas
const measureCanvas = document.createElement('canvas');
const measureCtx = measureCanvas.getContext('2d');

function measureTextWidth(text, font) {
    measureCtx.font = font;
    return measureCtx.measureText(text).width;
}

// Create highlight for a specific word within a span
function createWordHighlight(span, charIndex, charLength, highlight, pageDiv) {
    const spanRect = span.getBoundingClientRect();
    const pageRect = pageDiv.getBoundingClientRect();
    const spanText = span.textContent;

    // Get computed font for accurate measurement
    const computedStyle = window.getComputedStyle(span);
    const font = `${computedStyle.fontSize} ${computedStyle.fontFamily}`;

    // Calculate relative position within span using accurate text measurement
    const textBefore = spanText.substring(0, charIndex);
    const targetText = spanText.substring(charIndex, charIndex + charLength);

    // Measure text widths
    const beforeWidth = measureTextWidth(textBefore, font);
    const targetWidth = measureTextWidth(targetText, font);

    // Account for any transform/scale on the span
    const scaleX = spanRect.width / measureTextWidth(spanText, font) || 1;

    // Calculate word position and size
    const wordLeft = spanRect.left - pageRect.left + (beforeWidth * scaleX);
    const wordWidth = targetWidth * scaleX;
    const wordTop = spanRect.top - pageRect.top;
    const wordHeight = spanRect.height;

    // Create highlight overlay
    const overlay = document.createElement('div');
    overlay.className = 'highlight-overlay';
    overlay.style.left = wordLeft + 'px';
    overlay.style.top = wordTop + 'px';
    overlay.style.width = wordWidth + 'px';
    overlay.style.height = wordHeight + 'px';

    overlay.dataset.highlightId = highlight.id;
    overlay.title = `${highlight.original_text} → ${highlight.translated_text}`;

    // Add hover tooltip
    overlay.addEventListener('mouseenter', (e) => {
        showHighlightTooltip(e, highlight);
    });
    overlay.addEventListener('mouseleave', hideHighlightTooltip);

    pageDiv.appendChild(overlay);
}

// Tooltip for highlights
let highlightTooltip = null;

function showHighlightTooltip(e, highlight) {
    if (!highlightTooltip) {
        highlightTooltip = document.createElement('div');
        highlightTooltip.className = 'highlight-tooltip-popup';
        highlightTooltip.style.cssText = `
            position: fixed;
            background: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 13px;
            z-index: 2500;
            max-width: 300px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        `;
        document.body.appendChild(highlightTooltip);
    }

    highlightTooltip.innerHTML = `
        <div style="font-weight: 500; margin-bottom: 4px;">${highlight.original_text}</div>
        <div style="color: #74b9ff;">→ ${highlight.translated_text}</div>
    `;
    highlightTooltip.style.left = e.clientX + 10 + 'px';
    highlightTooltip.style.top = e.clientY + 10 + 'px';
    highlightTooltip.style.display = 'block';
}

function hideHighlightTooltip() {
    if (highlightTooltip) {
        highlightTooltip.style.display = 'none';
    }
}

// Render all highlights after pages are loaded
function renderAllHighlights() {
    for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
        renderHighlightsForPage(pageNum);
    }
}

// ============================================
// Explanation Highlight Rendering (Green)
// ============================================

function createExplanationHighlight(span, charIndex, charLength, explanation, pageDiv) {
    const spanRect = span.getBoundingClientRect();
    const pageRect = pageDiv.getBoundingClientRect();
    const spanText = span.textContent;

    const computedStyle = window.getComputedStyle(span);
    const font = `${computedStyle.fontSize} ${computedStyle.fontFamily}`;

    const textBefore = spanText.substring(0, charIndex);
    const targetText = spanText.substring(charIndex, charIndex + charLength);

    const beforeWidth = measureTextWidth(textBefore, font);
    const targetWidth = measureTextWidth(targetText, font);
    const scaleX = spanRect.width / measureTextWidth(spanText, font) || 1;

    const wordLeft = spanRect.left - pageRect.left + (beforeWidth * scaleX);
    const wordWidth = targetWidth * scaleX;
    const wordTop = spanRect.top - pageRect.top;
    const wordHeight = spanRect.height;

    const overlay = document.createElement('div');
    overlay.className = 'explanation-overlay';
    overlay.style.left = wordLeft + 'px';
    overlay.style.top = wordTop + 'px';
    overlay.style.width = wordWidth + 'px';
    overlay.style.height = wordHeight + 'px';

    overlay.dataset.explanationId = explanation.id;
    overlay.title = explanation.selected_text;

    overlay.addEventListener('mouseenter', (e) => {
        showExplanationTooltip(e, explanation);
    });
    overlay.addEventListener('mouseleave', hideExplanationTooltip);

    pageDiv.appendChild(overlay);
}

let explanationTooltip = null;

function showExplanationTooltip(e, explanation) {
    if (!explanationTooltip) {
        explanationTooltip = document.createElement('div');
        explanationTooltip.className = 'explanation-tooltip-popup';
        explanationTooltip.style.cssText = `
            position: fixed;
            background: #166534;
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 13px;
            z-index: 2500;
            max-width: 350px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        `;
        document.body.appendChild(explanationTooltip);
    }

    explanationTooltip.innerHTML = `
        <div style="font-weight: 600; margin-bottom: 8px; color: #86efac;">
            <i class="bi bi-lightbulb me-1"></i>${explanation.selected_text.substring(0, 50)}${explanation.selected_text.length > 50 ? '...' : ''}
        </div>
        <div style="line-height: 1.5;">${explanation.explanation}</div>
    `;
    explanationTooltip.style.left = Math.min(e.clientX + 10, window.innerWidth - 370) + 'px';
    explanationTooltip.style.top = e.clientY + 10 + 'px';
    explanationTooltip.style.display = 'block';
}

function hideExplanationTooltip() {
    if (explanationTooltip) {
        explanationTooltip.style.display = 'none';
    }
}

function renderExplanationsForPage(pageNum) {
    const pageDiv = document.querySelector(`.pdf-page[data-page="${pageNum}"]`);
    if (!pageDiv) return;

    const textLayer = pageDiv.querySelector('.textLayer');
    if (!textLayer) return;

    // Remove existing explanation overlays for this page
    pageDiv.querySelectorAll('.explanation-overlay').forEach(el => el.remove());

    const pageExplanations = explanations.filter(exp => exp.page_number === pageNum);
    if (pageExplanations.length === 0) return;

    const spans = textLayer.querySelectorAll('span');

    for (const explanation of pageExplanations) {
        const searchText = explanation.selected_text.toLowerCase();

        for (const span of spans) {
            const spanText = span.textContent.toLowerCase();
            let charIndex = 0;

            while ((charIndex = spanText.indexOf(searchText, charIndex)) !== -1) {
                createExplanationHighlight(span, charIndex, searchText.length, explanation, pageDiv);
                charIndex += searchText.length;
            }
        }
    }
}

function renderAllExplanations() {
    for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
        renderExplanationsForPage(pageNum);
    }
}

// Text-to-Speech
function speak(text, lang) {
    const utterance = new SpeechSynthesisUtterance(text);
    utterance.lang = lang === 'en' ? 'en-US' : 'de-DE';
    utterance.rate = 0.9;
    window.speechSynthesis.speak(utterance);
}

document.getElementById('speakOriginal').addEventListener('click', () => {
    const text = originalInput.value.trim();
    if (text) speak(text, 'en');
});

document.getElementById('speakTranslation').addEventListener('click', () => {
    if (currentTranslation) {
        speak(currentTranslation, 'de');
    }
});

// Save progress on page unload
window.addEventListener('beforeunload', () => {
    fetch(`/learnloom/api/progress/${bookId}/save/`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrfToken
        },
        body: JSON.stringify({
            current_page: currentPage,
            zoom_level: scale
        }),
        keepalive: true
    });
});

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
    // Ignore if typing in textarea
    if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT') return;

    if (e.key === 'ArrowLeft') {
        document.getElementById('prevPage').click();
    } else if (e.key === 'ArrowRight') {
        document.getElementById('nextPage').click();
    } else if (e.key === '+' || e.key === '=') {
        document.getElementById('zoomIn').click();
    } else if (e.key === '-') {
        document.getElementById('zoomOut').click();
    } else if (e.key === 'Escape') {
        translationPopup.classList.add('d-none');
        translateBtn.classList.add('d-none');
        notesPanel.classList.remove('open');
    }
});

// ============================================
// Summary Panel
// ============================================
const summaryPanel = document.getElementById('summaryPanel');
const pdfCanvasContainer = document.getElementById('pdfCanvasContainer');

document.getElementById('toggleSummaryPanel').addEventListener('click', async () => {
    const isOpen = summaryPanel.classList.toggle('open');
    if (isOpen) {
        pdfCanvasContainer.classList.add('panel-open');
        loadSummary();
        // Warte kurz und skaliere PDF neu
        setTimeout(() => recalculateAndRender(380, true), 400);
    } else {
        pdfCanvasContainer.classList.remove('panel-open');
        // Zurück zur vollen Breite
        setTimeout(() => recalculateAndRender(0, true), 400);
    }
});

document.getElementById('closeSummaryPanel').addEventListener('click', () => {
    summaryPanel.classList.remove('open');
    pdfCanvasContainer.classList.remove('panel-open');
    setTimeout(() => recalculateAndRender(0, true), 400);
});

// Funktion um PDF für verfügbaren Platz neu zu skalieren
async function recalculateAndRender(panelWidth, forceRecalculate = false) {
    if (!pdfDoc) return;
    
    // If user manually zoomed and not forcing, don't auto-adjust
    if (userHasZoomed && !forceRecalculate) {
        console.log('User has manually zoomed, skipping auto-fit');
        return;
    }
    
    try {
        const firstPage = await pdfDoc.getPage(1);
        const defaultViewport = firstPage.getViewport({ scale: 1.0 });
        
        // DIREKT den Container messen nach CSS-Änderung
        const container = document.getElementById('pdfCanvasContainer');
        const style = getComputedStyle(container);
        const containerWidth = container.clientWidth; // content + padding, ohne scrollbar
        const paddingLeft = parseFloat(style.paddingLeft) || 0;
        const paddingRight = parseFloat(style.paddingRight) || 0;
        
        // Verfügbare Breite = clientWidth minus Padding (clientWidth inkludiert Padding)
        const availableWidth = containerWidth - paddingLeft - paddingRight;
        
        console.log('recalculateAndRender:', {
            containerWidth,
            paddingLeft,
            paddingRight,
            availableWidth, 
            pdfNaturalWidth: defaultViewport.width
        });
        
        // Neue optimale Skalierung
        const newScale = Math.min(4, Math.max(0.5, availableWidth / defaultViewport.width));
        
        scale = newScale;
        userHasZoomed = false; // Reset nach Panel-Wechsel
        document.getElementById('zoomLevel').value = Math.round(scale * 100) + '%';
        
        // Seiten neu rendern
        await renderAllPages();
    } catch (error) {
        console.error('Error recalculating scale:', error);
    }
}

async function loadSummary() {
    const loading = document.getElementById('summaryLoading');
    const content = document.getElementById('summaryContent');
    const empty = document.getElementById('summaryEmpty');
    
    loading.style.display = 'block';
    content.style.display = 'none';
    empty.style.display = 'none';
    
    try {
        const response = await fetch(`/learnloom/api/summary/${bookId}/`);
        const data = await response.json();
        
        loading.style.display = 'none';
        
        if (data.success && data.has_summary) {
            content.style.display = 'block';
            renderSummary(data.summary);
        } else {
            empty.style.display = 'block';
        }
    } catch (error) {
        console.error('Error loading summary:', error);
        loading.style.display = 'none';
        empty.style.display = 'block';
    }
}

function renderSummary(summary) {
    const content = document.getElementById('summaryContent');
    
    // Kurze Zusammenfassung verwenden (eigenes Feld)
    const shortText = summary.short_summary || 'Keine Kurzzusammenfassung verfügbar.';
    
    let html = `
        <div class="summary-text mb-3">${shortText}</div>
        <a href="/learnloom/summary/${bookId}/" class="btn btn-outline-primary btn-sm mb-4">
            <i class="bi bi-box-arrow-up-right me-1"></i>Ausführliche Zusammenfassung
        </a>
    `;
    
    if (summary.sections && summary.sections.length > 0) {
        html += '<h6 class="text-muted mb-3"><i class="bi bi-list-columns-reverse me-2"></i>Abschnitte</h6>';
        summary.sections.forEach((section, index) => {
            const hasText = section.text && section.text.trim().length > 0;
            html += `
                <div class="summary-section" data-section-index="${index}">
                    <div class="summary-section-header" onclick="scrollToPage(${section.start_page})" style="cursor: pointer;">
                        <div class="summary-section-title">${section.title}</div>
                        <div class="summary-section-pages">
                            <i class="bi bi-file-earmark me-1"></i>
                            ${section.start_page === section.end_page ? 'Seite ' + section.start_page : 'Seite ' + section.start_page + '-' + section.end_page}
                        </div>
                    </div>
                    <div class="summary-section-text" id="section-text-${index}" style="${hasText ? '' : 'display: none;'}">
                        ${hasText ? section.text : ''}
                    </div>
                    <div class="summary-section-actions mt-2">
                        <button class="btn btn-sm btn-outline-primary summarize-section-btn" 
                                data-index="${index}"
                                data-title="${section.title}"
                                data-start="${section.start_page}"
                                data-end="${section.end_page}"
                                ${hasText ? 'style="display: none;"' : ''}>
                            <i class="bi bi-magic me-1"></i>Zusammenfassen
                        </button>
                        <span class="summarizing-spinner d-none" id="spinner-${index}">
                            <span class="spinner-border spinner-border-sm me-1"></span>Generiere...
                        </span>
                    </div>
                </div>
            `;
        });
    }
    
    content.innerHTML = html;
}

// Generate Summary Button
const generateBtn = document.getElementById('generateSummaryBtn');
if (generateBtn) {
    generateBtn.addEventListener('click', async () => {
        generateBtn.disabled = true;
        generateBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>Generiere...';
        
        try {
            const response = await fetch(`/learnloom/api/summary/${bookId}/generate/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrfToken,
                },
                body: JSON.stringify({ provider: 'openai', language: 'de' })
            });
            
            const data = await response.json();
            
            if (data.success) {
                loadSummary();
            } else {
                alert('Fehler: ' + data.error);
            }
        } catch (error) {
            alert('Fehler beim Generieren: ' + error.message);
        } finally {
            generateBtn.disabled = false;
            generateBtn.innerHTML = '<i class="bi bi-magic me-2"></i>Jetzt generieren';
        }
    });
}

// Section Summarize Buttons (event delegation)
document.getElementById('summaryContent').addEventListener('click', async (e) => {
    const btn = e.target.closest('.summarize-section-btn');
    if (!btn) return;
    
    const index = btn.dataset.index;
    const title = btn.dataset.title;
    const startPage = parseInt(btn.dataset.start);
    const endPage = parseInt(btn.dataset.end);
    
    const spinner = document.getElementById(`spinner-${index}`);
    const textDiv = document.getElementById(`section-text-${index}`);
    
    // UI: Loading state
    btn.style.display = 'none';
    spinner.classList.remove('d-none');
    
    try {
        const response = await fetch(`/learnloom/api/summary/${bookId}/section/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken,
            },
            body: JSON.stringify({
                start_page: startPage,
                end_page: endPage,
                title: title,
                section_index: parseInt(index),
                provider: 'openai',
                language: 'de'
            })
        });
        
        const data = await response.json();
        
        if (data.success) {
            textDiv.textContent = data.summary;
            textDiv.style.display = 'block';
            spinner.classList.add('d-none');
            // Button bleibt versteckt
        } else {
            alert('Fehler: ' + data.error);
            btn.style.display = '';
            spinner.classList.add('d-none');
        }
    } catch (error) {
        alert('Fehler beim Zusammenfassen: ' + error.message);
        btn.style.display = '';
        spinner.classList.add('d-none');
    }
});

// ============================================
// Dock Explanation Panel
// ============================================
let isExplanationDocked = false;

document.getElementById('dockExplanationBtn').addEventListener('click', () => {
    const popup = document.getElementById('explanationPopup');
    const dockBtn = document.getElementById('dockExplanationBtn');
    
    isExplanationDocked = !isExplanationDocked;
    
    if (isExplanationDocked) {
        popup.classList.add('docked');
        popup.classList.remove('fullscreen');
        pdfCanvasContainer.classList.add('panel-open');
        dockBtn.innerHTML = '<i class="bi bi-pip"></i>';
        dockBtn.title = 'Als Popup lösen';
        // Close summary panel if open
        summaryPanel.classList.remove('open');
        // PDF neu skalieren
        setTimeout(() => recalculateAndRender(400, true), 400);
    } else {
        popup.classList.remove('docked');
        pdfCanvasContainer.classList.remove('panel-open');
        dockBtn.innerHTML = '<i class="bi bi-layout-sidebar-reverse"></i>';
        dockBtn.title = 'Rechts andocken';
        // Reset position
        popup.style.left = '50%';
        popup.style.top = '50%';
        popup.style.transform = 'translate(-50%, -50%)';
        // PDF zurück skalieren
        setTimeout(() => recalculateAndRender(0, true), 400);
    }
});

// Update close handler to also undock
document.getElementById('closeExplanationPopup').addEventListener('click', () => {
    if (isExplanationDocked) {
        pdfCanvasContainer.classList.remove('panel-open');
        isExplanationDocked = false;
        const dockBtn = document.getElementById('dockExplanationBtn');
        dockBtn.innerHTML = '<i class="bi bi-layout-sidebar-reverse"></i>';
        dockBtn.title = 'Rechts andocken';
        // PDF zurück skalieren
        setTimeout(() => recalculateAndRender(0, true), 400);
    }
});

// Initialize
document.getElementById('zoomLevel').value = Math.round(scale * 100) + '%';
loadPDF();
</script>
{% endblock %}
