{% extends 'base.html' %}

{% block title %}{{ board.title }} - Ideenboard{% endblock %}

{% block content %}
<div class="container-fluid mt-4">
    <div class="row">
        <div class="col-12">
            <div class="d-flex justify-content-between align-items-center mb-4">
                <h1>{{ board.title }}</h1>
                <div>
                    <!-- Board Audio Button -->
                    <button type="button" id="audio-toggle-btn" class="btn btn-outline-success me-2">
                        <i class="fas fa-microphone-slash" id="audio-icon"></i>
                        <span id="audio-text">Audio beitreten</span>
                        <span id="audio-participants" class="badge bg-secondary ms-1" style="display: none;">0</span>
                    </button>

                    {% if board.creator == request.user %}
                        <button type="button" class="btn btn-info me-2" data-bs-toggle="modal" data-bs-target="#inviteModal">
                            <i class="fas fa-user-plus"></i> Personen einladen
                        </button>
                    {% endif %}
                    <a href="{% url 'organization:board_list' %}" class="btn btn-secondary">Zurück zur Liste</a>
                </div>
            </div>
            
            {% if board.description %}
                <p class="text-muted mb-4">{{ board.description }}</p>
            {% endif %}
        </div>
    </div>
    
    <div class="row">
        <div class="col-12 col-lg-2">
            <!-- Werkzeuge -->
            <div class="card">
                <div class="card-header d-lg-block d-none">
                    <h5>Werkzeuge</h5>
                </div>
                <div class="card-body p-2">
                    <div class="btn-group-vertical btn-group-horizontal-mobile w-100" role="group">
                        <button type="button" class="btn btn-outline-primary tool-btn active" data-tool="select">
                            <i class="fas fa-mouse-pointer"></i> Auswählen
                        </button>
                        <button type="button" class="btn btn-outline-primary tool-btn" data-tool="pen">
                            <i class="fas fa-pen"></i> Stift
                        </button>
                        <button type="button" class="btn btn-outline-primary tool-btn" data-tool="brush">
                            <i class="fas fa-brush"></i> Pinsel
                        </button>
                        <button type="button" class="btn btn-outline-primary tool-btn" data-tool="text">
                            <i class="fas fa-font"></i> Text
                        </button>
                        <button type="button" class="btn btn-outline-primary tool-btn" data-tool="rectangle">
                            <i class="fas fa-square"></i> Rechteck
                        </button>
                        <button type="button" class="btn btn-outline-primary tool-btn" data-tool="circle">
                            <i class="fas fa-circle"></i> Kreis
                        </button>
                        <button type="button" class="btn btn-outline-primary tool-btn" data-tool="triangle">
                            <i class="fas fa-play"></i> Dreieck
                        </button>
                        <button type="button" class="btn btn-outline-primary tool-btn" data-tool="line">
                            <i class="fas fa-minus"></i> Linie
                        </button>
                        <button type="button" class="btn btn-outline-primary tool-btn" data-tool="arrow">
                            <i class="fas fa-arrow-right"></i> Pfeil
                        </button>
                    </div>
                    
                    <hr>
                    
                    <!-- Farben -->
                    <div class="mb-3">
                        <label class="form-label">Farbe</label>
                        <input type="color" class="form-control form-control-color" id="color-picker" value="#000000">
                    </div>
                    
                    <!-- Strichstärke -->
                    <div class="mb-3">
                        <label class="form-label">Strichstärke</label>
                        <input type="range" class="form-range" id="stroke-width" min="1" max="20" value="2">
                        <span id="stroke-width-value">2</span>px
                    </div>
                    
                    <!-- Transparenz -->
                    <div class="mb-3">
                        <label class="form-label">Transparenz</label>
                        <input type="range" class="form-range" id="opacity" min="0" max="100" value="100">
                        <span id="opacity-value">100</span>%
                    </div>
                    
                    <hr>
                    
                    <button type="button" class="btn btn-warning btn-sm mb-2" id="clear-canvas">
                        <i class="fas fa-trash"></i> Canvas löschen
                    </button>
                    
                    <button type="button" class="btn btn-success btn-sm" id="save-board">
                        <i class="fas fa-save"></i> Speichern
                    </button>
                </div>
            </div>
        </div>
        
        <div class="col-12 col-lg-10">
            <!-- Canvas -->
            <div class="card">
                <div class="card-body p-0">
                    <div id="canvas-container" style="position: relative; overflow: hidden;">
                        <!-- Undo Button - Top Right -->
                        <div style="position: absolute; top: 10px; right: 10px; z-index: 10;">
                            <button type="button" class="btn btn-secondary btn-sm" id="undo-action">
                                <i class="fas fa-undo"></i> Rückgängig
                            </button>
                        </div>
                        
                        <!-- Zoom Controls - Top Left -->
                        <div style="position: absolute; top: 10px; left: 10px; z-index: 10;">
                            <div class="btn-group-vertical" role="group">
                                <button type="button" class="btn btn-outline-secondary btn-sm" id="zoom-in">
                                    <i class="fas fa-plus"></i>
                                </button>
                                <button type="button" class="btn btn-outline-secondary btn-sm" id="hand-tool" title="Board verschieben">
                                    <i class="fas fa-hand-paper"></i>
                                </button>
                                <button type="button" class="btn btn-outline-secondary btn-sm" id="zoom-out">
                                    <i class="fas fa-minus"></i>
                                </button>
                            </div>
                        </div>
                        
                        <!-- Navigation Controls - Bottom Right -->
                        <div style="position: absolute; bottom: 10px; right: 10px; z-index: 10;">
                            <div class="d-grid" style="grid-template-columns: repeat(3, 1fr); gap: 2px; width: 90px;">
                                <div></div>
                                <button type="button" class="btn btn-outline-secondary btn-sm" id="nav-up">
                                    <i class="fas fa-arrow-up"></i>
                                </button>
                                <div></div>
                                <button type="button" class="btn btn-outline-secondary btn-sm" id="nav-left">
                                    <i class="fas fa-arrow-left"></i>
                                </button>
                                <button type="button" class="btn btn-outline-secondary btn-sm" id="nav-center">
                                    <i class="fas fa-dot-circle"></i>
                                </button>
                                <button type="button" class="btn btn-outline-secondary btn-sm" id="nav-right">
                                    <i class="fas fa-arrow-right"></i>
                                </button>
                                <div></div>
                                <button type="button" class="btn btn-outline-secondary btn-sm" id="nav-down">
                                    <i class="fas fa-arrow-down"></i>
                                </button>
                                <div></div>
                            </div>
                        </div>
                        
                        <canvas id="drawing-canvas" 
                                width="{{ board.width }}" 
                                height="{{ board.height }}" 
                                style="border: 1px solid #dee2e6; background-color: {{ board.background_color }}; max-width: 100%; height: auto; cursor: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTMgM0w5IDE5TDEyIDE1TDE5IDEySjMgM1oiIGZpbGw9IiMwMDAiIHN0cm9rZT0iI2ZmZiIgc3Ryb2tlLXdpZHRoPSIxIi8+Cjwvc3ZnPg==) 3 3, pointer;">
                        </canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Modal für Personen einladen -->
<div class="modal fade" id="inviteModal" tabindex="-1" aria-labelledby="inviteModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="inviteModalLabel">Personen zu Board einladen</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <form id="inviteForm">
                    <div class="mb-3">
                        <label for="userSearch" class="form-label">Benutzer suchen</label>
                        <input type="text" class="form-control" id="userSearch" placeholder="Benutzername oder Name eingeben...">
                        <div id="searchResults" class="mt-2"></div>
                    </div>
                    
                    <div class="mb-3">
                        <label class="form-label">Aktuelle Mitarbeiter</label>
                        <div id="currentCollaborators">
                            {% for collaborator in board.collaborators.all %}
                                <span class="badge bg-secondary me-1" data-user-id="{{ collaborator.id }}">
                                    {{ collaborator.username }}
                                    <button type="button" class="btn-close btn-close-white ms-1" style="font-size: 0.7em;" onclick="removeCollaborator({{ collaborator.id }})"></button>
                                </span>
                            {% endfor %}
                        </div>
                    </div>
                    
                    <div class="mb-3">
                        <label class="form-label">Neue Mitarbeiter</label>
                        <div id="newCollaborators"></div>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Abbrechen</button>
                <button type="button" class="btn btn-primary" onclick="saveInvitations()">Einladungen senden</button>
            </div>
        </div>
    </div>
</div>

<script>
class IdeaBoard {
    constructor() {
        console.log('IdeaBoard constructor starting...');

        this.canvas = document.getElementById('drawing-canvas');
        if (!this.canvas) {
            console.error('Canvas not found!');
            return;
        }

        this.ctx = this.canvas.getContext('2d');
        this.isDrawing = false;
        this.currentTool = 'select';
        this.currentColor = '#000000';
        this.currentStrokeWidth = 2;
        this.currentOpacity = 1.0;
        this.startX = 0;
        this.startY = 0;
        this.elements = [];
        this.currentPath = [];
        this.selectedElement = null;
        this.isDragging = false;
        this.isResizing = false;
        this.resizeHandle = null;
        this.dragOffset = {x: 0, y: 0};

        // Performance optimization variables
        this.isDragActive = false;
        this.pendingUpdate = null;
        this.updateTimeout = null;
        this.debouncedUpdateDelay = 150; // ms
        this.pollingPaused = false;
        this.redrawScheduled = false;

        // Zoom and pan variables
        this.zoomLevel = 1;
        this.panX = 0;
        this.panY = 0;
        this.handToolActive = false;
        this.isPanning = false;
        this.lastPanX = 0;
        this.lastPanY = 0;
        
        console.log('Calling initEventListeners...');
        this.initEventListeners();
        
        console.log('Loading existing elements...');
        this.loadExistingElements();
        
        console.log('Setting up polling...');
        this.setupPolling();
        
        // Set initial cursor for default tool (select)
        this.updateCursor();
        
        console.log('IdeaBoard constructor completed');
    }
    
    initEventListeners() {
        console.log('initEventListeners called');
        
        // Canvas Events - Mouse
        this.canvas.addEventListener('mousedown', (e) => this.startDrawing(e));
        this.canvas.addEventListener('mousemove', (e) => this.draw(e));
        this.canvas.addEventListener('mouseup', (e) => this.stopDrawing(e));
        this.canvas.addEventListener('mouseout', (e) => this.stopDrawing(e));
        
        // Canvas Events - Touch (for mobile)
        this.canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            this.startDrawing(mouseEvent);
        });
        
        this.canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousemove', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            this.draw(mouseEvent);
        });
        
        this.canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            const mouseEvent = new MouseEvent('mouseup', {});
            this.stopDrawing(mouseEvent);
        });
        
        // Tool Selection - Force event handling
        const toolButtons = document.querySelectorAll('.tool-btn');
        console.log('Found tool buttons:', toolButtons.length);
        
        toolButtons.forEach((btn, index) => {
            console.log(`Button ${index}:`, btn.getAttribute('data-tool'));
            
            // Remove any existing event listeners by cloning
            const newBtn = btn.cloneNode(true);
            btn.parentNode.replaceChild(newBtn, btn);
            
            newBtn.addEventListener('click', (e) => {
                console.log('Button clicked:', newBtn.getAttribute('data-tool'));
                
                // Remove active class from all buttons
                document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                
                // Add active class to clicked button
                newBtn.classList.add('active');
                
                // Set the tool
                this.currentTool = newBtn.getAttribute('data-tool');
                
                // Deactivate hand tool when any drawing tool is selected
                if (this.handToolActive) {
                    this.deactivateHandTool();
                }
                
                this.updateCursor();
                console.log('Tool set to:', this.currentTool);
                
                e.preventDefault();
                e.stopPropagation();
            }, true);
        });
        
        // Color Picker
        document.getElementById('color-picker').addEventListener('change', (e) => {
            this.currentColor = e.target.value;
        });
        
        // Stroke Width
        document.getElementById('stroke-width').addEventListener('input', (e) => {
            this.currentStrokeWidth = parseInt(e.target.value);
            document.getElementById('stroke-width-value').textContent = e.target.value;
        });
        
        // Opacity
        document.getElementById('opacity').addEventListener('input', (e) => {
            this.currentOpacity = parseFloat(e.target.value) / 100;
            document.getElementById('opacity-value').textContent = e.target.value;
        });
        
        // Undo Button
        document.getElementById('undo-action').addEventListener('click', () => {
            this.undoLastAction();
        });
        
        // Clear Canvas
        document.getElementById('clear-canvas').addEventListener('click', () => {
            if (confirm('Möchten Sie das Canvas wirklich löschen?')) {
                this.clearCanvas();
            }
        });
        
        // Save Board
        document.getElementById('save-board').addEventListener('click', () => {
            this.saveBoard();
        });
        
        // Zoom controls
        document.getElementById('zoom-in').addEventListener('click', () => {
            this.zoomIn();
        });
        
        document.getElementById('hand-tool').addEventListener('click', () => {
            this.toggleHandTool();
        });
        
        document.getElementById('zoom-out').addEventListener('click', () => {
            this.zoomOut();
        });
        
        // Navigation controls
        document.getElementById('nav-up').addEventListener('click', () => {
            this.panCanvas(0, -50);
        });
        
        document.getElementById('nav-down').addEventListener('click', () => {
            this.panCanvas(0, 50);
        });
        
        document.getElementById('nav-left').addEventListener('click', () => {
            this.panCanvas(-50, 0);
        });
        
        document.getElementById('nav-right').addEventListener('click', () => {
            this.panCanvas(50, 0);
        });
        
        document.getElementById('nav-center').addEventListener('click', () => {
            this.resetCanvasView();
        });
    }
    
    getCanvasCoordinates(e) {
        const rect = this.canvas.getBoundingClientRect();
        const scaleX = this.canvas.width / rect.width;
        const scaleY = this.canvas.height / rect.height;
        
        return {
            x: (e.clientX - rect.left) * scaleX,
            y: (e.clientY - rect.top) * scaleY
        };
    }
    
    startDrawing(e) {
        const coords = this.getCanvasCoordinates(e);
        this.startX = coords.x;
        this.startY = coords.y;
        
        // Handle hand tool panning
        if (this.handToolActive) {
            this.isPanning = true;
            this.lastPanX = e.clientX;
            this.lastPanY = e.clientY;
            this.canvas.style.cursor = 'grabbing';
            return;
        }
        
        if (this.currentTool === 'select') {
            this.handleSelection(this.startX, this.startY);
            return;
        }
        
        this.isDrawing = true;
        
        if (this.currentTool === 'pen' || this.currentTool === 'brush') {
            this.currentPath = [{x: this.startX, y: this.startY}];
        }
    }
    
    draw(e) {
        const coords = this.getCanvasCoordinates(e);
        const currentX = coords.x;
        const currentY = coords.y;
        
        // Handle hand tool panning
        if (this.isPanning && this.handToolActive) {
            const deltaX = e.clientX - this.lastPanX;
            const deltaY = e.clientY - this.lastPanY;
            
            this.panX += deltaX;
            this.panY += deltaY;
            this.applyCanvasTransform();
            
            this.lastPanX = e.clientX;
            this.lastPanY = e.clientY;
            return;
        }
        
        if (this.currentTool === 'select') {
            this.handleDragOrResize(currentX, currentY);
            return;
        }
        
        if (!this.isDrawing) return;
        
        this.ctx.globalAlpha = this.currentOpacity;
        this.ctx.strokeStyle = this.currentColor;
        this.ctx.fillStyle = this.currentColor;
        this.ctx.lineWidth = this.currentStrokeWidth;
        this.ctx.lineCap = 'round';
        this.ctx.lineJoin = 'round';
        
        // Temporäres Canvas für Vorschau bei Formen
        if (['rectangle', 'circle', 'triangle', 'line', 'arrow'].includes(this.currentTool)) {
            this.drawShapePreview(currentX, currentY);
            return;
        }

        switch (this.currentTool) {
            case 'pen':
            case 'brush':
                this.ctx.beginPath();
                this.ctx.moveTo(this.startX, this.startY);
                this.ctx.lineTo(currentX, currentY);
                this.ctx.stroke();
                this.currentPath.push({x: currentX, y: currentY});
                this.startX = currentX;
                this.startY = currentY;
                break;


            case 'text':
                // Text wird beim Klick hinzugefügt
                break;
        }
    }

    drawShapePreview(currentX, currentY) {
        // Redraw canvas
        this.redrawCanvas();
        
        // Draw preview
        this.ctx.globalAlpha = this.currentOpacity;
        this.ctx.strokeStyle = this.currentColor;
        this.ctx.fillStyle = this.currentColor;
        this.ctx.lineWidth = this.currentStrokeWidth;
        
        // Set consistent line rendering properties for preview
        this.ctx.lineCap = 'round';
        this.ctx.lineJoin = 'round';
        
        const width = currentX - this.startX;
        const height = currentY - this.startY;
        
        switch (this.currentTool) {
            case 'rectangle':
                this.ctx.strokeRect(this.startX, this.startY, width, height);
                break;
                
            case 'circle':
                const radius = Math.sqrt(width * width + height * height);
                this.ctx.beginPath();
                this.ctx.arc(this.startX, this.startY, radius, 0, 2 * Math.PI);
                this.ctx.stroke();
                break;
                
            case 'triangle':
                this.ctx.beginPath();
                this.ctx.moveTo(this.startX, this.startY);
                this.ctx.lineTo(currentX, currentY);
                this.ctx.lineTo(this.startX - width, currentY);
                this.ctx.closePath();
                this.ctx.stroke();
                break;
                
            case 'line':
                this.ctx.beginPath();
                this.ctx.moveTo(this.startX, this.startY);
                this.ctx.lineTo(currentX, currentY);
                this.ctx.stroke();
                break;
                
            case 'arrow':
                this.drawArrow(this.startX, this.startY, currentX, currentY);
                break;
        }
    }
    
    drawArrow(fromX, fromY, toX, toY) {
        const headLen = 10; // length of head in pixels
        const dx = toX - fromX;
        const dy = toY - fromY;
        const angle = Math.atan2(dy, dx);
        
        // Draw the line
        this.ctx.beginPath();
        this.ctx.moveTo(fromX, fromY);
        this.ctx.lineTo(toX, toY);
        this.ctx.stroke();
        
        // Draw the arrow head
        this.ctx.beginPath();
        this.ctx.moveTo(toX, toY);
        this.ctx.lineTo(toX - headLen * Math.cos(angle - Math.PI / 6), toY - headLen * Math.sin(angle - Math.PI / 6));
        this.ctx.moveTo(toX, toY);
        this.ctx.lineTo(toX - headLen * Math.cos(angle + Math.PI / 6), toY - headLen * Math.sin(angle + Math.PI / 6));
        this.ctx.stroke();
    }
    
    redrawCanvas() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Redraw all saved elements
        this.elements.forEach(element => {
            this.drawElement(element);
        });
        
        // Draw selection handles if an element is selected
        this.drawSelectionHandles();
    }
    
    drawElement(element) {
        // Handle opacity correctly - use 1.0 only if opacity is undefined, not if it's 0
        this.ctx.globalAlpha = element.opacity !== undefined ? element.opacity : 1.0;
        this.ctx.strokeStyle = element.color || '#000000';
        this.ctx.fillStyle = element.color || '#000000';
        this.ctx.lineWidth = element.stroke_width || 2;
        
        // Set consistent line rendering properties
        this.ctx.lineCap = 'round';
        this.ctx.lineJoin = 'round';
        
        // Apply rotation if present
        if (element.rotation && element.rotation !== 0) {
            const bounds = this.getElementBounds(element);
            const centerX = bounds.x + bounds.width / 2;
            const centerY = bounds.y + bounds.height / 2;
            
            
            this.ctx.save();
            this.ctx.translate(centerX, centerY);
            this.ctx.rotate(element.rotation * Math.PI / 180);
            this.ctx.translate(-centerX, -centerY);
        }
        
        const data = element.data;
        
        switch (element.element_type) {
            case 'rectangle':
                this.ctx.strokeRect(data.x, data.y, data.width, data.height);
                break;
                
            case 'circle':
                this.ctx.beginPath();
                this.ctx.arc(data.x, data.y, data.radius, 0, 2 * Math.PI);
                this.ctx.stroke();
                break;
                
            case 'triangle':
                this.ctx.beginPath();
                this.ctx.moveTo(data.x1, data.y1);
                this.ctx.lineTo(data.x2, data.y2);
                this.ctx.lineTo(data.x3, data.y3);
                this.ctx.closePath();
                this.ctx.stroke();
                break;
                
            case 'line':
                this.ctx.beginPath();
                this.ctx.moveTo(data.x1, data.y1);
                this.ctx.lineTo(data.x2, data.y2);
                this.ctx.stroke();
                break;
                
            case 'arrow':
                this.drawArrow(data.x1, data.y1, data.x2, data.y2);
                break;
                
            case 'freehand':
                if (data.path && data.path.length > 1) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(data.path[0].x, data.path[0].y);
                    for (let i = 1; i < data.path.length; i++) {
                        this.ctx.lineTo(data.path[i].x, data.path[i].y);
                    }
                    this.ctx.stroke();
                }
                break;
                
            case 'text':
                this.ctx.font = `${data.fontSize || 16}px Arial`;
                this.ctx.fillText(data.text, data.x, data.y);
                break;
        }
        
        // Restore transformation if rotation was applied
        if (element.rotation && element.rotation !== 0) {
            this.ctx.restore();
        }
    }
    
    stopDrawing(event) {
        // Handle hand tool panning
        if (this.isPanning && this.handToolActive) {
            this.isPanning = false;
            this.canvas.style.cursor = 'grab';
            return;
        }

        if (this.currentTool === 'select') {
            // End drag operation and resume polling
            if (this.isDragActive) {
                this.isDragActive = false;
                this.resumePolling();
                this.finalizePendingUpdate();
            }

            this.isDragging = false;
            this.isResizing = false;
            this.isRotating = false;
            this.resizeHandle = null;
            return;
        }
        
        if (!this.isDrawing) return;
        this.isDrawing = false;
        
        const coords = event ? this.getCanvasCoordinates(event) : {x: this.startX, y: this.startY};
        const endX = coords.x;
        const endY = coords.y;
        
        const width = endX - this.startX;
        const height = endY - this.startY;
        
        switch (this.currentTool) {
            case 'pen':
            case 'brush':
                this.saveElement('freehand', {
                    path: this.currentPath,
                    color: this.currentColor,
                    strokeWidth: this.currentStrokeWidth,
                    opacity: this.currentOpacity
                });
                break;
                
            case 'rectangle':
                if (Math.abs(width) > 5 && Math.abs(height) > 5) {
                    this.saveElement('rectangle', {
                        x: this.startX,
                        y: this.startY,
                        width: width,
                        height: height
                    });
                }
                break;
                
            case 'circle':
                const radius = Math.sqrt(width * width + height * height);
                if (radius > 5) {
                    this.saveElement('circle', {
                        x: this.startX,
                        y: this.startY,
                        radius: radius
                    });
                }
                break;
                
            case 'triangle':
                if (Math.abs(width) > 5 && Math.abs(height) > 5) {
                    this.saveElement('triangle', {
                        x1: this.startX,
                        y1: this.startY,
                        x2: endX,
                        y2: endY,
                        x3: this.startX - width,
                        y3: endY
                    });
                }
                break;
                
            case 'line':
                if (Math.abs(width) > 5 || Math.abs(height) > 5) {
                    this.saveElement('line', {
                        x1: this.startX,
                        y1: this.startY,
                        x2: endX,
                        y2: endY
                    });
                }
                break;
                
            case 'arrow':
                if (Math.abs(width) > 5 || Math.abs(height) > 5) {
                    this.saveElement('arrow', {
                        x1: this.startX,
                        y1: this.startY,
                        x2: endX,
                        y2: endY
                    });
                }
                break;
                
            case 'text':
                this.addText(this.startX, this.startY);
                break;
        }
    }
    
    addText(x, y) {
        const text = prompt('Text eingeben:');
        if (text && text.trim()) {
            this.saveElement('text', {
                text: text.trim(),
                x: x,
                y: y,
                fontSize: 16
            });
            
            // Sofort zeichnen
            this.ctx.globalAlpha = this.currentOpacity;
            this.ctx.fillStyle = this.currentColor;
            this.ctx.font = '16px Arial';
            this.ctx.fillText(text.trim(), x, y);
        }
    }
    
    saveElement(type, data) {
        const element = {
            element_type: type,
            data: data,
            position_x: this.startX,
            position_y: this.startY,
            color: this.currentColor,
            stroke_width: this.currentStrokeWidth,
            opacity: this.currentOpacity,
            rotation: 0, // Default rotation
            layer_index: this.elements.length
        };
        
        fetch(`/organization/boards/{{ board.pk }}/save-element/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': '{{ csrf_token }}'
            },
            body: JSON.stringify(element)
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                element.id = data.id;
                this.elements.push(element);
                this.lastUpdate = Date.now();
            }
        });
    }
    
    undoLastAction() {
        if (this.elements.length === 0) {
            alert('Keine Aktion zum Rückgängigmachen vorhanden');
            return;
        }
        
        // Get the last element
        const lastElement = this.elements[this.elements.length - 1];
        
        // Delete the last element from server
        fetch(`/organization/boards/{{ board.pk }}/elements/${lastElement.id}/delete/`, {
            method: 'DELETE',
            headers: {
                'X-CSRFToken': '{{ csrf_token }}',
                'Content-Type': 'application/json'
            }
        }).then(response => {
            if (response.ok) {
                // Remove from local array
                this.elements.pop();
                this.scheduleRedraw();
                // Force update check
                setTimeout(() => this.checkForUpdates(), 100);
            } else {
                alert('Fehler beim Rückgängigmachen');
            }
        }).catch(error => {
            console.error('Error undoing action:', error);
            alert('Fehler beim Rückgängigmachen');
        });
    }
    
    clearCanvas() {
        // Clear all elements on server
        fetch(`/organization/boards/{{ board.pk }}/clear-elements/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': '{{ csrf_token }}'
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                // Clear local canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.elements = [];
                // Force update for all users
                this.lastUpdate = 0;
                this.checkForUpdates();
            } else {
                alert('Fehler beim Löschen des Canvas');
            }
        })
        .catch(error => {
            console.error('Error clearing canvas:', error);
            alert('Fehler beim Löschen des Canvas');
        });
    }
    
    saveBoard() {
        alert('Board gespeichert!');
    }
    
    loadExistingElements() {
        fetch(`/organization/boards/{{ board.pk }}/elements/`)
            .then(response => response.json())
            .then(data => {
                this.elements = data.elements || [];
                // Ensure all loaded elements have position values
                this.elements.forEach(element => {
                    this.ensureElementPosition(element);
                });
                this.scheduleRedraw();
            })
            .catch(error => {
                console.error('Error loading elements:', error);
            });
    }
    
    handleSelection(x, y) {
        // Check if clicking on resize/rotate handle
        if (this.selectedElement) {
            const handle = this.getResizeHandle(x, y);
            if (handle) {
                if (handle === 'rotate') {
                    this.isRotating = true;
                    this.isDragActive = true;
                    this.pausePolling();
                    const bounds = this.getElementBounds(this.selectedElement);
                    this.rotationCenter = {
                        x: bounds.x + bounds.width / 2,
                        y: bounds.y + bounds.height / 2
                    };
                    this.initialAngle = Math.atan2(y - this.rotationCenter.y, x - this.rotationCenter.x);
                    this.selectedElement.rotation = this.selectedElement.rotation || 0;
                } else {
                    this.isResizing = true;
                    this.isDragActive = true;
                    this.pausePolling();
                    this.resizeHandle = handle;
                }
                return;
            }
        }

        // Check if clicking on existing element
        const clickedElement = this.getElementAt(x, y);

        if (clickedElement) {
            if (this.selectedElement !== clickedElement) {
                this.selectedElement = clickedElement;
                this.scheduleRedraw();
            }
            this.isDragging = true;
            this.isDragActive = true;
            this.pausePolling();

            // Ensure position_x and position_y exist and are correct
            this.ensureElementPosition(clickedElement);

            this.dragOffset = {
                x: x - clickedElement.position_x,
                y: y - clickedElement.position_y
            };

        } else {
            // Clicked on empty space - deselect
            this.selectedElement = null;
            this.scheduleRedraw();
        }
    }
    
    handleDragOrResize(x, y) {
        if (this.isRotating && this.selectedElement) {
            this.rotateElement(x, y);
        } else if (this.isResizing && this.selectedElement) {
            this.resizeElement(x, y);
        } else if (this.isDragging && this.selectedElement) {
            this.dragElement(x, y);
        }
    }
    
    getElementAt(x, y) {
        // Search from top to bottom (reverse order)
        for (let i = this.elements.length - 1; i >= 0; i--) {
            const element = this.elements[i];
            if (this.isPointInElement(x, y, element)) {
                return element;
            }
        }
        return null;
    }
    
    isPointInElement(x, y, element) {
        const data = element.data;
        
        switch (element.element_type) {
            case 'rectangle':
                return x >= data.x && x <= data.x + data.width &&
                       y >= data.y && y <= data.y + data.height;
            
            case 'circle':
                const dx = x - data.x;
                const dy = y - data.y;
                return (dx * dx + dy * dy) <= (data.radius * data.radius);
            
            case 'triangle':
                // Simple bounding box check for triangles
                const minX = Math.min(data.x1, data.x2, data.x3);
                const maxX = Math.max(data.x1, data.x2, data.x3);
                const minY = Math.min(data.y1, data.y2, data.y3);
                const maxY = Math.max(data.y1, data.y2, data.y3);
                return x >= minX && x <= maxX && y >= minY && y <= maxY;
            
            case 'line':
            case 'arrow':
                // Check if point is near line (within stroke width)
                const dist = this.distanceToLine(x, y, data.x1, data.y1, data.x2, data.y2);
                return dist <= (element.stroke_width || 2) + 5;
            
            case 'text':
                // Simple bounding box for text
                const fontSize = data.fontSize || 16;
                this.ctx.font = `${fontSize}px Arial`;
                const textWidth = this.ctx.measureText(data.text).width;
                return x >= data.x && x <= data.x + textWidth &&
                       y >= data.y - fontSize && y <= data.y;
            
            case 'freehand':
                // Check if point is near any point in the path
                for (let point of data.path) {
                    const dx = x - point.x;
                    const dy = y - point.y;
                    if (Math.sqrt(dx * dx + dy * dy) <= (element.stroke_width || 2) + 3) {
                        return true;
                    }
                }
                return false;
        }
        return false;
    }
    
    distanceToLine(px, py, x1, y1, x2, y2) {
        const A = px - x1;
        const B = py - y1;
        const C = x2 - x1;
        const D = y2 - y1;
        
        const dot = A * C + B * D;
        const lenSq = C * C + D * D;
        let param = -1;
        if (lenSq !== 0) {
            param = dot / lenSq;
        }
        
        let xx, yy;
        if (param < 0) {
            xx = x1;
            yy = y1;
        } else if (param > 1) {
            xx = x2;
            yy = y2;
        } else {
            xx = x1 + param * C;
            yy = y1 + param * D;
        }
        
        const dx = px - xx;
        const dy = py - yy;
        return Math.sqrt(dx * dx + dy * dy);
    }
    
    dragElement(x, y) {
        if (!this.selectedElement) return;

        const newX = x - this.dragOffset.x;
        const newY = y - this.dragOffset.y;

        // Calculate delta before updating position
        const deltaX = newX - this.selectedElement.position_x;
        const deltaY = newY - this.selectedElement.position_y;

        this.selectedElement.position_x = newX;
        this.selectedElement.position_y = newY;

        // Update data based on element type
        const data = this.selectedElement.data;

        switch (this.selectedElement.element_type) {
            case 'rectangle':
                data.x = newX;
                data.y = newY;
                break;
            case 'circle':
                data.x = newX;
                data.y = newY;
                break;
            case 'text':
                data.x = newX;
                data.y = newY;
                break;
            case 'line':
            case 'arrow':
                data.x1 += deltaX;
                data.y1 += deltaY;
                data.x2 += deltaX;
                data.y2 += deltaY;
                break;
            case 'triangle':
                data.x1 += deltaX;
                data.y1 += deltaY;
                data.x2 += deltaX;
                data.y2 += deltaY;
                data.x3 += deltaX;
                data.y3 += deltaY;
                break;
            case 'freehand':
                // Move all points in the path
                if (data.path) {
                    for (let point of data.path) {
                        point.x += deltaX;
                        point.y += deltaY;
                    }
                }
                break;
        }

        this.scheduleRedraw();
        this.scheduleServerUpdate(this.selectedElement);
    }
    
    rotateElement(x, y) {
        if (!this.selectedElement) return;

        const currentAngle = Math.atan2(y - this.rotationCenter.y, x - this.rotationCenter.x);
        const angleDiff = currentAngle - this.initialAngle;

        // Update rotation (convert to degrees for easier handling)
        const oldRotation = this.selectedElement.rotation || 0;
        this.selectedElement.rotation = (oldRotation + angleDiff * (180 / Math.PI)) % 360;

        this.initialAngle = currentAngle;
        this.scheduleRedraw();
        this.scheduleServerUpdate(this.selectedElement);
    }
    
    getResizeHandle(x, y) {
        if (!this.selectedElement) return null;
        
        const bounds = this.getElementBounds(this.selectedElement);
        const handleSize = 10; // Match the drawing size
        
        // Check rotation handle first (higher priority)
        const centerX = bounds.x + bounds.width / 2;
        const centerY = bounds.y + bounds.height / 2;
        const rotateHandleX = centerX;
        const rotateHandleY = bounds.y - 20; // 20px above the element
        
        if (Math.abs(x - rotateHandleX) <= handleSize && Math.abs(y - rotateHandleY) <= handleSize) {
            return 'rotate';
        }
        
        // Check resize corners
        const handles = [
            { name: 'nw', x: bounds.x, y: bounds.y },
            { name: 'ne', x: bounds.x + bounds.width, y: bounds.y },
            { name: 'sw', x: bounds.x, y: bounds.y + bounds.height },
            { name: 'se', x: bounds.x + bounds.width, y: bounds.y + bounds.height }
        ];
        
        for (let handle of handles) {
            if (Math.abs(x - handle.x) <= handleSize && Math.abs(y - handle.y) <= handleSize) {
                return handle.name;
            }
        }
        
        return null;
    }
    
    getElementBounds(element) {
        const data = element.data;
        
        switch (element.element_type) {
            case 'rectangle':
                return {
                    x: data.x,
                    y: data.y,
                    width: data.width,
                    height: data.height
                };
            case 'circle':
                return {
                    x: data.x - data.radius,
                    y: data.y - data.radius,
                    width: data.radius * 2,
                    height: data.radius * 2
                };
            case 'text':
                const fontSize = data.fontSize || 16;
                this.ctx.font = `${fontSize}px Arial`;
                const textWidth = this.ctx.measureText(data.text).width;
                return {
                    x: data.x,
                    y: data.y - fontSize,
                    width: textWidth,
                    height: fontSize
                };
            case 'line':
            case 'arrow':
                const minX = Math.min(data.x1, data.x2);
                const maxX = Math.max(data.x1, data.x2);
                const minY = Math.min(data.y1, data.y2);
                const maxY = Math.max(data.y1, data.y2);
                return {
                    x: minX,
                    y: minY,
                    width: Math.max(maxX - minX, 10), // Minimum width for selection
                    height: Math.max(maxY - minY, 10) // Minimum height for selection
                };
            case 'triangle':
                const triMinX = Math.min(data.x1, data.x2, data.x3);
                const triMaxX = Math.max(data.x1, data.x2, data.x3);
                const triMinY = Math.min(data.y1, data.y2, data.y3);
                const triMaxY = Math.max(data.y1, data.y2, data.y3);
                return {
                    x: triMinX,
                    y: triMinY,
                    width: triMaxX - triMinX,
                    height: triMaxY - triMinY
                };
            default:
                return { x: 0, y: 0, width: 0, height: 0 };
        }
    }
    
    resizeElement(x, y) {
        if (!this.selectedElement || !this.resizeHandle) return;
        
        const data = this.selectedElement.data;
        
        switch (this.selectedElement.element_type) {
            case 'rectangle':
                if (this.resizeHandle.includes('e')) {
                    data.width = Math.max(10, x - data.x); // Minimum width of 10px
                }
                if (this.resizeHandle.includes('s')) {
                    data.height = Math.max(10, y - data.y); // Minimum height of 10px
                }
                if (this.resizeHandle.includes('w')) {
                    const oldWidth = data.width;
                    data.width = Math.max(10, data.x + oldWidth - x);
                    data.x = x;
                }
                if (this.resizeHandle.includes('n')) {
                    const oldHeight = data.height;
                    data.height = Math.max(10, data.y + oldHeight - y);
                    data.y = y;
                }
                break;
            case 'circle':
                const dx = x - data.x;
                const dy = y - data.y;
                data.radius = Math.max(5, Math.sqrt(dx * dx + dy * dy)); // Minimum radius of 5px
                break;
                
            case 'line':
            case 'arrow':
                // Resize by changing the end point
                if (this.resizeHandle.includes('e') || this.resizeHandle.includes('s')) {
                    data.x2 = x;
                    data.y2 = y;
                } else if (this.resizeHandle.includes('w') || this.resizeHandle.includes('n')) {
                    data.x1 = x;
                    data.y1 = y;
                }
                // Update position to match the top-left of bounding box
                const minX = Math.min(data.x1, data.x2);
                const minY = Math.min(data.y1, data.y2);
                this.selectedElement.position_x = minX;
                this.selectedElement.position_y = minY;
                break;
                
            case 'triangle':
                // Resize triangle by adjusting points based on handle
                const bounds = this.getElementBounds(this.selectedElement);
                const centerX = bounds.x + bounds.width / 2;
                const centerY = bounds.y + bounds.height / 2;
                
                if (this.resizeHandle.includes('e')) {
                    const scale = (x - bounds.x) / bounds.width;
                    data.x2 = bounds.x + bounds.width * scale;
                    data.x3 = bounds.x + (data.x3 - bounds.x) * scale;
                }
                if (this.resizeHandle.includes('s')) {
                    const scale = (y - bounds.y) / bounds.height;
                    data.y2 = bounds.y + bounds.height * scale;
                    data.y3 = bounds.y + (data.y3 - bounds.y) * scale;
                }
                break;
                
            case 'text':
                // For text, resize by changing font size
                const currentSize = data.fontSize || 16;
                const textBounds = this.getElementBounds(this.selectedElement);
                
                if (this.resizeHandle.includes('e') || this.resizeHandle.includes('s')) {
                    // Calculate scale factor based on distance from text origin
                    const distance = Math.sqrt((x - data.x) * (x - data.x) + (y - data.y) * (y - data.y));
                    const baseDistance = Math.sqrt(textBounds.width * textBounds.width + textBounds.height * textBounds.height);
                    const scale = distance / baseDistance;
                    data.fontSize = Math.max(8, Math.min(72, currentSize * scale)); // Limit between 8px and 72px
                }
                
                // Update position for text
                this.selectedElement.position_x = data.x;
                this.selectedElement.position_y = data.y;
                break;
        }
        
        // Update position_x and position_y to match data (for rectangles and circles)
        if (this.selectedElement.element_type === 'rectangle' || this.selectedElement.element_type === 'circle') {
            this.selectedElement.position_x = data.x;
            this.selectedElement.position_y = data.y;
        }
        
        this.scheduleRedraw();
        this.scheduleServerUpdate(this.selectedElement);
    }
    
    drawSelectionHandles() {
        if (!this.selectedElement) return;
        
        const bounds = this.getElementBounds(this.selectedElement);
        const handleSize = 10; // Increased size for better visibility
        
        // Draw selection border first
        this.ctx.strokeStyle = '#007bff';
        this.ctx.lineWidth = 2;
        this.ctx.setLineDash([5, 5]); // Dashed border
        this.ctx.strokeRect(bounds.x - 2, bounds.y - 2, bounds.width + 4, bounds.height + 4);
        this.ctx.setLineDash([]); // Reset to solid line
        
        // Draw corner handles with better visibility
        this.ctx.fillStyle = '#007bff';
        this.ctx.strokeStyle = '#ffffff';
        this.ctx.lineWidth = 2;
        
        // Draw corner handles
        const handles = [
            { x: bounds.x, y: bounds.y },
            { x: bounds.x + bounds.width, y: bounds.y },
            { x: bounds.x, y: bounds.y + bounds.height },
            { x: bounds.x + bounds.width, y: bounds.y + bounds.height }
        ];
        
        for (let handle of handles) {
            // Draw shadow for better visibility
            this.ctx.fillStyle = 'rgba(0,0,0,0.3)';
            this.ctx.fillRect(handle.x - handleSize/2 + 1, handle.y - handleSize/2 + 1, handleSize, handleSize);
            
            // Draw main handle
            this.ctx.fillStyle = '#007bff';
            this.ctx.fillRect(handle.x - handleSize/2, handle.y - handleSize/2, handleSize, handleSize);
            this.ctx.strokeRect(handle.x - handleSize/2, handle.y - handleSize/2, handleSize, handleSize);
        }
        
        // Draw rotation handle
        const centerX = bounds.x + bounds.width / 2;
        const rotateHandleY = bounds.y - 20;
        
        // Draw connection line to rotation handle
        this.ctx.strokeStyle = '#007bff';
        this.ctx.lineWidth = 1;
        this.ctx.setLineDash([3, 3]);
        this.ctx.beginPath();
        this.ctx.moveTo(centerX, bounds.y);
        this.ctx.lineTo(centerX, rotateHandleY);
        this.ctx.stroke();
        this.ctx.setLineDash([]);
        
        // Draw rotation handle (circular)
        this.ctx.fillStyle = 'rgba(0,0,0,0.3)';
        this.ctx.beginPath();
        this.ctx.arc(centerX + 1, rotateHandleY + 1, handleSize/2, 0, 2 * Math.PI);
        this.ctx.fill();
        
        this.ctx.fillStyle = '#28a745'; // Green color for rotation
        this.ctx.strokeStyle = '#ffffff';
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.arc(centerX, rotateHandleY, handleSize/2, 0, 2 * Math.PI);
        this.ctx.fill();
        this.ctx.stroke();
        
        // Draw rotation icon (small arrow)
        this.ctx.strokeStyle = '#ffffff';
        this.ctx.lineWidth = 1;
        this.ctx.beginPath();
        this.ctx.arc(centerX, rotateHandleY, 3, 0, 1.5 * Math.PI);
        this.ctx.stroke();
        // Arrow head
        this.ctx.beginPath();
        this.ctx.moveTo(centerX - 3, rotateHandleY - 3);
        this.ctx.lineTo(centerX - 1, rotateHandleY - 3);
        this.ctx.lineTo(centerX - 1, rotateHandleY - 1);
        this.ctx.stroke();
    }
    
    updateElementOnServer(element) {
        const updateData = {
            element_id: element.id,
            data: element.data,
            position_x: element.position_x,
            position_y: element.position_y,
            rotation: element.rotation || 0
        };
        
        
        fetch(`/organization/boards/{{ board.pk }}/update-element/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': '{{ csrf_token }}'
            },
            body: JSON.stringify(updateData)
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                this.lastUpdate = Date.now();
            }
        })
        .catch(error => {
            console.error('Error updating element:', error);
        });
    }
    
    setupPolling() {
        this.lastUpdate = Date.now();
        this.pollingInterval = setInterval(() => {
            this.checkForUpdates();
        }, 1500); // Check every 1.5 seconds - reduced frequency for better performance
    }
    
    checkForUpdates() {
        // Don't check for updates while actively dragging
        if (this.pollingPaused) {
            return;
        }

        fetch(`/organization/boards/{{ board.pk }}/elements/?since=${this.lastUpdate}`)
            .then(response => response.json())
            .then(data => {
                if (data.updated && data.elements) {
                    // Only update if there are actual changes and we're not actively dragging
                    if (!this.pollingPaused && this.hasElementsChanged(data.elements)) {
                        this.elements = data.elements;
                        // Ensure all elements have correct position values
                        this.elements.forEach(element => this.ensureElementPosition(element));
                        this.scheduleRedraw();
                    }
                    this.lastUpdate = Date.now();
                }
            })
            .catch(error => {
                console.error('Error checking for updates:', error);
            });
    }
    
    hasElementsChanged(newElements) {
        if (newElements.length !== this.elements.length) {
            return true;
        }
        
        for (let i = 0; i < newElements.length; i++) {
            const newEl = newElements[i];
            const oldEl = this.elements[i];
            
            if (!oldEl || newEl.id !== oldEl.id || 
                JSON.stringify(newEl.data) !== JSON.stringify(oldEl.data) ||
                newEl.position_x !== oldEl.position_x ||
                newEl.position_y !== oldEl.position_y ||
                newEl.rotation !== oldEl.rotation) {
                return true;
            }
        }
        
        return false;
    }
    
    ensureElementPosition(element) {
        // Ensure position_x and position_y are correctly set for all element types
        const data = element.data;
        
        switch (element.element_type) {
            case 'rectangle':
            case 'circle':
            case 'text':
                if (element.position_x === undefined) element.position_x = data.x || 0;
                if (element.position_y === undefined) element.position_y = data.y || 0;
                break;
                
            case 'line':
            case 'arrow':
                const minX = Math.min(data.x1, data.x2);
                const minY = Math.min(data.y1, data.y2);
                if (element.position_x === undefined) element.position_x = minX;
                if (element.position_y === undefined) element.position_y = minY;
                break;
                
            case 'triangle':
                const triMinX = Math.min(data.x1, data.x2, data.x3);
                const triMinY = Math.min(data.y1, data.y2, data.y3);
                if (element.position_x === undefined) element.position_x = triMinX;
                if (element.position_y === undefined) element.position_y = triMinY;
                break;
                
            case 'freehand':
                if (data.path && data.path.length > 0) {
                    const pathMinX = Math.min(...data.path.map(p => p.x));
                    const pathMinY = Math.min(...data.path.map(p => p.y));
                    if (element.position_x === undefined) element.position_x = pathMinX;
                    if (element.position_y === undefined) element.position_y = pathMinY;
                }
                break;
        }
    }

    // Performance optimization methods
    scheduleRedraw() {
        if (this.redrawScheduled) return;

        this.redrawScheduled = true;
        requestAnimationFrame(() => {
            this.redrawCanvas();
            this.redrawScheduled = false;
        });
    }

    scheduleServerUpdate(element) {
        // Clear any existing timeout
        if (this.updateTimeout) {
            clearTimeout(this.updateTimeout);
        }

        // Store the pending update
        this.pendingUpdate = {
            element_id: element.id,
            data: element.data,
            position_x: element.position_x,
            position_y: element.position_y,
            rotation: element.rotation || 0
        };

        // Schedule the debounced update
        this.updateTimeout = setTimeout(() => {
            this.finalizePendingUpdate();
        }, this.debouncedUpdateDelay);
    }

    finalizePendingUpdate() {
        if (!this.pendingUpdate) return;

        const updateData = this.pendingUpdate;
        this.pendingUpdate = null;

        if (this.updateTimeout) {
            clearTimeout(this.updateTimeout);
            this.updateTimeout = null;
        }

        // Store original state for potential rollback
        const elementToUpdate = this.elements.find(el => el.id === updateData.element_id);
        const originalState = elementToUpdate ? {
            data: JSON.parse(JSON.stringify(elementToUpdate.data)),
            position_x: elementToUpdate.position_x,
            position_y: elementToUpdate.position_y,
            rotation: elementToUpdate.rotation
        } : null;

        // Send the update to server
        fetch(`/organization/boards/{{ board.pk }}/update-element/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': '{{ csrf_token }}'
            },
            body: JSON.stringify(updateData)
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                this.lastUpdate = Date.now();
                console.log('Element successfully updated on server');
            } else {
                console.error('Failed to update element on server:', data);
                this.rollbackElement(updateData.element_id, originalState);
            }
        })
        .catch(error => {
            console.error('Error updating element:', error);
            this.rollbackElement(updateData.element_id, originalState);
        });
    }

    rollbackElement(elementId, originalState) {
        if (!originalState) {
            console.warn('Cannot rollback element - no original state available');
            return;
        }

        // Find and restore the element
        const element = this.elements.find(el => el.id === elementId);
        if (element) {
            element.data = originalState.data;
            element.position_x = originalState.position_x;
            element.position_y = originalState.position_y;
            element.rotation = originalState.rotation;

            this.scheduleRedraw();
            console.log('Element rolled back to previous state');

            // Show a brief user notification
            this.showNotification('Update failed - changes reverted', 'error');
        }
    }

    showNotification(message, type = 'info') {
        // Create a simple notification
        const notification = document.createElement('div');
        notification.className = `alert alert-${type === 'error' ? 'danger' : 'info'} alert-dismissible`;
        notification.style.cssText = 'position: fixed; top: 20px; right: 20px; z-index: 1000; min-width: 300px;';
        notification.innerHTML = `
            ${message}
            <button type="button" class="btn-close" onclick="this.parentElement.remove()"></button>
        `;

        document.body.appendChild(notification);

        // Auto-remove after 3 seconds
        setTimeout(() => {
            if (notification.parentElement) {
                notification.remove();
            }
        }, 3000);
    }

    pausePolling() {
        this.pollingPaused = true;
    }

    resumePolling() {
        this.pollingPaused = false;
        // Immediately check for updates when resuming
        setTimeout(() => this.checkForUpdates(), 100);
    }

    cleanup() {
        if (this.pollingInterval) {
            clearInterval(this.pollingInterval);
        }
        if (this.updateTimeout) {
            clearTimeout(this.updateTimeout);
        }
    }
    
    zoomIn() {
        this.zoomLevel = Math.min(this.zoomLevel * 1.2, 5); // Max zoom 5x
        this.applyCanvasTransform();
    }
    
    zoomOut() {
        this.zoomLevel = Math.max(this.zoomLevel / 1.2, 0.1); // Min zoom 0.1x
        this.applyCanvasTransform();
    }
    
    panCanvas(deltaX, deltaY) {
        this.panX += deltaX;
        this.panY += deltaY;
        this.applyCanvasTransform();
    }
    
    resetCanvasView() {
        this.zoomLevel = 1;
        this.panX = 0;
        this.panY = 0;
        this.applyCanvasTransform();
    }
    
    applyCanvasTransform() {
        const container = document.getElementById('canvas-container');
        this.canvas.style.transform = `translate(${this.panX}px, ${this.panY}px) scale(${this.zoomLevel})`;
        this.canvas.style.transformOrigin = 'top left';
    }
    
    toggleHandTool() {
        if (this.handToolActive) {
            this.deactivateHandTool();
        } else {
            this.activateHandTool();
        }
    }
    
    activateHandTool() {
        this.handToolActive = true;
        const handButton = document.getElementById('hand-tool');
        handButton.classList.remove('btn-outline-secondary');
        handButton.classList.add('btn-secondary');
        this.canvas.style.cursor = 'grab';
    }
    
    deactivateHandTool() {
        this.handToolActive = false;
        this.isPanning = false; // Stop any active panning
        const handButton = document.getElementById('hand-tool');
        handButton.classList.remove('btn-secondary');
        handButton.classList.add('btn-outline-secondary');
        this.updateCursor(); // Reset to normal cursor based on current tool
    }
    
    updateCursor() {
        switch (this.currentTool) {
            case 'select':
                // Dark pointer cursor for better visibility
                this.canvas.style.cursor = 'url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTMgM0w5IDE5TDEyIDE1TDE5IDEySjMgM1oiIGZpbGw9IiMwMDAiIHN0cm9rZT0iI2ZmZiIgc3Ryb2tlLXdpZHRoPSIxIi8+Cjwvc3ZnPg==) 3 3, pointer';
                break;
            case 'pen':
            case 'brush':
                // Dark crosshair for better visibility
                this.canvas.style.cursor = 'url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGxpbmUgeDE9IjEyIiB5MT0iMyIgeDI9IjEyIiB5Mj0iMjEiIHN0cm9rZT0iIzAwMCIgc3Ryb2tlLXdpZHRoPSIyIi8+CjxsaW5lIHgxPSIzIiB5MT0iMTIiIHgyPSIyMSIgeTI9IjEyIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMiIvPgo8Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSIyIiBmaWxsPSIjZmZmIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMSIvPgo8L3N2Zz4=) 12 12, crosshair';
                break;
            case 'text':
                // Dark text cursor
                this.canvas.style.cursor = 'url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGxpbmUgeDE9IjEyIiB5MT0iMyIgeDI9IjEyIiB5Mj0iMjEiIHN0cm9rZT0iIzAwMCIgc3Ryb2tlLXdpZHRoPSIyIi8+CjxsaW5lIHgxPSI5IiB5MT0iMyIgeDI9IjE1IiB5Mj0iMyIgc3Ryb2tlPSIjMDAwIiBzdHJva2Utd2lkdGg9IjIiLz4KPGxpbmUgeDE9IjkiIHkxPSIyMSIgeDI9IjE1IiB5Mj0iMjEiIHN0cm9rZT0iIzAwMCIgc3Ryb2tlLXdpZHRoPSIyIi8+Cjwvc3ZnPg==) 12 12, text';
                break;
            case 'arrow':
                // Arrow cursor
                this.canvas.style.cursor = 'url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGxpbmUgeDE9IjMiIHkxPSIxMiIgeDI9IjIxIiB5Mj0iMTIiIHN0cm9rZT0iIzAwMCIgc3Ryb2tlLXdpZHRoPSIyIi8+Cjxwb2x5bGluZSBwb2ludHM9IjE1LDYgMjEsMTIgMTUsMTgiIHN0cm9rZT0iIzAwMCIgc3Ryb2tlLXdpZHRoPSIyIiBmaWxsPSJub25lIi8+Cjwvc3ZnPg==) 12 12, crosshair';
                break;
            default:
                // Default dark crosshair
                this.canvas.style.cursor = 'url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGxpbmUgeDE9IjEyIiB5MT0iMyIgeDI9IjEyIiB5Mj0iMjEiIHN0cm9rZT0iIzAwMCIgc3Ryb2tlLXdpZHRoPSIyIi8+CjxsaW5lIHgxPSIzIiB5MT0iMTIiIHgyPSIyMSIgeTI9IjEyIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMiIvPgo8Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSIyIiBmaWxsPSIjZmZmIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMSIvPgo8L3N2Zz4=) 12 12, crosshair';
        }
    }
}

// Initialisiere das Board wenn die Seite geladen ist
let ideaBoard;

function initializeBoard() {
    console.log('Initializing IdeaBoard...');
    ideaBoard = new IdeaBoard();
    console.log('IdeaBoard initialized:', ideaBoard);
}

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeBoard);
} else {
    // DOM is already loaded
    initializeBoard();
}

// Cleanup when page is unloaded
window.addEventListener('beforeunload', function() {
    if (ideaBoard) {
        ideaBoard.cleanup();
    }
});

// Benutzersuche für Einladungen
let searchTimeout;
const newCollaborators = new Set();

document.getElementById('userSearch').addEventListener('input', function() {
    const query = this.value.trim();
    
    clearTimeout(searchTimeout);
    
    if (query.length < 2) {
        document.getElementById('searchResults').innerHTML = '';
        return;
    }
    
    searchTimeout = setTimeout(() => {
        fetch(`/organization/api/user-search/?q=${encodeURIComponent(query)}`)
            .then(response => response.json())
            .then(data => {
                const resultsDiv = document.getElementById('searchResults');
                resultsDiv.innerHTML = '';
                
                if (data.results.length === 0) {
                    resultsDiv.innerHTML = '<div class="text-muted">Keine Benutzer gefunden</div>';
                    return;
                }
                
                data.results.forEach(user => {
                    const userDiv = document.createElement('div');
                    userDiv.className = 'border rounded p-2 mb-2 cursor-pointer';
                    userDiv.style.cursor = 'pointer';
                    userDiv.innerHTML = `
                        <strong>${user.username}</strong> 
                        <small class="text-muted">${user.full_name}</small>
                    `;
                    userDiv.onclick = () => addCollaborator(user);
                    resultsDiv.appendChild(userDiv);
                });
            })
            .catch(error => {
                console.error('Fehler bei der Benutzersuche:', error);
            });
    }, 300);
});

function addCollaborator(user) {
    // Prüfen ob bereits hinzugefügt
    if (newCollaborators.has(user.id)) {
        return;
    }
    
    // Prüfen ob bereits Mitarbeiter
    const existingCollaborator = document.querySelector(`[data-user-id="${user.id}"]`);
    if (existingCollaborator) {
        return;
    }
    
    newCollaborators.add(user.id);
    
    const badge = document.createElement('span');
    badge.className = 'badge bg-success me-1';
    badge.dataset.userId = user.id;
    badge.innerHTML = `
        ${user.username}
        <button type="button" class="btn-close btn-close-white ms-1" style="font-size: 0.7em;" onclick="removeNewCollaborator(${user.id})"></button>
    `;
    
    document.getElementById('newCollaborators').appendChild(badge);
    document.getElementById('userSearch').value = '';
    document.getElementById('searchResults').innerHTML = '';
}

function removeNewCollaborator(userId) {
    newCollaborators.delete(userId);
    const badge = document.querySelector(`#newCollaborators [data-user-id="${userId}"]`);
    if (badge) {
        badge.remove();
    }
}

function removeCollaborator(userId) {
    if (confirm('Mitarbeiter wirklich entfernen?')) {
        fetch(`/organization/boards/{{ board.pk }}/remove-collaborator/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': '{{ csrf_token }}'
            },
            body: JSON.stringify({user_id: userId})
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                const badge = document.querySelector(`#currentCollaborators [data-user-id="${userId}"]`);
                if (badge) {
                    badge.remove();
                }
            } else {
                alert('Fehler beim Entfernen des Mitarbeiters');
            }
        })
        .catch(error => {
            console.error('Fehler:', error);
            alert('Fehler beim Entfernen des Mitarbeiters');
        });
    }
}

function saveInvitations() {
    if (newCollaborators.size === 0) {
        alert('Keine neuen Mitarbeiter ausgewählt');
        return;
    }
    
    const collaboratorIds = Array.from(newCollaborators);
    
    fetch(`/organization/boards/{{ board.pk }}/invite-collaborators/`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': '{{ csrf_token }}'
        },
        body: JSON.stringify({collaborator_ids: collaboratorIds})
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            alert('Einladungen erfolgreich gesendet!');
            location.reload(); // Seite neu laden um neue Mitarbeiter anzuzeigen
        } else {
            alert('Fehler beim Senden der Einladungen');
        }
    })
    .catch(error => {
        console.error('Fehler:', error);
        alert('Fehler beim Senden der Einladungen');
    });
}
</script>

<!-- Agora SDK -->
<script src="https://download.agora.io/sdk/release/AgoraRTC_N-4.18.0.js"></script>

<script>
// ========================================
// Board Audio Manager
// ========================================
class BoardAudioManager {
    constructor() {
        this.isAudioActive = false;
        this.isMuted = false;
        this.agoraClient = null;
        this.localAudioTrack = null;
        this.audioConfig = null;
        this.participantCount = 0;

        this.initEventListeners();
        this.checkAudioStatus();
    }

    initEventListeners() {
        const audioBtn = document.getElementById('audio-toggle-btn');
        if (audioBtn) {
            audioBtn.addEventListener('click', () => {
                if (this.isAudioActive) {
                    this.leaveAudio();
                } else {
                    this.joinAudio();
                }
            });
        }

        // Status alle 5 Sekunden prüfen
        setInterval(() => {
            if (!this.isAudioActive) {
                this.checkAudioStatus();
            }
        }, 5000);
    }

    async checkAudioStatus() {
        try {
            const response = await fetch(`/organization/boards/{{ board.pk }}/audio/status/`);
            const data = await response.json();

            this.updateUI(data);
        } catch (error) {
            console.error('Error checking audio status:', error);
        }
    }

    updateUI(audioStatus) {
        const audioBtn = document.getElementById('audio-toggle-btn');
        const audioIcon = document.getElementById('audio-icon');
        const audioText = document.getElementById('audio-text');
        const audioParticipants = document.getElementById('audio-participants');

        if (!audioBtn) return;

        if (audioStatus.has_active_session && audioStatus.participant_count > 0) {
            audioParticipants.style.display = 'inline';
            audioParticipants.textContent = audioStatus.participant_count;
        } else {
            audioParticipants.style.display = 'none';
        }

        if (audioStatus.user_is_participant) {
            audioBtn.className = 'btn btn-success me-2';
            audioIcon.className = this.isMuted ? 'fas fa-microphone-slash' : 'fas fa-microphone';
            audioText.textContent = 'Audio verlassen';
        } else {
            audioBtn.className = 'btn btn-outline-success me-2';
            audioIcon.className = 'fas fa-microphone-slash';
            audioText.textContent = 'Audio beitreten';
        }
    }

    async joinAudio() {
        try {
            // Backend: Audio-Session beitreten
            const joinResponse = await fetch(`/organization/boards/{{ board.pk }}/audio/join/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': '{{ csrf_token }}'
                }
            });

            if (!joinResponse.ok) {
                const errorData = await joinResponse.json();
                console.error('Join audio response error:', errorData);
                throw new Error(errorData.error || 'Failed to join audio session');
            }

            // Agora Token holen
            const tokenResponse = await fetch(`/organization/boards/{{ board.pk }}/audio/token/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': '{{ csrf_token }}'
                }
            });

            if (!tokenResponse.ok) {
                const errorData = await tokenResponse.json();
                console.error('Token response error:', errorData);
                throw new Error(errorData.error || 'Failed to get audio token');
            }

            this.audioConfig = await tokenResponse.json();
            console.log('Audio config received:', this.audioConfig);

            // Agora Client initialisieren
            this.agoraClient = AgoraRTC.createClient({ mode: "rtc", codec: "vp8" });

            // Event Listener für Agora
            this.agoraClient.on("user-published", async (user, mediaType) => {
                await this.agoraClient.subscribe(user, mediaType);
                if (mediaType === 'audio') {
                    user.audioTrack.play();
                }
            });

            this.agoraClient.on("user-unpublished", (user) => {
                console.log('User left audio:', user.uid);
            });

            // Channel beitreten
            await this.agoraClient.join(
                this.audioConfig.app_id,
                this.audioConfig.channel_name,
                this.audioConfig.token,
                this.audioConfig.uid
            );

            // Mikrofon aktivieren
            this.localAudioTrack = await AgoraRTC.createMicrophoneAudioTrack();
            await this.agoraClient.publish([this.localAudioTrack]);

            this.isAudioActive = true;
            this.checkAudioStatus();

            console.log('Successfully joined board audio');

        } catch (error) {
            console.error('Error joining audio:', error);
            alert('Fehler beim Beitreten zum Audio: ' + error.message);
        }
    }

    async leaveAudio() {
        try {
            // Agora Client cleanup
            if (this.localAudioTrack) {
                this.localAudioTrack.stop();
                this.localAudioTrack.close();
                this.localAudioTrack = null;
            }

            if (this.agoraClient) {
                await this.agoraClient.leave();
                this.agoraClient = null;
            }

            // Backend: Audio-Session verlassen
            const response = await fetch(`/organization/boards/{{ board.pk }}/audio/leave/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': '{{ csrf_token }}'
                }
            });

            if (!response.ok) {
                throw new Error('Failed to leave audio session');
            }

            this.isAudioActive = false;
            this.checkAudioStatus();

            console.log('Successfully left board audio');

        } catch (error) {
            console.error('Error leaving audio:', error);
            alert('Fehler beim Verlassen des Audios: ' + error.message);
        }
    }

    async toggleMute() {
        if (!this.localAudioTrack) return;

        if (this.isMuted) {
            await this.localAudioTrack.setMuted(false);
            this.isMuted = false;
        } else {
            await this.localAudioTrack.setMuted(true);
            this.isMuted = true;
        }

        this.checkAudioStatus();
    }

    cleanup() {
        if (this.isAudioActive) {
            this.leaveAudio();
        }
    }
}

// Initialisiere Board Audio Manager
let boardAudioManager;

function initializeBoardAudio() {
    boardAudioManager = new BoardAudioManager();
}

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeBoardAudio);
} else {
    initializeBoardAudio();
}

// Cleanup when page is unloaded
window.addEventListener('beforeunload', function() {
    if (boardAudioManager) {
        boardAudioManager.cleanup();
    }
});

// Tastenkürzel für Mute/Unmute (Leertaste gedrückt halten)
document.addEventListener('keydown', function(e) {
    if (e.code === 'Space' && boardAudioManager && boardAudioManager.isAudioActive) {
        e.preventDefault();
        boardAudioManager.toggleMute();
    }
});

document.addEventListener('keyup', function(e) {
    if (e.code === 'Space' && boardAudioManager && boardAudioManager.isAudioActive) {
        e.preventDefault();
        boardAudioManager.toggleMute();
    }
});
</script>

<style>
.tool-btn.active {
    background-color: #0d6efd;
    color: white;
}

#canvas-container {
    max-width: 100%;
    overflow: auto;
}

.form-control-color {
    width: 100%;
    height: 40px;
}

/* Mobile responsive styles */
@media (max-width: 991.98px) {
    /* Transform vertical button group to horizontal on mobile */
    .btn-group-horizontal-mobile {
        display: flex !important;
        flex-direction: row !important;
        flex-wrap: wrap !important;
        gap: 4px !important;
    }
    
    .btn-group-horizontal-mobile .tool-btn {
        flex: 1 1 calc(20% - 4px) !important;
        min-width: 60px !important;
        padding: 8px 4px !important;
        font-size: 12px !important;
        border-radius: 6px !important;
        white-space: nowrap !important;
        overflow: hidden !important;
        text-overflow: ellipsis !important;
    }
    
    /* Hide text on very small screens, show only icons */
    .btn-group-horizontal-mobile .tool-btn i {
        display: block !important;
        margin-right: 0 !important;
        font-size: 16px !important;
    }
    
    /* Canvas container adjustments for mobile */
    #canvas-container {
        overflow-x: auto !important;
        overflow-y: auto !important;
        max-width: 100vw !important;
        padding: 10px !important;
    }
    
    #drawing-canvas {
        max-width: 100% !important;
        height: auto !important;
        touch-action: none !important; /* Prevent page scrolling while drawing */
    }
    
    /* Mobile card adjustments */
    .card-body {
        padding: 0.75rem !important;
    }
    
    /* Smaller controls on mobile */
    .form-control, .form-select {
        font-size: 14px !important;
        padding: 6px 8px !important;
    }
    
    .btn {
        font-size: 14px !important;
        padding: 6px 12px !important;
    }
}

@media (max-width: 575.98px) {
    /* Even more compact on very small screens */
    .btn-group-horizontal-mobile .tool-btn {
        flex: 1 1 calc(25% - 3px) !important;
        padding: 6px 2px !important;
        font-size: 0 !important; /* Hide text completely */
    }
    
    .btn-group-horizontal-mobile .tool-btn i {
        font-size: 14px !important;
    }
    
    /* Stack canvas below tools on very small screens */
    .row {
        margin: 0 !important;
    }
    
    .col-12 {
        padding: 0.25rem !important;
    }
}
</style>
{% endblock %}