{% extends 'base.html' %}

{% block title %}{{ board.title }} - Ideenboard{% endblock %}

{% block content %}
<div class="container-fluid mt-4">
    <div class="row">
        <div class="col-12">
            <div class="d-flex justify-content-between align-items-center mb-4">
                <h1>{{ board.title }}</h1>
                <div style="display: flex; flex-wrap: wrap; align-items: center; gap: 8px;">
                    <!-- Board Audio Button -->
                    <button type="button" id="audio-toggle-btn" class="btn btn-sm btn-outline-success me-1" style="width: 120px; height: 38px; display: flex; align-items: center; justify-content: center;">
                        üé§ <span id="audio-text" class="d-none d-sm-inline">Audio</span>
                        <span id="audio-participants" class="badge bg-secondary ms-1" style="display: none; font-size: 0.65rem;">0</span>
                    </button>

                    <!-- Mute Button (only visible when audio is active) -->
                    <button type="button" id="mute-toggle-btn" class="btn btn-sm btn-outline-warning me-1" style="display: none; width: 120px; height: 38px;">
                        üîá <span id="mute-text" class="d-none d-sm-inline">Stumm</span>
                    </button>

                    <!-- Audio Participants List with Speaking Indicator -->
                    <div id="audio-participants-list" class="d-inline-block me-1" style="display: none;">
                        <div class="dropdown">
                            <button class="btn btn-sm btn-outline-secondary dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" style="width: 120px; height: 38px; display: flex; align-items: center; justify-content: center;">
                                <span id="active-speaker-name">üë• <span class="d-none d-sm-inline">Teiln.</span></span>
                            </button>
                            <div class="dropdown-menu" id="participants-dropdown" style="min-width: 200px;">
                                <!-- Participants will be added here dynamically -->
                            </div>
                        </div>
                    </div>

                    {% if board.creator == request.user %}
                        <button type="button" class="btn btn-sm btn-info me-1" data-bs-toggle="modal" data-bs-target="#inviteModal" style="width: 120px; height: 38px; display: flex; align-items: center; justify-content: center;">
                            üë• <span class="d-none d-sm-inline">Einladen</span>
                        </button>
                    {% endif %}
                    <a href="{% url 'organization:board_list' %}" class="btn btn-sm btn-secondary" style="width: 120px; height: 38px; display: flex; align-items: center; justify-content: center;">
                        ‚Ü©Ô∏è <span class="d-none d-sm-inline">Zur√ºck</span>
                    </a>
                </div>
            </div>
            
            {% if board.description %}
                <p class="text-muted mb-4">{{ board.description }}</p>
            {% endif %}
        </div>
    </div>
    
    <div class="row">
        <div class="col-12 col-lg-2">
            <!-- Werkzeuge -->
            <div class="card">
                <div class="card-header d-lg-block d-none">
                    <h5>üé® Werkzeuge</h5>
                </div>
                <div class="card-body p-2">
                    <div class="btn-group-vertical btn-group-horizontal-mobile w-100" role="group">
                        <button type="button" class="btn btn-outline-primary tool-btn active" data-tool="select">
                            üëÜ Ausw√§hlen
                        </button>
                        <button type="button" class="btn btn-outline-primary tool-btn" data-tool="pen">
                            ‚úèÔ∏è Stift
                        </button>
                        <button type="button" class="btn btn-outline-primary tool-btn" data-tool="brush">
                            üñåÔ∏è Pinsel
                        </button>
                        <button type="button" class="btn btn-outline-primary tool-btn" data-tool="text">
                            üìù Text
                        </button>
                        <button type="button" class="btn btn-outline-primary tool-btn" data-tool="rectangle">
                            ‚¨ú Rechteck
                        </button>
                        <button type="button" class="btn btn-outline-primary tool-btn" data-tool="circle">
                            ‚≠ï Kreis
                        </button>
                        <button type="button" class="btn btn-outline-primary tool-btn" data-tool="triangle">
                            üî∫ Dreieck
                        </button>
                        <button type="button" class="btn btn-outline-primary tool-btn" data-tool="line">
                            ‚ûñ Linie
                        </button>
                        <button type="button" class="btn btn-outline-primary tool-btn" data-tool="arrow">
                            ‚û°Ô∏è Pfeil
                        </button>
                    </div>
                    
                    <hr>
                    
                    
                    <hr>

                    <div class="d-grid gap-2 my-3">
                        <button type="button" class="btn btn-warning btn-sm" id="clear-canvas" style="font-size: 0.75rem; padding: 0.25rem 0.5rem;">
                            üóëÔ∏è Canvas l√∂schen
                        </button>

                        <button type="button" class="btn btn-success btn-sm" id="save-board" style="font-size: 0.75rem; padding: 0.25rem 0.5rem;">
                            üíæ Speichern
                        </button>

                        <button type="button" class="btn btn-info btn-sm" id="download-board" style="font-size: 0.75rem; padding: 0.25rem 0.5rem;">
                            üì• Download JPG
                        </button>
                    </div>

                </div>
            </div>
        </div>
        
        <div class="col-12 col-lg-10">
            <!-- Canvas -->
            <div class="card">
                <div class="card-body p-0">
                    <div id="canvas-container" style="position: relative; overflow: hidden;">
                        <!-- Undo Button and Speaking Indicator - Top Right -->
                        <div style="position: absolute; top: 10px; right: 10px; z-index: 10;">
                            <button type="button" class="btn btn-secondary btn-sm" id="undo-action">
                                ‚Ü©Ô∏è R√ºckg√§ngig
                            </button>
                            <!-- Speaking Indicator -->
                            <div id="speaking-indicator-top" style="display: none; margin-top: 10px; padding: 8px 12px; background: rgba(40, 167, 69, 0.15); border: 1px solid #28a745; border-radius: 6px; text-align: center;">
                                <span style="color: #28a745; font-weight: 600; font-size: 14px;">
                                    üó£Ô∏è <span id="speaking-name-top">-</span>
                                </span>
                            </div>

                            <!-- Audio Join Notification -->
                            <div id="audio-join-notification" style="display: none; margin-top: 10px; padding: 8px 12px; background: rgba(0, 123, 255, 0.15); border: 1px solid #007bff; border-radius: 6px; text-align: center; min-width: 200px;">
                                <span style="color: #007bff; font-weight: 600; font-size: 13px;">
                                    üé§ <span id="join-notification-text">-</span>
                                </span>
                            </div>
                        </div>
                        
                        <!-- Zoom Controls - Top Left -->
                        <div style="position: absolute; top: 10px; left: 10px; z-index: 10;">
                            <div class="btn-group-vertical" role="group">
                                <button type="button" class="btn btn-outline-secondary btn-sm" id="zoom-in" title="Hineinzoomen">
                                    üîç+
                                </button>
                                <button type="button" class="btn btn-outline-secondary btn-sm" id="hand-tool" title="Board verschieben">
                                    ‚úã
                                </button>
                                <button type="button" class="btn btn-outline-secondary btn-sm" id="nav-center" title="Zentrieren">
                                    üéØ
                                </button>
                                <button type="button" class="btn btn-outline-secondary btn-sm" id="zoom-out" title="Herauszoomen">
                                    üîç-
                                </button>
                            </div>
                        </div>
                        
                        
                        <div style="position: relative;">
                            <canvas id="drawing-canvas"
                                    width="{{ board.width }}"
                                    height="{{ board.height }}"
                                    style="border: 1px solid #dee2e6; background-color: {{ board.background_color }}; max-width: 100%; height: auto; cursor: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTMgM0w5IDE5TDEyIDE1TDE5IDEySjMgM1oiIGZpbGw9IiMwMDAiIHN0cm9rZT0iI2ZmZiIgc3Ryb2tlLXdpZHRoPSIxIi8+Cjwvc3ZnPg==) 3 3, pointer;">
                            </canvas>

                            <!-- Tool Controls Popup -->
                            <div id="tool-controls-popup" style="display: none; position: absolute; z-index: 9999; background: white; border: 1px solid #ccc; border-radius: 4px; padding: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.15); top: 10px; left: 50%; transform: translateX(-50%);">
                                <div class="d-flex align-items-center gap-3">
                                    <!-- Farben -->
                                    <div class="d-flex align-items-center">
                                        <label class="small me-2 mb-0">üé®</label>
                                        <input type="color" id="color-picker" value="#000000" style="width: 30px; height: 25px; border: 1px solid #ccc; border-radius: 3px; cursor: pointer;">
                                    </div>

                                    <!-- Strichst√§rke -->
                                    <div class="d-flex align-items-center" id="stroke-width-control">
                                        <label class="small me-2 mb-0">üìè</label>
                                        <input type="range" class="form-range" id="stroke-width" min="1" max="20" value="2" style="width: 80px; height: 15px;">
                                        <span class="small ms-1"><span id="stroke-width-value">2</span>px</span>
                                    </div>

                                    <!-- Schriftgr√∂√üe (nur f√ºr Text) -->
                                    <div class="d-flex align-items-center" id="font-size-control" style="display: none;">
                                        <label class="small me-2 mb-0">üìù</label>
                                        <input type="range" class="form-range" id="font-size" min="8" max="72" value="16" style="width: 80px; height: 15px;">
                                        <span class="small ms-1"><span id="font-size-value">16</span>px</span>
                                    </div>

                                    <!-- Transparenz -->
                                    <div class="d-flex align-items-center">
                                        <label class="small me-2 mb-0">üîç</label>
                                        <input type="range" class="form-range" id="opacity" min="0" max="100" value="100" style="width: 80px; height: 15px;">
                                        <span class="small ms-1"><span id="opacity-value">100</span>%</span>
                                    </div>
                                </div>
                            </div>

                            <!-- Floating Trash Can on Canvas -->
                            <div id="canvas-trash-zone"
                                 style="position: absolute; bottom: 20px; left: 20px;
                                        width: 60px; height: 60px;
                                        background: rgba(255, 193, 7, 0.8);
                                        border: 2px dashed #ffc107;
                                        border-radius: 12px;
                                        display: flex; align-items: center; justify-content: center;
                                        transition: all 0.3s ease;
                                        cursor: pointer;
                                        z-index: 1000;
                                        box-shadow: 0 2px 6px rgba(0,0,0,0.15);
                                        pointer-events: none;">
                                <div style="text-align: center; color: #856404; font-weight: bold;">
                                    <div style="font-size: 20px;">üóëÔ∏è</div>
                                    <div style="font-size: 8px; line-height: 1;">L√ñSCHEN</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Shared Notes Section - Below Canvas -->
            <div class="card mt-3">
                <div class="card-header">
                    <h6 class="mb-0">üìù Gemeinsame Notizen</h6>
                </div>
                <div class="card-body">
                    <!-- Rich Text Editor Toolbar -->
                    <div id="notes-toolbar">
                        <span class="ql-formats">
                            <button class="ql-bold" title="Fett"></button>
                            <button class="ql-italic" title="Kursiv"></button>
                            <button class="ql-underline" title="Unterstrichen"></button>
                        </span>
                        <span class="ql-formats">
                            <button class="ql-list" value="ordered" title="Nummerierte Liste"></button>
                            <button class="ql-list" value="bullet" title="Aufz√§hlung"></button>
                        </span>
                        <span class="ql-formats">
                            <select class="ql-color" title="Textfarbe">
                                <option selected></option>
                                <option value="red"></option>
                                <option value="orange"></option>
                                <option value="yellow"></option>
                                <option value="green"></option>
                                <option value="blue"></option>
                                <option value="purple"></option>
                            </select>
                            <select class="ql-background" title="Hintergrundfarbe">
                                <option selected></option>
                                <option value="red"></option>
                                <option value="orange"></option>
                                <option value="yellow"></option>
                                <option value="green"></option>
                                <option value="blue"></option>
                                <option value="purple"></option>
                            </select>
                        </span>
                        <span class="ql-formats">
                            <select class="ql-size" title="Schriftgr√∂√üe">
                                <option value="small">Klein</option>
                                <option selected>Normal</option>
                                <option value="large">Gro√ü</option>
                                <option value="huge">Sehr gro√ü</option>
                            </select>
                        </span>
                    </div>

                    <!-- Rich Text Editor Content -->
                    <div id="board-notes-editor" style="height: 150px;"></div>

                    <!-- Hidden textarea for form compatibility -->
                    <textarea id="board-notes" style="display: none;">{{ board.notes }}</textarea>

                    <div class="d-flex justify-content-between align-items-center mt-2">
                        <div class="d-flex flex-column">
                            <small class="text-muted" id="notes-status">Automatisch gespeichert</small>
                            <small class="text-info" id="notes-author" style="display: none;">
                                üë§ <span id="notes-author-name"></span> bearbeitet...
                            </small>
                        </div>
                        <button type="button" class="btn btn-sm btn-outline-primary" id="save-notes-btn">
                            üíæ Notizen speichern
                        </button>
                    </div>
                </div>
            </div>
        </div>

    </div>
</div>

<!-- Modal f√ºr Personen einladen -->
<div class="modal fade" id="inviteModal" tabindex="-1" aria-labelledby="inviteModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="inviteModalLabel">Personen zu Board einladen</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <form id="inviteForm">
                    <div class="mb-3">
                        <label for="userSearch" class="form-label">Benutzer suchen</label>
                        <input type="text" class="form-control" id="userSearch" placeholder="Benutzername oder Name eingeben...">
                        <div id="searchResults" class="mt-2"></div>
                    </div>
                    
                    <div class="mb-3">
                        <label class="form-label">Aktuelle Mitarbeiter</label>
                        <div id="currentCollaborators">
                            {% for collaborator in board.collaborators.all %}
                                <span class="badge bg-secondary me-1" data-user-id="{{ collaborator.id }}">
                                    {{ collaborator.username }}
                                    <button type="button" class="btn-close btn-close-white ms-1" style="font-size: 0.7em;" onclick="removeCollaborator({{ collaborator.id }})"></button>
                                </span>
                            {% endfor %}
                        </div>
                    </div>
                    
                    <div class="mb-3">
                        <label class="form-label">Neue Mitarbeiter</label>
                        <div id="newCollaborators"></div>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Abbrechen</button>
                <button type="button" class="btn btn-primary" onclick="saveInvitations()">Einladungen senden</button>
            </div>
        </div>
    </div>
</div>

<!-- Modal f√ºr Text-Eingabe -->
<div class="modal fade" id="textInputModal" tabindex="-1" aria-labelledby="textInputModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="textInputModalLabel">üìù Text hinzuf√ºgen</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="mb-2">
                    <label for="textInput" class="form-label small mb-1">Text eingeben</label>
                    <textarea class="form-control" id="textInput" rows="2" placeholder="Geben Sie hier Ihren Text ein..."></textarea>
                </div>

                <!-- Live-Vorschau -->
                <div class="mb-2">
                    <label class="form-label small mb-1">üëÅÔ∏è Vorschau</label>
                    <div id="textPreview" style="border: 1px solid #ddd; padding: 8px; min-height: 40px; background: #f9f9f9; border-radius: 4px; font-size: 14px; font-family: Arial, sans-serif; color: #000000;">
                        Vorschau des Textes...
                    </div>
                </div>

                <div class="row">
                    <div class="col-md-6">
                        <div class="mb-3">
                            <label for="textFontSize" class="form-label">üìè Schriftgr√∂√üe</label>
                            <select class="form-select" id="textFontSize">
                                <option value="12">12px</option>
                                <option value="14">14px</option>
                                <option value="16" selected>16px</option>
                                <option value="18">18px</option>
                                <option value="20">20px</option>
                                <option value="24">24px</option>
                                <option value="28">28px</option>
                                <option value="32">32px</option>
                                <option value="36">36px</option>
                                <option value="48">48px</option>
                            </select>
                        </div>
                    </div>

                    <div class="col-md-6">
                        <div class="mb-3">
                            <label for="textFontFamily" class="form-label">üî§ Schriftart</label>
                            <select class="form-select" id="textFontFamily">
                                <option value="Arial, sans-serif" selected>Arial</option>
                                <option value="'Times New Roman', serif">Times New Roman</option>
                                <option value="'Courier New', monospace">Courier New</option>
                                <option value="Georgia, serif">Georgia</option>
                                <option value="'Comic Sans MS', cursive">Comic Sans MS</option>
                                <option value="Impact, sans-serif">Impact</option>
                                <option value="'Trebuchet MS', sans-serif">Trebuchet MS</option>
                                <option value="Verdana, sans-serif">Verdana</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div class="mb-3">
                    <label class="form-label">üé® Text-Formatierung</label>
                    <div class="btn-group" role="group" aria-label="Text formatting">
                        <input type="checkbox" class="btn-check" id="textBold" autocomplete="off">
                        <label class="btn btn-outline-secondary" for="textBold">
                            <strong>B</strong> Fett
                        </label>

                        <input type="checkbox" class="btn-check" id="textItalic" autocomplete="off">
                        <label class="btn btn-outline-secondary" for="textItalic">
                            <em>I</em> Kursiv
                        </label>
                    </div>
                </div>

                <!-- Color and Author in one row -->
                <div class="row mb-2">
                    <div class="col-md-6">
                        <label for="textColor" class="form-label small mb-1">üé® Textfarbe</label>
                        <input type="color" class="form-control form-control-color" id="textColor" value="#000000">
                    </div>
                    <!-- Author information (only shown when editing existing text) -->
                    <div class="col-md-6" id="textAuthorInfo" style="display: none;">
                        <label class="form-label small mb-1">üë§ Erstellt von</label>
                        <p class="form-control-plaintext text-muted small mb-0" id="textAuthorName">-</p>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Abbrechen</button>
                <button type="button" class="btn btn-primary" id="addTextButton">Text hinzuf√ºgen</button>
            </div>
        </div>
    </div>
</div>

<!-- Shape Properties Modal -->
<div class="modal fade" id="shapePropertiesModal" tabindex="-1" aria-labelledby="shapePropertiesModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="shapePropertiesModalLabel">üé® Eigenschaften bearbeiten</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <!-- Live-Vorschau -->
                <div class="mb-3">
                    <label class="form-label">üëÅÔ∏è Vorschau</label>
                    <div id="shapePreview" style="border: 1px solid #ddd; padding: 15px; height: 100px; background: #f9f9f9; border-radius: 5px; display: flex; align-items: center; justify-content: center;">
                        <div id="shapePreviewElement" style="width: 60px; height: 60px; background: #000000; border: 2px solid #000000;"></div>
                    </div>
                </div>

                <div class="row">
                    <div class="col-md-6">
                        <div class="mb-3">
                            <label for="shapeColor" class="form-label">üé® Farbe</label>
                            <input type="color" class="form-control form-control-color" id="shapeColor" value="#000000">
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="mb-3">
                            <label for="shapeStrokeWidth" class="form-label">üìè Strichst√§rke</label>
                            <input type="range" class="form-range" id="shapeStrokeWidth" min="1" max="20" value="2">
                            <div class="text-center"><span id="shapeStrokeWidthValue">2</span>px</div>
                        </div>
                    </div>
                </div>

                <div class="row">
                    <div class="col-md-6">
                        <div class="mb-3">
                            <label for="shapeOpacity" class="form-label">üîç Transparenz</label>
                            <input type="range" class="form-range" id="shapeOpacity" min="0" max="100" value="100">
                            <div class="text-center"><span id="shapeOpacityValue">100</span>%</div>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <!-- Fill option for geometric shapes - 2x2 grid position -->
                        <div class="mb-3" id="shapeFillOption" style="display: none;">
                            <label class="form-label">üé® F√ºllung</label>
                            <div class="form-check form-switch">
                                <input class="form-check-input" type="checkbox" id="shapeFilled">
                                <label class="form-check-label" for="shapeFilled">
                                    Form ausf√ºllen
                                </label>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Author information -->
                <div class="row" id="shapeAuthorInfo" style="display: none;">
                    <div class="col-12">
                        <div class="mb-2">
                            <label class="form-label small mb-1">üë§ Erstellt von</label>
                            <p class="form-control-plaintext text-muted small mb-0" id="shapeAuthorName">-</p>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Abbrechen</button>
                <button type="button" class="btn btn-primary" id="updateShapeButton">Eigenschaften aktualisieren</button>
            </div>
        </div>
    </div>
</div>

<script>
class IdeaBoard {
    constructor() {
        console.log('IdeaBoard constructor starting...');

        this.canvas = document.getElementById('drawing-canvas');
        if (!this.canvas) {
            console.error('Canvas not found!');
            return;
        }

        this.ctx = this.canvas.getContext('2d');
        this.isDrawing = false;
        this.currentTool = 'select';
        this.currentColor = '#000000';
        this.currentStrokeWidth = 2;
        this.currentOpacity = 1.0;
        this.startX = 0;
        this.startY = 0;
        this.elements = [];
        this.currentPath = [];
        this.selectedElement = null;
        this.isDragging = false;
        this.isResizing = false;
        this.resizeHandle = null;
        this.dragOffset = {x: 0, y: 0};

        // Performance optimization variables
        this.isDragActive = false;
        this.pendingUpdate = null;
        this.updateTimeout = null;
        this.debouncedUpdateDelay = 150; // ms
        this.pollingPaused = false;
        this.redrawScheduled = false;

        // Trash zone tracking
        this.isOverTrashZone = false;
        this.justDeleted = false;

        // Zoom and pan variables
        this.zoomLevel = 1;
        this.panX = 0;
        this.panY = 0;
        this.handToolActive = false;
        this.isPanning = false;
        this.lastPanX = 0;
        this.lastPanY = 0;
        
        console.log('Calling initEventListeners...');
        this.initEventListeners();
        
        console.log('Loading existing elements...');
        this.loadExistingElements();
        
        console.log('Setting up polling...');
        this.setupPolling();
        
        // Set initial cursor for default tool (select)
        this.updateCursor();
        
        console.log('IdeaBoard constructor completed');
    }
    
    initEventListeners() {
        console.log('initEventListeners called');
        
        // Canvas Events - Mouse
        this.canvas.addEventListener('mousedown', (e) => this.startDrawing(e));
        this.canvas.addEventListener('mousemove', (e) => this.draw(e));
        this.canvas.addEventListener('mouseup', (e) => {
            this.stopDrawing(e);
        });
        this.canvas.addEventListener('mouseout', (e) => {
            // Don't stop dragging on mouseout - only stop drawing/creating new elements
            if (this.isDrawing && !this.isDragging) {
                this.stopDrawing(e);
            }
        });
        this.canvas.addEventListener('dblclick', (e) => this.handleDoubleClick(e));
        
        // Global mouse events to handle dragging outside canvas
        document.addEventListener('mouseup', (e) => {
            if (this.isDragging) {
                this.stopDrawing(e);
            }
        });

        // Canvas Events - Touch (for mobile)
        this.canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            this.startDrawing(mouseEvent);
        });
        
        this.canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousemove', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            this.draw(mouseEvent);
        });
        
        this.canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            const mouseEvent = new MouseEvent('mouseup', {});
            this.stopDrawing(mouseEvent);
        });
        
        // Tool Selection - Force event handling
        const toolButtons = document.querySelectorAll('.tool-btn');
        console.log('Found tool buttons:', toolButtons.length);
        
        toolButtons.forEach((btn, index) => {
            console.log(`Button ${index}:`, btn.getAttribute('data-tool'));
            
            // Remove any existing event listeners by cloning
            const newBtn = btn.cloneNode(true);
            btn.parentNode.replaceChild(newBtn, btn);
            
            newBtn.addEventListener('click', (e) => {
                console.log('Button clicked:', newBtn.getAttribute('data-tool'));
                
                // Remove active class from all buttons
                document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                
                // Add active class to clicked button
                newBtn.classList.add('active');
                
                // Set the tool
                this.currentTool = newBtn.getAttribute('data-tool');

                // Show/hide tool controls based on selected tool
                this.toggleToolControls();

                // Deactivate hand tool when any drawing tool is selected
                if (this.handToolActive) {
                    this.deactivateHandTool();
                }
                
                this.updateCursor();
                console.log('Tool set to:', this.currentTool);
                
                e.preventDefault();
                e.stopPropagation();
            }, true);
        });
        
        // Color Picker
        const colorPicker = document.getElementById('color-picker');

        // Use both 'input' and 'change' events for better browser compatibility
        const handleColorChange = (e) => {
            this.currentColor = e.target.value;
            // Apply to selected element if any (only if not currently editing)
            if (this.selectedElement && !this.editingElement) {
                this.selectedElement.color = e.target.value;
                // For text elements, also update the textColor in data
                if (this.selectedElement.element_type === 'text') {
                    this.selectedElement.data.textColor = e.target.value;
                }
                this.scheduleRedraw();
                this.scheduleServerUpdate(this.selectedElement);
            }
        };

        colorPicker.addEventListener('input', handleColorChange);
        colorPicker.addEventListener('change', handleColorChange);

        // Stroke Width
        document.getElementById('stroke-width').addEventListener('input', (e) => {
            this.currentStrokeWidth = parseInt(e.target.value);
            document.getElementById('stroke-width-value').textContent = e.target.value;
            // Apply to selected element if any (but not text elements, and not while editing)
            if (this.selectedElement && this.selectedElement.element_type !== 'text' && !this.editingElement) {
                this.selectedElement.stroke_width = parseInt(e.target.value);
                this.scheduleRedraw();
                this.scheduleServerUpdate(this.selectedElement);
            }
        });
        
        // Opacity
        document.getElementById('opacity').addEventListener('input', (e) => {
            this.currentOpacity = parseFloat(e.target.value) / 100;
            document.getElementById('opacity-value').textContent = e.target.value;
            // Apply to selected element if any (only if not currently editing)
            if (this.selectedElement && !this.editingElement) {
                this.selectedElement.opacity = parseFloat(e.target.value) / 100;
                this.scheduleRedraw();
                this.scheduleServerUpdate(this.selectedElement);
            }
        });

        // Font Size (for text elements)
        document.getElementById('font-size').addEventListener('input', (e) => {
            const fontSize = parseInt(e.target.value);
            document.getElementById('font-size-value').textContent = e.target.value;
            // Apply to selected text element if any (only if not currently editing)
            if (this.selectedElement && this.selectedElement.element_type === 'text' && !this.editingElement) {
                this.selectedElement.data.fontSize = fontSize;
                this.scheduleRedraw();
                this.scheduleServerUpdate(this.selectedElement);
            }
        });
        
        // Undo Button
        document.getElementById('undo-action').addEventListener('click', () => {
            this.undoLastAction();
        });
        
        // Clear Canvas
        document.getElementById('clear-canvas').addEventListener('click', () => {
            if (confirm('M√∂chten Sie das Canvas wirklich l√∂schen?')) {
                this.clearCanvas();
            }
        });
        
        // Save Board
        document.getElementById('save-board').addEventListener('click', () => {
            this.saveBoard();
        });

        // Download Board as JPG
        document.getElementById('download-board').addEventListener('click', () => {
            this.downloadBoard();
        });
        
        // Zoom controls
        document.getElementById('zoom-in').addEventListener('click', () => {
            this.zoomIn();
        });
        
        document.getElementById('hand-tool').addEventListener('click', () => {
            this.toggleHandTool();
        });
        
        document.getElementById('zoom-out').addEventListener('click', () => {
            this.zoomOut();
        });
        
        // Center button
        document.getElementById('nav-center').addEventListener('click', () => {
            this.resetCanvasView();
        });

        // Text Modal Button
        document.getElementById('addTextButton').addEventListener('click', () => {
            this.handleTextSubmit();
        });

        // Text Preview Event Listeners
        document.getElementById('textInput').addEventListener('input', () => this.updateTextPreview());
        document.getElementById('textFontSize').addEventListener('change', () => this.updateTextPreview());
        document.getElementById('textFontFamily').addEventListener('change', () => this.updateTextPreview());
        document.getElementById('textBold').addEventListener('change', () => this.updateTextPreview());
        document.getElementById('textItalic').addEventListener('change', () => this.updateTextPreview());
        document.getElementById('textColor').addEventListener('change', () => this.updateTextPreview());

        // Shape Properties Modal Event Listeners
        document.getElementById('updateShapeButton').addEventListener('click', () => {
            this.handleShapePropertiesSubmit();
        });

        // Shape Preview Event Listeners
        document.getElementById('shapeColor').addEventListener('change', () => this.updateShapePreview());
        document.getElementById('shapeStrokeWidth').addEventListener('input', () => this.updateShapePreview());
        document.getElementById('shapeOpacity').addEventListener('input', () => this.updateShapePreview());
        document.getElementById('shapeFilled').addEventListener('change', () => this.updateShapePreview());
    }
    
    getCanvasCoordinates(e) {
        const rect = this.canvas.getBoundingClientRect();
        const scaleX = this.canvas.width / rect.width;
        const scaleY = this.canvas.height / rect.height;
        
        return {
            x: (e.clientX - rect.left) * scaleX,
            y: (e.clientY - rect.top) * scaleY
        };
    }
    
    startDrawing(e) {
        const coords = this.getCanvasCoordinates(e);
        this.startX = coords.x;
        this.startY = coords.y;
        
        // Handle hand tool panning
        if (this.handToolActive) {
            this.isPanning = true;
            this.lastPanX = e.clientX;
            this.lastPanY = e.clientY;
            this.canvas.style.cursor = 'grabbing';
            return;
        }
        
        if (this.currentTool === 'select') {
            this.handleSelection(this.startX, this.startY);
            return;
        }
        
        this.isDrawing = true;
        
        if (this.currentTool === 'pen' || this.currentTool === 'brush') {
            this.currentPath = [{x: this.startX, y: this.startY}];
        }
    }
    
    draw(e) {
        const coords = this.getCanvasCoordinates(e);
        const currentX = coords.x;
        const currentY = coords.y;
        
        // Handle hand tool panning
        if (this.isPanning && this.handToolActive) {
            const deltaX = e.clientX - this.lastPanX;
            const deltaY = e.clientY - this.lastPanY;
            
            this.panX += deltaX;
            this.panY += deltaY;
            this.applyCanvasTransform();
            
            this.lastPanX = e.clientX;
            this.lastPanY = e.clientY;
            return;
        }
        
        if (this.currentTool === 'select') {
            // Check if dragging element over trash can for visual feedback
            if (this.isDragging && this.selectedElement && e) {
                const canvasTrash = document.getElementById('canvas-trash-zone');

                if (canvasTrash) {
                    // Check if mouse position is over the trash area
                    const canvasRect = this.canvas.getBoundingClientRect();
                    const trashRect = canvasTrash.getBoundingClientRect();

                    const isOverTrash = (
                        e.clientX >= trashRect.left &&
                        e.clientX <= trashRect.right &&
                        e.clientY >= trashRect.top &&
                        e.clientY <= trashRect.bottom
                    );

                    if (isOverTrash) {
                        // Highlight when hovering with dragged element
                        canvasTrash.style.background = 'rgba(220, 53, 69, 0.9)';
                        canvasTrash.style.borderColor = '#dc3545';
                        canvasTrash.style.transform = 'scale(1.2)';
                        canvasTrash.innerHTML = `
                            <div style="text-align: center; color: white; font-weight: bold;">
                                <div style="font-size: 20px;">üóëÔ∏è</div>
                                <div style="font-size: 8px; line-height: 1;">LOSLASSEN!</div>
                            </div>`;

                        // Store that we're over trash for the drop check
                        this.isOverTrashZone = true;
                    } else {
                        // Reset when not hovering
                        canvasTrash.style.background = 'rgba(255, 193, 7, 0.8)';
                        canvasTrash.style.borderColor = '#ffc107';
                        canvasTrash.style.transform = 'scale(1)';
                        canvasTrash.innerHTML = `
                            <div style="text-align: center; color: #856404; font-weight: bold;">
                                <div style="font-size: 20px;">üóëÔ∏è</div>
                                <div style="font-size: 8px; line-height: 1;">L√ñSCHEN</div>
                            </div>`;

                        this.isOverTrashZone = false;
                    }
                }
            }

            this.handleDragOrResize(currentX, currentY);
            return;
        }
        
        if (!this.isDrawing) return;
        
        this.ctx.globalAlpha = this.currentOpacity;
        this.ctx.strokeStyle = this.currentColor;
        this.ctx.fillStyle = this.currentColor;
        this.ctx.lineWidth = this.currentStrokeWidth;
        this.ctx.lineCap = 'round';
        this.ctx.lineJoin = 'round';
        
        // Tempor√§res Canvas f√ºr Vorschau bei Formen
        if (['rectangle', 'circle', 'triangle', 'line', 'arrow'].includes(this.currentTool)) {
            this.drawShapePreview(currentX, currentY);
            return;
        }

        switch (this.currentTool) {
            case 'pen':
                this.ctx.beginPath();
                this.ctx.moveTo(this.startX, this.startY);
                this.ctx.lineTo(currentX, currentY);
                this.ctx.stroke();
                this.currentPath.push({x: currentX, y: currentY});
                this.startX = currentX;
                this.startY = currentY;
                break;

            case 'brush':
                // Live brush effect during drawing
                this.drawLiveBrushStroke(this.startX, this.startY, currentX, currentY);
                this.currentPath.push({x: currentX, y: currentY});
                this.startX = currentX;
                this.startY = currentY;
                break;


            case 'text':
                // Text wird beim Klick hinzugef√ºgt
                break;
        }
    }

    drawShapePreview(currentX, currentY) {
        // Redraw canvas
        this.redrawCanvas();
        
        // Draw preview
        this.ctx.globalAlpha = this.currentOpacity;
        this.ctx.strokeStyle = this.currentColor;
        this.ctx.fillStyle = this.currentColor;
        this.ctx.lineWidth = this.currentStrokeWidth;
        
        // Set consistent line rendering properties for preview
        this.ctx.lineCap = 'round';
        this.ctx.lineJoin = 'round';
        
        const width = currentX - this.startX;
        const height = currentY - this.startY;
        
        switch (this.currentTool) {
            case 'rectangle':
                this.ctx.strokeRect(this.startX, this.startY, width, height);
                break;
                
            case 'circle':
                const radius = Math.sqrt(width * width + height * height);
                this.ctx.beginPath();
                this.ctx.arc(this.startX, this.startY, radius, 0, 2 * Math.PI);
                this.ctx.stroke();
                break;
                
            case 'triangle':
                this.ctx.beginPath();
                this.ctx.moveTo(this.startX, this.startY);
                this.ctx.lineTo(currentX, currentY);
                this.ctx.lineTo(this.startX - width, currentY);
                this.ctx.closePath();
                this.ctx.stroke();
                break;
                
            case 'line':
                this.ctx.beginPath();
                this.ctx.moveTo(this.startX, this.startY);
                this.ctx.lineTo(currentX, currentY);
                this.ctx.stroke();
                break;
                
            case 'arrow':
                this.drawArrow(this.startX, this.startY, currentX, currentY);
                break;
        }
    }
    
    drawArrow(fromX, fromY, toX, toY) {
        const headLen = 10; // length of head in pixels
        const dx = toX - fromX;
        const dy = toY - fromY;
        const angle = Math.atan2(dy, dx);
        
        // Draw the line
        this.ctx.beginPath();
        this.ctx.moveTo(fromX, fromY);
        this.ctx.lineTo(toX, toY);
        this.ctx.stroke();
        
        // Draw the arrow head
        this.ctx.beginPath();
        this.ctx.moveTo(toX, toY);
        this.ctx.lineTo(toX - headLen * Math.cos(angle - Math.PI / 6), toY - headLen * Math.sin(angle - Math.PI / 6));
        this.ctx.moveTo(toX, toY);
        this.ctx.lineTo(toX - headLen * Math.cos(angle + Math.PI / 6), toY - headLen * Math.sin(angle + Math.PI / 6));
        this.ctx.stroke();
    }

    drawBrushStroke(path, strokeWidth) {
        // Pinsel-Effekt: unregelm√§√üige, texturierte Striche
        this.ctx.save();
        this.ctx.lineCap = 'round';
        this.ctx.lineJoin = 'round';

        for (let i = 0; i < path.length - 1; i++) {
            const currentPoint = path[i];
            const nextPoint = path[i + 1];

            // Variiere die Strichst√§rke f√ºr nat√ºrlichen Effekt
            const variance = strokeWidth * 0.3;
            const currentWidth = strokeWidth + (Math.random() - 0.5) * variance;
            this.ctx.lineWidth = Math.max(1, currentWidth);

            // Zeichne mehrere parallele Linien mit leichten Vers√§tzen f√ºr Textur
            const numStrokes = Math.max(2, Math.floor(strokeWidth / 2));

            for (let j = 0; j < numStrokes; j++) {
                this.ctx.beginPath();

                // F√ºge zuf√§llige Vers√§tze hinzu f√ºr unregelm√§√üigen Effekt
                const offset = (Math.random() - 0.5) * strokeWidth * 0.4;
                const perpAngle = Math.atan2(nextPoint.y - currentPoint.y, nextPoint.x - currentPoint.x) + Math.PI / 2;

                const startX = currentPoint.x + Math.cos(perpAngle) * offset;
                const startY = currentPoint.y + Math.sin(perpAngle) * offset;
                const endX = nextPoint.x + Math.cos(perpAngle) * offset;
                const endY = nextPoint.y + Math.sin(perpAngle) * offset;

                this.ctx.moveTo(startX, startY);
                this.ctx.lineTo(endX, endY);

                // Variiere die Transparenz f√ºr unregelm√§√üigen Effekt
                const alpha = 0.3 + Math.random() * 0.4;
                this.ctx.globalAlpha = alpha;
                this.ctx.stroke();
            }
        }

        this.ctx.restore();
    }

    drawLiveBrushStroke(startX, startY, endX, endY) {
        // Live brush effect during drawing - simpler version for real-time performance
        this.ctx.save();
        this.ctx.lineCap = 'round';
        this.ctx.lineJoin = 'round';

        // Create multiple slightly offset strokes for texture effect
        const numStrokes = Math.max(2, Math.floor(this.currentStrokeWidth / 3));

        for (let i = 0; i < numStrokes; i++) {
            this.ctx.beginPath();

            // Add random offset for irregular effect
            const offset = (Math.random() - 0.5) * this.currentStrokeWidth * 0.3;
            const angle = Math.atan2(endY - startY, endX - startX) + Math.PI / 2;

            const offsetStartX = startX + Math.cos(angle) * offset;
            const offsetStartY = startY + Math.sin(angle) * offset;
            const offsetEndX = endX + Math.cos(angle) * offset;
            const offsetEndY = endY + Math.sin(angle) * offset;

            this.ctx.moveTo(offsetStartX, offsetStartY);
            this.ctx.lineTo(offsetEndX, offsetEndY);

            // Vary line width slightly
            this.ctx.lineWidth = this.currentStrokeWidth + (Math.random() - 0.5) * this.currentStrokeWidth * 0.2;

            // Vary opacity for texture
            this.ctx.globalAlpha = (this.currentOpacity || 1) * (0.4 + Math.random() * 0.4);

            this.ctx.stroke();
        }

        this.ctx.restore();
    }

    redrawCanvas() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Redraw all saved elements
        this.elements.forEach(element => {
            this.drawElement(element);
        });
        
        // Draw selection handles if an element is selected
        this.drawSelectionHandles();
    }
    
    drawElement(element) {
        // Handle opacity correctly - use 1.0 only if opacity is undefined, not if it's 0
        this.ctx.globalAlpha = element.opacity !== undefined ? element.opacity : 1.0;
        this.ctx.strokeStyle = element.color || '#000000';
        this.ctx.fillStyle = element.color || '#000000';
        this.ctx.lineWidth = element.stroke_width || 2;
        
        // Set consistent line rendering properties
        this.ctx.lineCap = 'round';
        this.ctx.lineJoin = 'round';
        
        // Apply rotation if present
        if (element.rotation && element.rotation !== 0) {
            const bounds = this.getElementBounds(element);
            const centerX = bounds.x + bounds.width / 2;
            const centerY = bounds.y + bounds.height / 2;
            
            
            this.ctx.save();
            this.ctx.translate(centerX, centerY);
            this.ctx.rotate(element.rotation * Math.PI / 180);
            this.ctx.translate(-centerX, -centerY);
        }
        
        const data = element.data;
        
        switch (element.element_type) {
            case 'rectangle':
                if (data.filled === true) {
                    // Filled rectangle (default behavior)
                    this.ctx.fillRect(data.x, data.y, data.width, data.height);
                    this.ctx.strokeRect(data.x, data.y, data.width, data.height);
                } else {
                    // Hollow rectangle
                    this.ctx.strokeRect(data.x, data.y, data.width, data.height);
                }
                break;

            case 'circle':
                this.ctx.beginPath();
                this.ctx.arc(data.x, data.y, data.radius, 0, 2 * Math.PI);
                if (data.filled === true) {
                    // Filled circle (default behavior)
                    this.ctx.fill();
                    this.ctx.stroke();
                } else {
                    // Hollow circle
                    this.ctx.stroke();
                }
                break;

            case 'triangle':
                this.ctx.beginPath();
                this.ctx.moveTo(data.x1, data.y1);
                this.ctx.lineTo(data.x2, data.y2);
                this.ctx.lineTo(data.x3, data.y3);
                this.ctx.closePath();
                if (data.filled === true) {
                    // Filled triangle (default behavior)
                    this.ctx.fill();
                    this.ctx.stroke();
                } else {
                    // Hollow triangle
                    this.ctx.stroke();
                }
                break;
                
            case 'line':
                this.ctx.beginPath();
                this.ctx.moveTo(data.x1, data.y1);
                this.ctx.lineTo(data.x2, data.y2);
                this.ctx.stroke();
                break;
                
            case 'arrow':
                this.drawArrow(data.x1, data.y1, data.x2, data.y2);
                break;
                
            case 'freehand':
                if (data.path && data.path.length > 1) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(data.path[0].x, data.path[0].y);
                    for (let i = 1; i < data.path.length; i++) {
                        this.ctx.lineTo(data.path[i].x, data.path[i].y);
                    }
                    this.ctx.stroke();
                }
                break;

            case 'brush':
                if (data.path && data.path.length > 1) {
                    this.drawBrushStroke(data.path, element.stroke_width || 2);
                }
                break;
                
            case 'text':
                const fontSize = data.fontSize || 16;
                const fontFamily = data.fontFamily || 'Arial, sans-serif';
                const fontWeight = data.fontWeight || 'normal';
                const fontStyle = data.fontStyle || 'normal';
                const textColor = data.textColor || element.color || this.currentColor;

                // Draw main text
                this.ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;
                this.ctx.fillStyle = textColor;
                this.ctx.fillText(data.text, data.x, data.y);
                break;
        }
        
        // Restore transformation if rotation was applied
        if (element.rotation && element.rotation !== 0) {
            this.ctx.restore();
        }

        // Author info is now only shown in edit modals, not on selection
        // this.drawAuthorInfo(element);
    }

    drawAuthorInfo(element) {
        // Only show author info if this element is selected and has a creator
        if (!element.created_by || !this.selectedElement || this.selectedElement.id !== element.id) {
            return;
        }

        const bounds = this.getElementBounds(element);
        const data = element.data;

        // Determine position for author text based on element type
        let authorX = bounds.x;
        let authorY = bounds.y + bounds.height + 15; // 15px below the element

        // Special positioning for different element types
        switch (element.element_type) {
            case 'text':
                // For text, position it at top-right within text bounds
                const fontSize = data.fontSize || 16;

                // Measure the main text width to position author within bounds
                this.ctx.font = `${data.fontStyle || 'normal'} ${data.fontWeight || 'normal'} ${fontSize}px ${data.fontFamily || 'Arial, sans-serif'}`;
                const textWidth = this.ctx.measureText(data.text).width;

                // Calculate author font size (larger, but reasonable)
                const authorFontSize = Math.max(10, fontSize * 0.6); // 60% of main text, minimum 10px

                // Measure author text width to ensure it fits within bounds
                this.ctx.font = `italic ${authorFontSize}px Arial, sans-serif`;
                const authorTextWidth = this.ctx.measureText(element.created_by).width;

                // Position author at top-right, but ensure it stays within text bounds
                authorX = data.x + textWidth - authorTextWidth - 2; // 2px margin from right edge
                authorY = data.y - 4; // Just above the main text baseline
                break;
            case 'line':
            case 'arrow':
                // For lines/arrows, position at the end point
                authorX = Math.max(data.x1, data.x2);
                authorY = Math.max(data.y1, data.y2) + 15;
                break;
            default:
                // For shapes (rectangles, circles, etc.), position below
                authorY = bounds.y + bounds.height + 15;
                authorX = bounds.x;
                break;
        }

        // Draw author info with special styling for text elements
        let authorFontSize = 10; // Fixed small size for most elements
        let authorText = `by ${element.created_by}`;

        if (element.element_type === 'text') {
            // For text elements, use the pre-calculated font size from positioning
            const mainFontSize = data.fontSize || 16;
            authorFontSize = Math.max(10, mainFontSize * 0.6); // Larger for text: 60% of main text
            authorText = element.created_by; // Just the name, no "by"
        }

        this.ctx.font = `italic ${authorFontSize}px Arial, sans-serif`;

        // Use different opacity for text vs other elements
        if (element.element_type === 'text') {
            this.ctx.fillStyle = 'rgba(100, 100, 100, 0.6)'; // More visible for text
        } else {
            this.ctx.fillStyle = 'rgba(120, 120, 120, 0.4)'; // Subtle for other elements
        }

        this.ctx.fillText(authorText, authorX, authorY);
    }
    
    stopDrawing(event) {
        console.log('STOPDRAWING - Tool:', this.currentTool, 'Dragging:', this.isDragging, 'Event:', event?.type);

        // Handle hand tool panning
        if (this.isPanning && this.handToolActive) {
            this.isPanning = false;
            this.canvas.style.cursor = 'grab';
            return;
        }

        if (this.currentTool === 'select') {
            // Check for deletion on mouseup events
            if (this.isDragging && this.selectedElement && event && event.type === 'mouseup') {
                const canvasTrash = document.getElementById('canvas-trash-zone');

                if (canvasTrash) {
                    // Check current mouse position over trash at the moment of mouseup
                    const trashRect = canvasTrash.getBoundingClientRect();

                    const isOverTrashNow = (
                        event.clientX >= trashRect.left &&
                        event.clientX <= trashRect.right &&
                        event.clientY >= trashRect.top &&
                        event.clientY <= trashRect.bottom
                    );

                    console.log('TRASH CHECK: Over trash =', isOverTrashNow, 'Element ID =', this.selectedElement?.id);

                    if (isOverTrashNow) {
                        console.log('DELETING ELEMENT:', this.selectedElement);

                        // Store element reference before clearing selection
                        const elementToDelete = this.selectedElement;

                        // Stop dragging immediately to prevent further position updates
                        this.isDragging = false;
                        this.isDragActive = false;

                        // Clear selection immediately to remove selection frame
                        this.selectedElement = null;

                        // Delete element using existing method
                        this.deleteElement(elementToDelete);

                        // Redraw canvas immediately
                        this.scheduleRedraw();

                        // Show deletion feedback
                        canvasTrash.style.background = 'rgba(40, 167, 69, 0.9)';
                        canvasTrash.style.borderColor = '#28a745';
                        canvasTrash.innerHTML = `
                            <div style="text-align: center; color: white; font-weight: bold;">
                                <div style="font-size: 20px;">‚úì</div>
                                <div style="font-size: 8px; line-height: 1;">GEL√ñSCHT!</div>
                            </div>`;

                        // Reset after short delay
                        setTimeout(() => {
                            canvasTrash.style.background = 'rgba(255, 193, 7, 0.8)';
                            canvasTrash.style.borderColor = '#ffc107';
                            canvasTrash.style.transform = 'scale(1)';
                            canvasTrash.innerHTML = `
                                <div style="text-align: center; color: #856404; font-weight: bold;">
                                    <div style="font-size: 20px;">üóëÔ∏è</div>
                                    <div style="font-size: 8px; line-height: 1;">L√ñSCHEN</div>
                                </div>`;
                        }, 1000);

                        // Resume polling immediately
                        this.resumePolling();

                        // Mark that we handled deletion and return to avoid normal processing
                        this.justDeleted = true;
                        return;
                    }
                }
            }

            // End drag operation and resume polling
            if (this.isDragActive) {
                this.isDragActive = false;
                this.resumePolling();
                this.finalizePendingUpdate();
            }

            this.isDragging = false;
            this.isResizing = false;
            this.isRotating = false;
            this.resizeHandle = null;

            // Reset canvas trash when stopping drag (if not deleted)
            if (!this.justDeleted) {
                const canvasTrash = document.getElementById('canvas-trash-zone');
                if (canvasTrash) {
                    canvasTrash.style.background = 'rgba(255, 193, 7, 0.8)';
                    canvasTrash.style.borderColor = '#ffc107';
                    canvasTrash.style.transform = 'scale(1)';
                    canvasTrash.innerHTML = `
                        <div style="text-align: center; color: #856404; font-weight: bold;">
                            <div style="font-size: 20px;">üóëÔ∏è</div>
                            <div style="font-size: 8px; line-height: 1;">L√ñSCHEN</div>
                        </div>`;
                }
            }

            // Reset flags
            this.isOverTrashZone = false;
            this.justDeleted = false;

            return;
        }
        
        if (!this.isDrawing) return;
        this.isDrawing = false;
        
        const coords = event ? this.getCanvasCoordinates(event) : {x: this.startX, y: this.startY};
        const endX = coords.x;
        const endY = coords.y;
        
        const width = endX - this.startX;
        const height = endY - this.startY;
        
        switch (this.currentTool) {
            case 'pen':
                this.saveElement('freehand', {
                    path: this.currentPath,
                    color: this.currentColor,
                    strokeWidth: this.currentStrokeWidth,
                    opacity: this.currentOpacity
                });
                break;

            case 'brush':
                this.saveElement('brush', {
                    path: this.currentPath,
                    color: this.currentColor,
                    strokeWidth: this.currentStrokeWidth,
                    opacity: this.currentOpacity
                });
                break;
                
            case 'rectangle':
                if (Math.abs(width) > 5 && Math.abs(height) > 5) {
                    this.saveElement('rectangle', {
                        x: this.startX,
                        y: this.startY,
                        width: width,
                        height: height,
                        filled: false // Default to hollow for new shapes
                    });
                }
                break;
                
            case 'circle':
                const radius = Math.sqrt(width * width + height * height);
                if (radius > 5) {
                    this.saveElement('circle', {
                        x: this.startX,
                        y: this.startY,
                        radius: radius,
                        filled: false // Default to hollow for new shapes
                    });
                }
                break;
                
            case 'triangle':
                if (Math.abs(width) > 5 && Math.abs(height) > 5) {
                    this.saveElement('triangle', {
                        x1: this.startX,
                        y1: this.startY,
                        x2: endX,
                        y2: endY,
                        x3: this.startX - width,
                        y3: endY,
                        filled: false // Default to hollow for new shapes
                    });
                }
                break;
                
            case 'line':
                if (Math.abs(width) > 5 || Math.abs(height) > 5) {
                    this.saveElement('line', {
                        x1: this.startX,
                        y1: this.startY,
                        x2: endX,
                        y2: endY
                    });
                }
                break;
                
            case 'arrow':
                if (Math.abs(width) > 5 || Math.abs(height) > 5) {
                    this.saveElement('arrow', {
                        x1: this.startX,
                        y1: this.startY,
                        x2: endX,
                        y2: endY
                    });
                }
                break;
                
            case 'text':
                this.addText(this.startX, this.startY);
                break;
        }
    }
    
    addText(x, y) {
        // Position f√ºr sp√§ter speichern
        this.pendingTextX = x;
        this.pendingTextY = y;

        // Hide popup when opening text modal
        const popup = document.getElementById('tool-controls-popup');
        popup.style.display = 'none';

        // Modal √∂ffnen
        const modal = new bootstrap.Modal(document.getElementById('textInputModal'));

        // Felder zur√ºcksetzen
        document.getElementById('textInput').value = '';
        document.getElementById('textFontSize').value = '16';
        document.getElementById('textFontFamily').value = 'Arial, sans-serif';
        document.getElementById('textBold').checked = false;
        document.getElementById('textItalic').checked = false;
        document.getElementById('textColor').value = this.currentColor;

        modal.show();

        // Vorschau aktualisieren
        this.updateTextPreview();
    }

    updateTextPreview() {
        const textInput = document.getElementById('textInput').value || 'Vorschau des Textes...';
        const fontSize = document.getElementById('textFontSize').value;
        const fontFamily = document.getElementById('textFontFamily').value;
        const isBold = document.getElementById('textBold').checked;
        const isItalic = document.getElementById('textItalic').checked;
        const textColor = document.getElementById('textColor').value;

        const preview = document.getElementById('textPreview');
        preview.innerText = textInput;
        preview.style.fontSize = fontSize + 'px';
        preview.style.fontFamily = fontFamily;
        preview.style.fontWeight = isBold ? 'bold' : 'normal';
        preview.style.fontStyle = isItalic ? 'italic' : 'normal';
        preview.style.color = textColor;
    }

    isMouseOverElement(event, element) {
        const rect = element.getBoundingClientRect();
        return (
            event.clientX >= rect.left &&
            event.clientX <= rect.right &&
            event.clientY >= rect.top &&
            event.clientY <= rect.bottom
        );
    }

    deleteElement(element) {
        console.log('DELETING ELEMENT ID:', element?.id);

        // Remove from elements array immediately for visual feedback
        this.elements = this.elements.filter(el => el !== element);

        // Delete from server
        if (element.id) {
            console.log('SENDING DELETE REQUEST for ID:', element.id);
            fetch(`/organization/boards/{{ board.pk }}/elements/${element.id}/delete/`, {
                method: 'POST',
                headers: {
                    'X-CSRFToken': '{{ csrf_token }}',
                    'Content-Type': 'application/json',
                }
            }).then(response => {
                console.log('Delete response:', response.status, response.statusText);
                if (!response.ok) {
                    console.error('Failed to delete element from server:', response.status);
                    // Re-add element to local array if server delete failed
                    this.elements.push(element);
                    this.scheduleRedraw();
                } else {
                    console.log('Element successfully deleted from server');
                }
            }).catch(error => {
                console.error('Error deleting element:', error);
                // Re-add element to local array on error
                this.elements.push(element);
                this.scheduleRedraw();
            });
        } else {
            console.log('Element has no ID, only removing locally');
        }
    }

    handleDoubleClick(e) {
        if (this.currentTool !== 'select') return;

        const coords = this.getCanvasCoordinates(e);
        const x = coords.x;
        const y = coords.y;

        // Check if double-clicking on an element
        const clickedElement = this.getElementAt(x, y);
        if (clickedElement) {
            // Hide popup when opening edit modal
            const popup = document.getElementById('tool-controls-popup');
            popup.style.display = 'none';

            if (clickedElement.element_type === 'text') {
                this.editText(clickedElement);
            } else {
                // For other shapes, open properties modal
                this.editShapeProperties(clickedElement);
            }
        }
    }

    editText(textElement) {
        // Store reference to element being edited
        this.editingElement = textElement;

        // Open modal with current text values
        const modal = new bootstrap.Modal(document.getElementById('textInputModal'));

        // Fill form with current values
        const data = textElement.data;
        console.log('editText - textElement:', textElement);
        console.log('editText - data:', data);
        console.log('editText - fontSize in data:', data.fontSize);
        document.getElementById('textInput').value = data.text || '';
        const fontSizeValue = data.fontSize || 16;
        document.getElementById('textFontSize').value = fontSizeValue;
        console.log('Setting textFontSize input to:', fontSizeValue);
        console.log('Input value after setting:', document.getElementById('textFontSize').value);
        document.getElementById('textFontFamily').value = data.fontFamily || 'Arial, sans-serif';
        document.getElementById('textBold').checked = data.fontWeight === 'bold';
        document.getElementById('textItalic').checked = data.fontStyle === 'italic';
        document.getElementById('textColor').value = data.textColor || textElement.color || '#000000';

        // Change modal title and button text
        document.getElementById('textInputModalLabel').textContent = 'üìù Text bearbeiten';
        document.getElementById('addTextButton').textContent = 'Text aktualisieren';

        // Show author information
        if (textElement.created_by) {
            document.getElementById('textAuthorInfo').style.display = 'block';
            document.getElementById('textAuthorName').textContent = textElement.created_by;
        } else {
            document.getElementById('textAuthorInfo').style.display = 'none';
        }

        modal.show();

        // Update preview
        this.updateTextPreview();
    }

    handleTextSubmit() {
        const textInput = document.getElementById('textInput').value.trim();
        if (!textInput) return;

        const fontSize = parseInt(document.getElementById('textFontSize').value);
        const fontFamily = document.getElementById('textFontFamily').value;
        const isBold = document.getElementById('textBold').checked;
        const isItalic = document.getElementById('textItalic').checked;
        const textColor = document.getElementById('textColor').value;

        // Font style zusammenstellen
        let fontWeight = isBold ? 'bold' : 'normal';
        let fontStyle = isItalic ? 'italic' : 'normal';

        if (this.editingElement) {
            // Updating existing text element
            this.editingElement.data = {
                ...this.editingElement.data,
                text: textInput,
                fontSize: fontSize,
                fontFamily: fontFamily,
                fontWeight: fontWeight,
                fontStyle: fontStyle,
                textColor: textColor
            };

            // Update element color as well
            this.editingElement.color = textColor;

            // Schedule server update
            this.scheduleServerUpdate(this.editingElement);

            // Redraw canvas
            this.scheduleRedraw();

            // Clear editing reference
            this.editingElement = null;
        } else {
            // Creating new text element
            this.saveElement('text', {
                text: textInput,
                x: this.pendingTextX,
                y: this.pendingTextY,
                fontSize: fontSize,
                fontFamily: fontFamily,
                fontWeight: fontWeight,
                fontStyle: fontStyle,
                textColor: textColor
            });

            // Sofort zeichnen
            this.ctx.globalAlpha = this.currentOpacity;
            this.ctx.fillStyle = textColor;
            this.ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;
            this.ctx.fillText(textInput, this.pendingTextX, this.pendingTextY);
        }

        // Reset modal title and button text for next use
        document.getElementById('textInputModalLabel').textContent = 'üìù Text hinzuf√ºgen';
        document.getElementById('addTextButton').textContent = 'Text hinzuf√ºgen';

        // Hide author info for new texts
        document.getElementById('textAuthorInfo').style.display = 'none';

        // Modal schlie√üen
        const modal = bootstrap.Modal.getInstance(document.getElementById('textInputModal'));
        modal.hide();
    }

    editShapeProperties(element) {
        // Store reference to element being edited
        this.editingElement = element;

        // Open modal with current property values
        const modal = new bootstrap.Modal(document.getElementById('shapePropertiesModal'));

        // Fill form with current values
        document.getElementById('shapeColor').value = element.color || '#000000';
        document.getElementById('shapeStrokeWidth').value = element.stroke_width || 2;
        document.getElementById('shapeOpacity').value = Math.round((element.opacity || 1) * 100);

        // Update display values
        document.getElementById('shapeStrokeWidthValue').textContent = element.stroke_width || 2;
        document.getElementById('shapeOpacityValue').textContent = Math.round((element.opacity || 1) * 100);

        // Show/hide fill option for geometric shapes
        const shapeFillOption = document.getElementById('shapeFillOption');
        const geometricShapes = ['circle', 'rectangle', 'triangle'];
        if (geometricShapes.includes(element.element_type)) {
            shapeFillOption.style.display = 'block';
            // Set the filled state based on element data or default to false (hollow)
            document.getElementById('shapeFilled').checked = element.data?.filled === true;
        } else {
            shapeFillOption.style.display = 'none';
        }

        // Set modal title based on shape type
        const titleMap = {
            'rectangle': 'üìê Rechteck bearbeiten',
            'circle': '‚≠ï Kreis bearbeiten',
            'triangle': 'üî∫ Dreieck bearbeiten',
            'line': 'üìè Linie bearbeiten',
            'arrow': '‚û°Ô∏è Pfeil bearbeiten',
            'pen': '‚úèÔ∏è Stift bearbeiten',
            'brush': 'üñåÔ∏è Pinsel bearbeiten'
        };

        const title = titleMap[element.element_type] || 'üé® Eigenschaften bearbeiten';
        document.getElementById('shapePropertiesModalLabel').textContent = title;

        // Show author information
        if (element.created_by) {
            document.getElementById('shapeAuthorInfo').style.display = 'block';
            document.getElementById('shapeAuthorName').textContent = element.created_by;
        } else {
            document.getElementById('shapeAuthorInfo').style.display = 'none';
        }

        modal.show();

        // Update preview
        this.updateShapePreview();
    }

    updateShapePreview() {
        const color = document.getElementById('shapeColor').value;
        const strokeWidth = parseInt(document.getElementById('shapeStrokeWidth').value);
        const opacity = parseInt(document.getElementById('shapeOpacity').value) / 100;

        // Get filled state for geometric shapes
        const shapeFilled = document.getElementById('shapeFilled').checked;

        // Update display values
        document.getElementById('shapeStrokeWidthValue').textContent = strokeWidth;
        document.getElementById('shapeOpacityValue').textContent = Math.round(opacity * 100);

        const previewElement = document.getElementById('shapePreviewElement');

        // Reset all styles first
        previewElement.style.borderRadius = '';
        previewElement.style.background = '';
        previewElement.style.backgroundColor = '';
        previewElement.style.border = '';
        previewElement.style.borderLeft = '';
        previewElement.style.borderRight = '';
        previewElement.style.borderBottom = '';
        previewElement.style.borderTop = '';
        previewElement.style.height = '60px';
        previewElement.style.width = '60px';
        previewElement.innerHTML = '';

        // Update preview element based on editing element type
        if (this.editingElement) {
            const elementType = this.editingElement.element_type;
            console.log('Updating preview for element type:', elementType, 'filled:', shapeFilled);

            switch (elementType) {
                case 'circle':
                    previewElement.style.borderRadius = '50%';
                    if (shapeFilled) {
                        previewElement.style.backgroundColor = color;
                        previewElement.style.border = `${strokeWidth}px solid ${color}`;
                    } else {
                        previewElement.style.backgroundColor = 'transparent';
                        previewElement.style.border = `${strokeWidth}px solid ${color}`;
                    }
                    break;

                case 'rectangle':
                    previewElement.style.borderRadius = '4px';
                    if (shapeFilled) {
                        previewElement.style.backgroundColor = color;
                        previewElement.style.border = `${strokeWidth}px solid ${color}`;
                    } else {
                        previewElement.style.backgroundColor = 'transparent';
                        previewElement.style.border = `${strokeWidth}px solid ${color}`;
                    }
                    break;

                case 'triangle':
                    previewElement.style.backgroundColor = 'transparent';
                    previewElement.style.border = 'none';
                    previewElement.style.width = '60px';
                    previewElement.style.height = '60px';

                    // Use SVG for better triangle preview
                    if (shapeFilled) {
                        previewElement.innerHTML = `
                            <svg width="60" height="60" viewBox="0 0 60 60">
                                <polygon points="30,10 50,50 10,50"
                                         fill="${color}"
                                         stroke="${color}"
                                         stroke-width="${strokeWidth}"/>
                            </svg>`;
                    } else {
                        previewElement.innerHTML = `
                            <svg width="60" height="60" viewBox="0 0 60 60">
                                <polygon points="30,10 50,50 10,50"
                                         fill="none"
                                         stroke="${color}"
                                         stroke-width="${strokeWidth}"/>
                            </svg>`;
                    }
                    break;

                case 'line':
                    previewElement.style.backgroundColor = color;
                    previewElement.style.height = `${strokeWidth}px`;
                    previewElement.style.width = '60px';
                    previewElement.style.borderRadius = `${strokeWidth/2}px`;
                    break;

                case 'arrow':
                    // Create arrow shape with CSS
                    previewElement.style.backgroundColor = color;
                    previewElement.style.height = `${strokeWidth}px`;
                    previewElement.style.width = '50px';
                    previewElement.style.position = 'relative';
                    previewElement.style.borderRadius = `${strokeWidth/2}px`;

                    // Add arrow head using pseudo-element or create a simple representation
                    previewElement.innerHTML = `<div style="position: absolute; right: -${strokeWidth*2}px; top: -${strokeWidth*2}px; width: 0; height: 0; border-left: ${strokeWidth*3}px solid ${color}; border-top: ${strokeWidth*2}px solid transparent; border-bottom: ${strokeWidth*2}px solid transparent;"></div>`;
                    break;

                case 'pen':
                case 'brush':
                case 'freehand':
                    // Show a wavy line to represent freehand drawing
                    previewElement.style.backgroundColor = 'transparent';
                    previewElement.style.border = 'none';
                    previewElement.innerHTML = `
                        <svg width="60" height="60" viewBox="0 0 60 60">
                            <path d="M10,30 Q20,10 30,30 T50,30"
                                  stroke="${color}"
                                  stroke-width="${strokeWidth}"
                                  fill="none"
                                  stroke-linecap="round"/>
                        </svg>`;
                    break;

                default:
                    // Default to rectangle-like shape
                    previewElement.style.borderRadius = '4px';
                    previewElement.style.backgroundColor = color;
                    previewElement.style.border = `${strokeWidth}px solid ${color}`;
            }
        }

        previewElement.style.opacity = opacity;
    }

    handleShapePropertiesSubmit() {
        if (!this.editingElement) return;

        const color = document.getElementById('shapeColor').value;
        const strokeWidth = parseInt(document.getElementById('shapeStrokeWidth').value);
        const opacity = parseInt(document.getElementById('shapeOpacity').value) / 100;

        // Update element properties
        this.editingElement.color = color;
        this.editingElement.stroke_width = strokeWidth;
        this.editingElement.opacity = opacity;

        // Update filled state for geometric shapes
        const geometricShapes = ['circle', 'rectangle', 'triangle'];
        if (geometricShapes.includes(this.editingElement.element_type)) {
            const shapeFilled = document.getElementById('shapeFilled').checked;
            if (!this.editingElement.data) {
                this.editingElement.data = {};
            }
            this.editingElement.data.filled = shapeFilled;
        }

        // Update element on server
        if (this.editingElement.id) {
            const updateData = {
                color: color,
                stroke_width: strokeWidth,
                opacity: opacity
            };

            // Add filled state to data if it's a geometric shape
            if (geometricShapes.includes(this.editingElement.element_type)) {
                updateData.data = this.editingElement.data;
            }

            fetch(`/organization/boards/{{ board.pk }}/update-element/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': '{{ csrf_token }}'
                },
                body: JSON.stringify({
                    element_id: this.editingElement.id,
                    ...updateData
                })
            }).then(response => {
                if (response.ok) {
                    console.log('Shape properties updated successfully');
                    this.scheduleRedraw();
                } else {
                    console.error('Failed to update shape properties');
                }
            }).catch(error => {
                console.error('Error updating shape properties:', error);
            });
        }

        // Clear editing element
        this.editingElement = null;

        // Close modal
        const modal = bootstrap.Modal.getInstance(document.getElementById('shapePropertiesModal'));
        modal.hide();

        // Schedule redraw to show changes
        this.scheduleRedraw();
    }

    saveElement(type, data) {
        const element = {
            element_type: type,
            data: data,
            position_x: this.startX,
            position_y: this.startY,
            color: this.currentColor,
            stroke_width: this.currentStrokeWidth,
            opacity: this.currentOpacity,
            rotation: 0, // Default rotation
            layer_index: this.elements.length
        };
        
        fetch(`/organization/boards/{{ board.pk }}/save-element/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': '{{ csrf_token }}'
            },
            body: JSON.stringify(element)
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                element.id = data.id;
                this.elements.push(element);
                this.lastUpdate = Date.now();
            }
        });
    }
    
    undoLastAction() {
        if (this.elements.length === 0) {
            alert('Keine Aktion zum R√ºckg√§ngigmachen vorhanden');
            return;
        }
        
        // Get the last element
        const lastElement = this.elements[this.elements.length - 1];
        
        // Delete the last element from server
        fetch(`/organization/boards/{{ board.pk }}/elements/${lastElement.id}/delete/`, {
            method: 'DELETE',
            headers: {
                'X-CSRFToken': '{{ csrf_token }}',
                'Content-Type': 'application/json'
            }
        }).then(response => {
            if (response.ok) {
                // Remove from local array
                this.elements.pop();
                this.scheduleRedraw();
                // Force update check
                setTimeout(() => this.checkForUpdates(), 100);
            } else {
                alert('Fehler beim R√ºckg√§ngigmachen');
            }
        }).catch(error => {
            console.error('Error undoing action:', error);
            alert('Fehler beim R√ºckg√§ngigmachen');
        });
    }
    
    clearCanvas() {
        // Clear all elements on server
        fetch(`/organization/boards/{{ board.pk }}/clear-elements/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': '{{ csrf_token }}'
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                // Clear local canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.elements = [];
                // Force update for all users
                this.lastUpdate = 0;
                this.checkForUpdates();
            } else {
                alert('Fehler beim L√∂schen des Canvas');
            }
        })
        .catch(error => {
            console.error('Error clearing canvas:', error);
            alert('Fehler beim L√∂schen des Canvas');
        });
    }
    
    saveBoard() {
        alert('Board gespeichert!');
    }

    downloadBoard() {
        // Ask user what to download
        const choice = confirm('M√∂chten Sie Board + Notizen als ZIP herunterladen?\n\nOK = ZIP mit Board (JPG) + Notizen (TXT)\nAbbrechen = Nur Board als JPG');

        if (choice) {
            this.downloadBoardWithNotes();
        } else {
            this.downloadBoardOnly();
        }
    }

    downloadBoardOnly() {
        // Create a temporary canvas with white background
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');

        // Set canvas size to match the original
        tempCanvas.width = this.canvas.width;
        tempCanvas.height = this.canvas.height;

        // Fill with white background (JPG doesn't support transparency)
        tempCtx.fillStyle = 'white';
        tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

        // Draw the original canvas content on top
        tempCtx.drawImage(this.canvas, 0, 0);

        // Create download link
        tempCanvas.toBlob((blob) => {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `board_${new Date().getTime()}.jpg`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }, 'image/jpeg', 0.9); // 90% quality JPG
    }

    async downloadBoardWithNotes() {
        try {
            // Get notes content from Quill editor
            const notesContent = boardNotesManager ? boardNotesManager.quill.root.innerHTML : '';
            const plainTextNotes = boardNotesManager ? boardNotesManager.quill.getText() : '';

            // Create board image
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = this.canvas.width;
            tempCanvas.height = this.canvas.height;

            // Fill with white background
            tempCtx.fillStyle = 'white';
            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
            tempCtx.drawImage(this.canvas, 0, 0);

            // Convert canvas to blob
            tempCanvas.toBlob(async (imageBlob) => {
                // Create JSZip instance
                const zip = new JSZip();

                // Add board image to ZIP
                zip.file(`board_${new Date().getTime()}.jpg`, imageBlob);

                // Add notes as text file if there are any
                if (plainTextNotes.trim()) {
                    const notesText = `Board Notizen\n=============\n\nErstellt: ${new Date().toLocaleString('de-DE')}\nBoard: {{ board.title }}\n\n${plainTextNotes}`;
                    zip.file(`notizen_${new Date().getTime()}.txt`, notesText);
                }

                // Add notes as HTML file for formatting preservation
                if (notesContent.trim() && notesContent !== '<p><br></p>') {
                    const htmlContent = `<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Board Notizen - {{ board.title }}</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
        .header { border-bottom: 2px solid #ccc; margin-bottom: 20px; padding-bottom: 10px; }
        .notes-content { line-height: 1.6; }
    </style>
</head>
<body>
    <div class="header">
        <h1>Board Notizen</h1>
        <p><strong>Board:</strong> {{ board.title }}</p>
        <p><strong>Erstellt:</strong> ${new Date().toLocaleString('de-DE')}</p>
    </div>
    <div class="notes-content">
        ${notesContent}
    </div>
</body>
</html>`;
                    zip.file(`notizen_formatiert_${new Date().getTime()}.html`, htmlContent);
                }

                // Generate and download ZIP
                const zipBlob = await zip.generateAsync({type: 'blob'});
                const url = URL.createObjectURL(zipBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `board_komplett_${new Date().getTime()}.zip`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

            }, 'image/jpeg', 0.9);

        } catch (error) {
            console.error('Error creating download:', error);
            alert('Fehler beim Erstellen des Downloads: ' + error.message);
        }
    }
    
    loadExistingElements() {
        fetch(`/organization/boards/{{ board.pk }}/elements/`)
            .then(response => response.json())
            .then(data => {
                this.elements = data.elements || [];
                // Ensure all loaded elements have position values
                this.elements.forEach(element => {
                    this.ensureElementPosition(element);
                });
                this.scheduleRedraw();
            })
            .catch(error => {
                console.error('Error loading elements:', error);
            });
    }
    
    handleSelection(x, y) {
        // Check if clicking on resize/rotate handle
        if (this.selectedElement) {
            const handle = this.getResizeHandle(x, y);
            if (handle) {
                if (handle === 'rotate') {
                    this.isRotating = true;
                    this.isDragActive = true;
                    this.pausePolling();
                    const bounds = this.getElementBounds(this.selectedElement);
                    this.rotationCenter = {
                        x: bounds.x + bounds.width / 2,
                        y: bounds.y + bounds.height / 2
                    };
                    this.initialAngle = Math.atan2(y - this.rotationCenter.y, x - this.rotationCenter.x);
                    this.selectedElement.rotation = this.selectedElement.rotation || 0;
                } else {
                    this.isResizing = true;
                    this.isDragActive = true;
                    this.pausePolling();
                    this.resizeHandle = handle;
                }
                return;
            }
        }

        // Check if clicking on existing element
        const clickedElement = this.getElementAt(x, y);

        if (clickedElement) {
            if (this.selectedElement !== clickedElement) {
                this.selectedElement = clickedElement;
                this.scheduleRedraw();
                // Show tool controls popup when element is selected
                this.showToolControlsPopup();
            }
            this.isDragging = true;
            this.isDragActive = true;
            this.pausePolling();
            console.log('=== DRAG STARTED ===');
            console.log('Element:', clickedElement);
            console.log('Element ID:', clickedElement.id);
            console.log('Element position:', clickedElement.position_x, clickedElement.position_y);

            // Ensure position_x and position_y exist and are correct
            this.ensureElementPosition(clickedElement);

            this.dragOffset = {
                x: x - clickedElement.position_x,
                y: y - clickedElement.position_y
            };

        } else {
            // Clicked on empty space - deselect
            this.selectedElement = null;
            this.scheduleRedraw();
            // Hide tool controls popup when deselecting
            const popup = document.getElementById('tool-controls-popup');
            popup.style.display = 'none';
        }
    }
    
    handleDragOrResize(x, y) {
        if (this.isRotating && this.selectedElement) {
            this.rotateElement(x, y);
        } else if (this.isResizing && this.selectedElement) {
            this.resizeElement(x, y);
        } else if (this.isDragging && this.selectedElement) {
            this.dragElement(x, y);
        }
    }
    
    getElementAt(x, y) {
        // Search from top to bottom (reverse order)
        for (let i = this.elements.length - 1; i >= 0; i--) {
            const element = this.elements[i];
            if (this.isPointInElement(x, y, element)) {
                return element;
            }
        }
        return null;
    }
    
    isPointInElement(x, y, element) {
        const data = element.data;
        
        switch (element.element_type) {
            case 'rectangle':
                return x >= data.x && x <= data.x + data.width &&
                       y >= data.y && y <= data.y + data.height;
            
            case 'circle':
                const dx = x - data.x;
                const dy = y - data.y;
                return (dx * dx + dy * dy) <= (data.radius * data.radius);
            
            case 'triangle':
                // Simple bounding box check for triangles
                const minX = Math.min(data.x1, data.x2, data.x3);
                const maxX = Math.max(data.x1, data.x2, data.x3);
                const minY = Math.min(data.y1, data.y2, data.y3);
                const maxY = Math.max(data.y1, data.y2, data.y3);
                return x >= minX && x <= maxX && y >= minY && y <= maxY;
            
            case 'line':
            case 'arrow':
                // Check if point is near line with improved hit area
                const dist = this.distanceToLine(x, y, data.x1, data.y1, data.x2, data.y2);
                const lineHitRadius = Math.max(8, (element.stroke_width || 2) + 6); // Minimum 8px hit radius
                return dist <= lineHitRadius;
            
            case 'text':
                // Simple bounding box for text (author text is only shown when selected)
                const fontSize = data.fontSize || 16;
                const fontFamily = data.fontFamily || 'Arial, sans-serif';
                const fontWeight = data.fontWeight || 'normal';
                const fontStyle = data.fontStyle || 'normal';
                this.ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;
                const textWidth = this.ctx.measureText(data.text).width;

                return x >= data.x && x <= data.x + textWidth &&
                       y >= data.y - fontSize && y <= data.y;
            
            case 'freehand':
            case 'brush':
                // Check if point is near any point in the path with improved hit area
                const hitRadius = Math.max(10, (element.stroke_width || 2) + 8); // Minimum 10px hit radius

                // Also check line segments between points, not just individual points
                for (let i = 0; i < data.path.length; i++) {
                    if (i === 0) {
                        // Check distance to first point
                        const dx = x - data.path[i].x;
                        const dy = y - data.path[i].y;
                        if (Math.sqrt(dx * dx + dy * dy) <= hitRadius) {
                            return true;
                        }
                    } else {
                        // Check distance to line segment between previous and current point
                        const distance = this.distanceToLine(x, y,
                            data.path[i-1].x, data.path[i-1].y,
                            data.path[i].x, data.path[i].y);
                        if (distance <= hitRadius) {
                            return true;
                        }
                    }
                }
                return false;
        }
        return false;
    }
    
    distanceToLine(px, py, x1, y1, x2, y2) {
        const A = px - x1;
        const B = py - y1;
        const C = x2 - x1;
        const D = y2 - y1;
        
        const dot = A * C + B * D;
        const lenSq = C * C + D * D;
        let param = -1;
        if (lenSq !== 0) {
            param = dot / lenSq;
        }
        
        let xx, yy;
        if (param < 0) {
            xx = x1;
            yy = y1;
        } else if (param > 1) {
            xx = x2;
            yy = y2;
        } else {
            xx = x1 + param * C;
            yy = y1 + param * D;
        }
        
        const dx = px - xx;
        const dy = py - yy;
        return Math.sqrt(dx * dx + dy * dy);
    }
    
    dragElement(x, y) {
        if (!this.selectedElement) return;

        const newX = x - this.dragOffset.x;
        const newY = y - this.dragOffset.y;

        // Calculate delta before updating position
        const deltaX = newX - this.selectedElement.position_x;
        const deltaY = newY - this.selectedElement.position_y;

        this.selectedElement.position_x = newX;
        this.selectedElement.position_y = newY;

        // Update data based on element type
        const data = this.selectedElement.data;

        switch (this.selectedElement.element_type) {
            case 'rectangle':
                data.x = newX;
                data.y = newY;
                break;
            case 'circle':
                data.x = newX;
                data.y = newY;
                break;
            case 'text':
                data.x = newX;
                data.y = newY;
                break;
            case 'line':
            case 'arrow':
                data.x1 += deltaX;
                data.y1 += deltaY;
                data.x2 += deltaX;
                data.y2 += deltaY;
                break;
            case 'triangle':
                data.x1 += deltaX;
                data.y1 += deltaY;
                data.x2 += deltaX;
                data.y2 += deltaY;
                data.x3 += deltaX;
                data.y3 += deltaY;
                break;
            case 'freehand':
            case 'brush':
                // Move all points in the path
                if (data.path) {
                    for (let point of data.path) {
                        point.x += deltaX;
                        point.y += deltaY;
                    }
                }
                break;
        }

        this.scheduleRedraw();
        this.scheduleServerUpdate(this.selectedElement);
    }
    
    rotateElement(x, y) {
        if (!this.selectedElement) return;

        const currentAngle = Math.atan2(y - this.rotationCenter.y, x - this.rotationCenter.x);
        const angleDiff = currentAngle - this.initialAngle;

        // Update rotation (convert to degrees for easier handling)
        const oldRotation = this.selectedElement.rotation || 0;
        this.selectedElement.rotation = (oldRotation + angleDiff * (180 / Math.PI)) % 360;

        this.initialAngle = currentAngle;
        this.scheduleRedraw();
        this.scheduleServerUpdate(this.selectedElement);
    }
    
    getResizeHandle(x, y) {
        if (!this.selectedElement) return null;
        
        const bounds = this.getElementBounds(this.selectedElement);
        const handleSize = 10; // Match the drawing size
        
        // Check rotation handle first (higher priority)
        const centerX = bounds.x + bounds.width / 2;
        const centerY = bounds.y + bounds.height / 2;
        const rotateHandleX = centerX;
        const rotateHandleY = bounds.y - 20; // 20px above the element
        
        if (Math.abs(x - rotateHandleX) <= handleSize && Math.abs(y - rotateHandleY) <= handleSize) {
            return 'rotate';
        }
        
        // Check resize corners
        const handles = [
            { name: 'nw', x: bounds.x, y: bounds.y },
            { name: 'ne', x: bounds.x + bounds.width, y: bounds.y },
            { name: 'sw', x: bounds.x, y: bounds.y + bounds.height },
            { name: 'se', x: bounds.x + bounds.width, y: bounds.y + bounds.height }
        ];
        
        for (let handle of handles) {
            if (Math.abs(x - handle.x) <= handleSize && Math.abs(y - handle.y) <= handleSize) {
                return handle.name;
            }
        }
        
        return null;
    }
    
    getElementBounds(element) {
        const data = element.data;
        
        switch (element.element_type) {
            case 'rectangle':
                return {
                    x: data.x,
                    y: data.y,
                    width: data.width,
                    height: data.height
                };
            case 'circle':
                return {
                    x: data.x - data.radius,
                    y: data.y - data.radius,
                    width: data.radius * 2,
                    height: data.radius * 2
                };
            case 'text':
                const fontSize = data.fontSize || 16;
                const fontFamily = data.fontFamily || 'Arial, sans-serif';
                const fontWeight = data.fontWeight || 'normal';
                const fontStyle = data.fontStyle || 'normal';
                this.ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;
                const textWidth = this.ctx.measureText(data.text).width;

                return {
                    x: data.x,
                    y: data.y - fontSize,
                    width: textWidth,
                    height: fontSize
                };
            case 'line':
            case 'arrow':
                const minX = Math.min(data.x1, data.x2);
                const maxX = Math.max(data.x1, data.x2);
                const minY = Math.min(data.y1, data.y2);
                const maxY = Math.max(data.y1, data.y2);
                return {
                    x: minX,
                    y: minY,
                    width: Math.max(maxX - minX, 10), // Minimum width for selection
                    height: Math.max(maxY - minY, 10) // Minimum height for selection
                };
            case 'triangle':
                const triMinX = Math.min(data.x1, data.x2, data.x3);
                const triMaxX = Math.max(data.x1, data.x2, data.x3);
                const triMinY = Math.min(data.y1, data.y2, data.y3);
                const triMaxY = Math.max(data.y1, data.y2, data.y3);
                return {
                    x: triMinX,
                    y: triMinY,
                    width: triMaxX - triMinX,
                    height: triMaxY - triMinY
                };
            default:
                return { x: 0, y: 0, width: 0, height: 0 };
        }
    }
    
    resizeElement(x, y) {
        if (!this.selectedElement || !this.resizeHandle) return;
        
        const data = this.selectedElement.data;
        
        switch (this.selectedElement.element_type) {
            case 'rectangle':
                if (this.resizeHandle.includes('e')) {
                    data.width = Math.max(10, x - data.x); // Minimum width of 10px
                }
                if (this.resizeHandle.includes('s')) {
                    data.height = Math.max(10, y - data.y); // Minimum height of 10px
                }
                if (this.resizeHandle.includes('w')) {
                    const oldWidth = data.width;
                    data.width = Math.max(10, data.x + oldWidth - x);
                    data.x = x;
                }
                if (this.resizeHandle.includes('n')) {
                    const oldHeight = data.height;
                    data.height = Math.max(10, data.y + oldHeight - y);
                    data.y = y;
                }
                break;
            case 'circle':
                const dx = x - data.x;
                const dy = y - data.y;
                data.radius = Math.max(5, Math.sqrt(dx * dx + dy * dy)); // Minimum radius of 5px
                break;
                
            case 'line':
            case 'arrow':
                // Resize by changing the end point
                if (this.resizeHandle.includes('e') || this.resizeHandle.includes('s')) {
                    data.x2 = x;
                    data.y2 = y;
                } else if (this.resizeHandle.includes('w') || this.resizeHandle.includes('n')) {
                    data.x1 = x;
                    data.y1 = y;
                }
                // Update position to match the top-left of bounding box
                const minX = Math.min(data.x1, data.x2);
                const minY = Math.min(data.y1, data.y2);
                this.selectedElement.position_x = minX;
                this.selectedElement.position_y = minY;
                break;
                
            case 'triangle':
                // Resize triangle by adjusting points based on handle
                const bounds = this.getElementBounds(this.selectedElement);
                const centerX = bounds.x + bounds.width / 2;
                const centerY = bounds.y + bounds.height / 2;
                
                if (this.resizeHandle.includes('e')) {
                    const scale = (x - bounds.x) / bounds.width;
                    data.x2 = bounds.x + bounds.width * scale;
                    data.x3 = bounds.x + (data.x3 - bounds.x) * scale;
                }
                if (this.resizeHandle.includes('s')) {
                    const scale = (y - bounds.y) / bounds.height;
                    data.y2 = bounds.y + bounds.height * scale;
                    data.y3 = bounds.y + (data.y3 - bounds.y) * scale;
                }
                break;
                
            case 'text':
                // For text, resize by changing font size
                const currentSize = data.fontSize || 16;
                const textBounds = this.getElementBounds(this.selectedElement);
                
                if (this.resizeHandle.includes('e') || this.resizeHandle.includes('s')) {
                    // Calculate scale factor based on distance from text origin
                    const distance = Math.sqrt((x - data.x) * (x - data.x) + (y - data.y) * (y - data.y));
                    const baseDistance = Math.sqrt(textBounds.width * textBounds.width + textBounds.height * textBounds.height);
                    const scale = distance / baseDistance;
                    data.fontSize = Math.max(8, Math.min(72, currentSize * scale)); // Limit between 8px and 72px
                }
                
                // Update position for text
                this.selectedElement.position_x = data.x;
                this.selectedElement.position_y = data.y;
                break;
        }
        
        // Update position_x and position_y to match data (for rectangles and circles)
        if (this.selectedElement.element_type === 'rectangle' || this.selectedElement.element_type === 'circle') {
            this.selectedElement.position_x = data.x;
            this.selectedElement.position_y = data.y;
        }
        
        this.scheduleRedraw();
        this.scheduleServerUpdate(this.selectedElement);
    }
    
    drawSelectionHandles() {
        if (!this.selectedElement) return;
        
        const bounds = this.getElementBounds(this.selectedElement);
        const handleSize = 10; // Increased size for better visibility
        
        // Draw selection border first
        this.ctx.strokeStyle = '#007bff';
        this.ctx.lineWidth = 2;
        this.ctx.setLineDash([5, 5]); // Dashed border
        this.ctx.strokeRect(bounds.x - 2, bounds.y - 2, bounds.width + 4, bounds.height + 4);
        this.ctx.setLineDash([]); // Reset to solid line
        
        // Draw corner handles with better visibility
        this.ctx.fillStyle = '#007bff';
        this.ctx.strokeStyle = '#ffffff';
        this.ctx.lineWidth = 2;
        
        // Draw corner handles
        const handles = [
            { x: bounds.x, y: bounds.y },
            { x: bounds.x + bounds.width, y: bounds.y },
            { x: bounds.x, y: bounds.y + bounds.height },
            { x: bounds.x + bounds.width, y: bounds.y + bounds.height }
        ];
        
        for (let handle of handles) {
            // Draw shadow for better visibility
            this.ctx.fillStyle = 'rgba(0,0,0,0.3)';
            this.ctx.fillRect(handle.x - handleSize/2 + 1, handle.y - handleSize/2 + 1, handleSize, handleSize);
            
            // Draw main handle
            this.ctx.fillStyle = '#007bff';
            this.ctx.fillRect(handle.x - handleSize/2, handle.y - handleSize/2, handleSize, handleSize);
            this.ctx.strokeRect(handle.x - handleSize/2, handle.y - handleSize/2, handleSize, handleSize);
        }
        
        // Draw rotation handle
        const centerX = bounds.x + bounds.width / 2;
        const rotateHandleY = bounds.y - 20;
        
        // Draw connection line to rotation handle
        this.ctx.strokeStyle = '#007bff';
        this.ctx.lineWidth = 1;
        this.ctx.setLineDash([3, 3]);
        this.ctx.beginPath();
        this.ctx.moveTo(centerX, bounds.y);
        this.ctx.lineTo(centerX, rotateHandleY);
        this.ctx.stroke();
        this.ctx.setLineDash([]);
        
        // Draw rotation handle (circular)
        this.ctx.fillStyle = 'rgba(0,0,0,0.3)';
        this.ctx.beginPath();
        this.ctx.arc(centerX + 1, rotateHandleY + 1, handleSize/2, 0, 2 * Math.PI);
        this.ctx.fill();
        
        this.ctx.fillStyle = '#28a745'; // Green color for rotation
        this.ctx.strokeStyle = '#ffffff';
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.arc(centerX, rotateHandleY, handleSize/2, 0, 2 * Math.PI);
        this.ctx.fill();
        this.ctx.stroke();
        
        // Draw rotation icon (small arrow)
        this.ctx.strokeStyle = '#ffffff';
        this.ctx.lineWidth = 1;
        this.ctx.beginPath();
        this.ctx.arc(centerX, rotateHandleY, 3, 0, 1.5 * Math.PI);
        this.ctx.stroke();
        // Arrow head
        this.ctx.beginPath();
        this.ctx.moveTo(centerX - 3, rotateHandleY - 3);
        this.ctx.lineTo(centerX - 1, rotateHandleY - 3);
        this.ctx.lineTo(centerX - 1, rotateHandleY - 1);
        this.ctx.stroke();
    }
    
    updateElementOnServer(element) {
        const updateData = {
            element_id: element.id,
            data: element.data,
            position_x: element.position_x,
            position_y: element.position_y,
            rotation: element.rotation || 0
        };
        
        
        fetch(`/organization/boards/{{ board.pk }}/update-element/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': '{{ csrf_token }}'
            },
            body: JSON.stringify(updateData)
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                this.lastUpdate = Date.now();
            }
        })
        .catch(error => {
            console.error('Error updating element:', error);
        });
    }
    
    setupPolling() {
        this.lastUpdate = Date.now();
        this.pollingInterval = setInterval(() => {
            this.checkForUpdates();
        }, 1500); // Check every 1.5 seconds - reduced frequency for better performance
    }
    
    checkForUpdates() {
        // Don't check for updates while actively dragging
        if (this.pollingPaused) {
            return;
        }

        fetch(`/organization/boards/{{ board.pk }}/elements/?since=${this.lastUpdate}`)
            .then(response => response.json())
            .then(data => {
                if (data.updated && data.elements) {
                    // Only update if there are actual changes and we're not actively dragging
                    if (!this.pollingPaused && this.hasElementsChanged(data.elements)) {
                        this.elements = data.elements;
                        // Ensure all elements have correct position values
                        this.elements.forEach(element => this.ensureElementPosition(element));
                        this.scheduleRedraw();
                    }
                    this.lastUpdate = Date.now();
                }
            })
            .catch(error => {
                console.error('Error checking for updates:', error);
            });
    }
    
    hasElementsChanged(newElements) {
        if (newElements.length !== this.elements.length) {
            return true;
        }
        
        for (let i = 0; i < newElements.length; i++) {
            const newEl = newElements[i];
            const oldEl = this.elements[i];
            
            if (!oldEl || newEl.id !== oldEl.id || 
                JSON.stringify(newEl.data) !== JSON.stringify(oldEl.data) ||
                newEl.position_x !== oldEl.position_x ||
                newEl.position_y !== oldEl.position_y ||
                newEl.rotation !== oldEl.rotation) {
                return true;
            }
        }
        
        return false;
    }
    
    ensureElementPosition(element) {
        // Ensure position_x and position_y are correctly set for all element types
        const data = element.data;
        
        switch (element.element_type) {
            case 'rectangle':
            case 'circle':
            case 'text':
                if (element.position_x === undefined) element.position_x = data.x || 0;
                if (element.position_y === undefined) element.position_y = data.y || 0;
                break;
                
            case 'line':
            case 'arrow':
                const minX = Math.min(data.x1, data.x2);
                const minY = Math.min(data.y1, data.y2);
                if (element.position_x === undefined) element.position_x = minX;
                if (element.position_y === undefined) element.position_y = minY;
                break;
                
            case 'triangle':
                const triMinX = Math.min(data.x1, data.x2, data.x3);
                const triMinY = Math.min(data.y1, data.y2, data.y3);
                if (element.position_x === undefined) element.position_x = triMinX;
                if (element.position_y === undefined) element.position_y = triMinY;
                break;
                
            case 'freehand':
            case 'brush':
                if (data.path && data.path.length > 0) {
                    const pathMinX = Math.min(...data.path.map(p => p.x));
                    const pathMinY = Math.min(...data.path.map(p => p.y));
                    if (element.position_x === undefined) element.position_x = pathMinX;
                    if (element.position_y === undefined) element.position_y = pathMinY;
                }
                break;
        }
    }

    // Performance optimization methods
    scheduleRedraw() {
        if (this.redrawScheduled) return;

        this.redrawScheduled = true;
        requestAnimationFrame(() => {
            this.redrawCanvas();
            this.redrawScheduled = false;
        });
    }

    scheduleServerUpdate(element) {
        // Clear any existing timeout
        if (this.updateTimeout) {
            clearTimeout(this.updateTimeout);
        }

        // Store the pending update
        this.pendingUpdate = {
            element_id: element.id,
            data: element.data,
            position_x: element.position_x,
            position_y: element.position_y,
            rotation: element.rotation || 0
        };

        // Schedule the debounced update
        this.updateTimeout = setTimeout(() => {
            this.finalizePendingUpdate();
        }, this.debouncedUpdateDelay);
    }

    finalizePendingUpdate() {
        if (!this.pendingUpdate) return;

        const updateData = this.pendingUpdate;
        this.pendingUpdate = null;

        if (this.updateTimeout) {
            clearTimeout(this.updateTimeout);
            this.updateTimeout = null;
        }

        // Store original state for potential rollback
        const elementToUpdate = this.elements.find(el => el.id === updateData.element_id);
        const originalState = elementToUpdate ? {
            data: JSON.parse(JSON.stringify(elementToUpdate.data)),
            position_x: elementToUpdate.position_x,
            position_y: elementToUpdate.position_y,
            rotation: elementToUpdate.rotation
        } : null;

        // Send the update to server
        fetch(`/organization/boards/{{ board.pk }}/update-element/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': '{{ csrf_token }}'
            },
            body: JSON.stringify(updateData)
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                this.lastUpdate = Date.now();
                console.log('Element successfully updated on server');
            } else {
                console.error('Failed to update element on server:', data);
                this.rollbackElement(updateData.element_id, originalState);
            }
        })
        .catch(error => {
            console.error('Error updating element:', error);
            this.rollbackElement(updateData.element_id, originalState);
        });
    }

    rollbackElement(elementId, originalState) {
        if (!originalState) {
            console.warn('Cannot rollback element - no original state available');
            return;
        }

        // Find and restore the element
        const element = this.elements.find(el => el.id === elementId);
        if (element) {
            element.data = originalState.data;
            element.position_x = originalState.position_x;
            element.position_y = originalState.position_y;
            element.rotation = originalState.rotation;

            this.scheduleRedraw();
            console.log('Element rolled back to previous state');

            // Show a brief user notification
            this.showNotification('Update failed - changes reverted', 'error');
        }
    }

    showNotification(message, type = 'info') {
        // Create a simple notification
        const notification = document.createElement('div');
        notification.className = `alert alert-${type === 'error' ? 'danger' : 'info'} alert-dismissible`;
        notification.style.cssText = 'position: fixed; top: 20px; right: 20px; z-index: 1000; min-width: 300px;';
        notification.innerHTML = `
            ${message}
            <button type="button" class="btn-close" onclick="this.parentElement.remove()"></button>
        `;

        document.body.appendChild(notification);

        // Auto-remove after 3 seconds
        setTimeout(() => {
            if (notification.parentElement) {
                notification.remove();
            }
        }, 3000);
    }

    pausePolling() {
        this.pollingPaused = true;
    }

    resumePolling() {
        this.pollingPaused = false;
        // Immediately check for updates when resuming
        setTimeout(() => this.checkForUpdates(), 100);
    }

    cleanup() {
        if (this.pollingInterval) {
            clearInterval(this.pollingInterval);
        }
        if (this.updateTimeout) {
            clearTimeout(this.updateTimeout);
        }
    }
    
    zoomIn() {
        this.zoomLevel = Math.min(this.zoomLevel * 1.2, 5); // Max zoom 5x
        this.applyCanvasTransform();
    }
    
    zoomOut() {
        this.zoomLevel = Math.max(this.zoomLevel / 1.2, 0.1); // Min zoom 0.1x
        this.applyCanvasTransform();
    }
    
    panCanvas(deltaX, deltaY) {
        this.panX += deltaX;
        this.panY += deltaY;
        this.applyCanvasTransform();
    }
    
    resetCanvasView() {
        this.zoomLevel = 1;
        this.panX = 0;
        this.panY = 0;
        this.applyCanvasTransform();
    }
    
    applyCanvasTransform() {
        const container = document.getElementById('canvas-container');
        this.canvas.style.transform = `translate(${this.panX}px, ${this.panY}px) scale(${this.zoomLevel})`;
        this.canvas.style.transformOrigin = 'top left';
    }
    
    toggleHandTool() {
        if (this.handToolActive) {
            this.deactivateHandTool();
        } else {
            this.activateHandTool();
        }
    }
    
    activateHandTool() {
        this.handToolActive = true;
        const handButton = document.getElementById('hand-tool');
        handButton.classList.remove('btn-outline-secondary');
        handButton.classList.add('btn-secondary');
        this.canvas.style.cursor = 'grab';

        // Hide popup when hand tool is activated
        const popup = document.getElementById('tool-controls-popup');
        popup.style.display = 'none';

        // Remove active class from all tool buttons
        document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
    }
    
    deactivateHandTool() {
        this.handToolActive = false;
        this.isPanning = false; // Stop any active panning
        const handButton = document.getElementById('hand-tool');
        handButton.classList.remove('btn-secondary');
        handButton.classList.add('btn-outline-secondary');
        this.updateCursor(); // Reset to normal cursor based on current tool
    }
    
    updateCursor() {
        switch (this.currentTool) {
            case 'select':
                // Dark pointer cursor for better visibility
                this.canvas.style.cursor = 'url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTMgM0w5IDE5TDEyIDE1TDE5IDEySjMgM1oiIGZpbGw9IiMwMDAiIHN0cm9rZT0iI2ZmZiIgc3Ryb2tlLXdpZHRoPSIxIi8+Cjwvc3ZnPg==) 3 3, pointer';
                break;
            case 'pen':
            case 'brush':
                // Dark crosshair for better visibility
                this.canvas.style.cursor = 'url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGxpbmUgeDE9IjEyIiB5MT0iMyIgeDI9IjEyIiB5Mj0iMjEiIHN0cm9rZT0iIzAwMCIgc3Ryb2tlLXdpZHRoPSIyIi8+CjxsaW5lIHgxPSIzIiB5MT0iMTIiIHgyPSIyMSIgeTI9IjEyIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMiIvPgo8Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSIyIiBmaWxsPSIjZmZmIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMSIvPgo8L3N2Zz4=) 12 12, crosshair';
                break;
            case 'text':
                // Dark text cursor
                this.canvas.style.cursor = 'url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGxpbmUgeDE9IjEyIiB5MT0iMyIgeDI9IjEyIiB5Mj0iMjEiIHN0cm9rZT0iIzAwMCIgc3Ryb2tlLXdpZHRoPSIyIi8+CjxsaW5lIHgxPSI5IiB5MT0iMyIgeDI9IjE1IiB5Mj0iMyIgc3Ryb2tlPSIjMDAwIiBzdHJva2Utd2lkdGg9IjIiLz4KPGxpbmUgeDE9IjkiIHkxPSIyMSIgeDI9IjE1IiB5Mj0iMjEiIHN0cm9rZT0iIzAwMCIgc3Ryb2tlLXdpZHRoPSIyIi8+Cjwvc3ZnPg==) 12 12, text';
                break;
            case 'arrow':
                // Arrow cursor
                this.canvas.style.cursor = 'url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGxpbmUgeDE9IjMiIHkxPSIxMiIgeDI9IjIxIiB5Mj0iMTIiIHN0cm9rZT0iIzAwMCIgc3Ryb2tlLXdpZHRoPSIyIi8+Cjxwb2x5bGluZSBwb2ludHM9IjE1LDYgMjEsMTIgMTUsMTgiIHN0cm9rZT0iIzAwMCIgc3Ryb2tlLXdpZHRoPSIyIiBmaWxsPSJub25lIi8+Cjwvc3ZnPg==) 12 12, crosshair';
                break;
            default:
                // Default dark crosshair
                this.canvas.style.cursor = 'url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGxpbmUgeDE9IjEyIiB5MT0iMyIgeDI9IjEyIiB5Mj0iMjEiIHN0cm9rZT0iIzAwMCIgc3Ryb2tlLXdpZHRoPSIyIi8+CjxsaW5lIHgxPSIzIiB5MT0iMTIiIHgyPSIyMSIgeTI9IjEyIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMiIvPgo8Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSIyIiBmaWxsPSIjZmZmIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMSIvPgo8L3N2Zz4=) 12 12, crosshair';
        }
    }

    toggleToolControls() {
        const popup = document.getElementById('tool-controls-popup');
        const toolsWithControls = ['pen', 'brush', 'line', 'arrow', 'rectangle', 'circle', 'triangle', 'text'];

        if (toolsWithControls.includes(this.currentTool)) {
            this.showToolControlsPopup();
        } else {
            popup.style.display = 'none';
        }
    }

    showToolControlsPopup() {
        const popup = document.getElementById('tool-controls-popup');
        const strokeControl = document.getElementById('stroke-width-control');
        const fontSizeControl = document.getElementById('font-size-control');

        console.log('showToolControlsPopup called');
        console.log('currentTool:', this.currentTool);
        console.log('selectedElement:', this.selectedElement?.element_type);

        // Determine what controls to show based on current tool AND selected element
        let showStrokeWidth = false;
        let showFontSize = false;

        // Check current tool for controls
        if (this.currentTool !== 'select') {
            switch (this.currentTool) {
                case 'text':
                    showFontSize = true;
                    break;
                case 'pen':
                case 'brush':
                case 'line':
                case 'arrow':
                case 'rectangle':
                case 'circle':
                case 'triangle':
                    showStrokeWidth = true;
                    break;
            }
        }

        // Also check selected element for controls (show both if relevant)
        if (this.selectedElement) {
            const elementType = this.selectedElement.element_type;
            switch (elementType) {
                case 'text':
                    showFontSize = true;
                    break;
                case 'pen':
                case 'brush':
                case 'line':
                case 'arrow':
                case 'rectangle':
                case 'circle':
                case 'triangle':
                case 'freehand':
                    showStrokeWidth = true;
                    break;
            }
        }

        // Apply visibility with !important to override Bootstrap
        if (showStrokeWidth) {
            strokeControl.style.setProperty('display', 'flex', 'important');
        } else {
            strokeControl.style.setProperty('display', 'none', 'important');
        }

        if (showFontSize) {
            fontSizeControl.style.setProperty('display', 'flex', 'important');
        } else {
            fontSizeControl.style.setProperty('display', 'none', 'important');
        }

        console.log('Popup controls - showStrokeWidth:', showStrokeWidth, 'showFontSize:', showFontSize);

        // Update popup values based on selected element or current tool settings
        if (this.selectedElement) {
            // Set values from selected element
            let elementColor = this.selectedElement.color || '#000000';
            // For text elements, use textColor from data if available
            if (this.selectedElement.element_type === 'text' && this.selectedElement.data.textColor) {
                elementColor = this.selectedElement.data.textColor;
            }
            document.getElementById('color-picker').value = elementColor;

            if (showStrokeWidth) {
                document.getElementById('stroke-width').value = this.selectedElement.stroke_width || 2;
                document.getElementById('stroke-width-value').textContent = this.selectedElement.stroke_width || 2;
            }

            if (showFontSize) {
                const fontSize = this.selectedElement.data.fontSize || 16;
                document.getElementById('font-size').value = fontSize;
                document.getElementById('font-size-value').textContent = fontSize;
            }

            const opacityPercent = Math.round((this.selectedElement.opacity || 1.0) * 100);
            document.getElementById('opacity').value = opacityPercent;
            document.getElementById('opacity-value').textContent = opacityPercent;
        } else {
            // Set values from current tool settings
            document.getElementById('color-picker').value = this.currentColor;

            if (showStrokeWidth) {
                document.getElementById('stroke-width').value = this.currentStrokeWidth;
                document.getElementById('stroke-width-value').textContent = this.currentStrokeWidth;
            }

            if (showFontSize) {
                // For text tool, set default font size
                document.getElementById('font-size').value = 16;
                document.getElementById('font-size-value').textContent = 16;
            }

            const opacityPercent = Math.round(this.currentOpacity * 100);
            document.getElementById('opacity').value = opacityPercent;
            document.getElementById('opacity-value').textContent = opacityPercent;
        }

        // Simple display - popup is already positioned at top center of canvas
        popup.style.display = 'block';
    }

    closePopupOnClickOutside(event) {
        const popup = document.getElementById('tool-controls-popup');
        const activeButton = document.querySelector('.tool-btn.active');
        const canvas = document.getElementById('drawing-canvas');

        // Don't close if clicking on popup, active button, popup controls, or if we have a selected element
        if (popup.contains(event.target) ||
            (activeButton && activeButton.contains(event.target)) ||
            event.target.closest('#tool-controls-popup') ||
            this.selectedElement) {
            // Re-add the listener for next click
            setTimeout(() => {
                document.addEventListener('click', this.closePopupOnClickOutside.bind(this), { once: true });
            }, 100);
            return;
        }

        // Only close if clicking outside canvas area or on empty canvas space
        if (!canvas.contains(event.target)) {
            popup.style.display = 'none';
        } else {
            // Re-add the listener for next click
            setTimeout(() => {
                document.addEventListener('click', this.closePopupOnClickOutside.bind(this), { once: true });
            }, 100);
        }
    }
}

// Initialisiere das Board wenn die Seite geladen ist
let ideaBoard;

function initializeBoard() {
    console.log('Initializing IdeaBoard...');
    ideaBoard = new IdeaBoard();
    console.log('IdeaBoard initialized:', ideaBoard);

    // Add event listeners for modal close events to show popup again
    const textModal = document.getElementById('textInputModal');
    const shapeModal = document.getElementById('shapePropertiesModal');

    if (textModal) {
        textModal.addEventListener('hidden.bs.modal', function () {
            // Clear editing element reference
            ideaBoard.editingElement = null;
            // Show popup again if we have a selected element
            if (ideaBoard.selectedElement) {
                ideaBoard.showToolControlsPopup();
            }
        });
    }

    if (shapeModal) {
        shapeModal.addEventListener('hidden.bs.modal', function () {
            // Clear editing element reference
            ideaBoard.editingElement = null;
            // Show popup again if we have a selected element
            if (ideaBoard.selectedElement) {
                ideaBoard.showToolControlsPopup();
            }
        });
    }
}

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeBoard);
} else {
    // DOM is already loaded
    initializeBoard();
}

// Cleanup when page is unloaded
window.addEventListener('beforeunload', function() {
    if (ideaBoard) {
        ideaBoard.cleanup();
    }
});

// Benutzersuche f√ºr Einladungen
let searchTimeout;
const newCollaborators = new Set();

document.getElementById('userSearch').addEventListener('input', function() {
    const query = this.value.trim();
    
    clearTimeout(searchTimeout);
    
    if (query.length < 2) {
        document.getElementById('searchResults').innerHTML = '';
        return;
    }
    
    searchTimeout = setTimeout(() => {
        fetch(`/organization/api/user-search/?q=${encodeURIComponent(query)}`)
            .then(response => response.json())
            .then(data => {
                const resultsDiv = document.getElementById('searchResults');
                resultsDiv.innerHTML = '';
                
                if (data.results.length === 0) {
                    resultsDiv.innerHTML = '<div class="text-muted">Keine Benutzer gefunden</div>';
                    return;
                }
                
                data.results.forEach(user => {
                    const userDiv = document.createElement('div');
                    userDiv.className = 'border rounded p-2 mb-2 cursor-pointer';
                    userDiv.style.cursor = 'pointer';
                    userDiv.innerHTML = `
                        <strong>${user.username}</strong> 
                        <small class="text-muted">${user.full_name}</small>
                    `;
                    userDiv.onclick = () => addCollaborator(user);
                    resultsDiv.appendChild(userDiv);
                });
            })
            .catch(error => {
                console.error('Fehler bei der Benutzersuche:', error);
            });
    }, 300);
});

function addCollaborator(user) {
    // Pr√ºfen ob bereits hinzugef√ºgt
    if (newCollaborators.has(user.id)) {
        return;
    }
    
    // Pr√ºfen ob bereits Mitarbeiter
    const existingCollaborator = document.querySelector(`[data-user-id="${user.id}"]`);
    if (existingCollaborator) {
        return;
    }
    
    newCollaborators.add(user.id);
    
    const badge = document.createElement('span');
    badge.className = 'badge bg-success me-1';
    badge.dataset.userId = user.id;
    badge.innerHTML = `
        ${user.username}
        <button type="button" class="btn-close btn-close-white ms-1" style="font-size: 0.7em;" onclick="removeNewCollaborator(${user.id})"></button>
    `;
    
    document.getElementById('newCollaborators').appendChild(badge);
    document.getElementById('userSearch').value = '';
    document.getElementById('searchResults').innerHTML = '';
}

function removeNewCollaborator(userId) {
    newCollaborators.delete(userId);
    const badge = document.querySelector(`#newCollaborators [data-user-id="${userId}"]`);
    if (badge) {
        badge.remove();
    }
}

function removeCollaborator(userId) {
    if (confirm('Mitarbeiter wirklich entfernen?')) {
        fetch(`/organization/boards/{{ board.pk }}/remove-collaborator/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': '{{ csrf_token }}'
            },
            body: JSON.stringify({user_id: userId})
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                const badge = document.querySelector(`#currentCollaborators [data-user-id="${userId}"]`);
                if (badge) {
                    badge.remove();
                }
            } else {
                alert('Fehler beim Entfernen des Mitarbeiters');
            }
        })
        .catch(error => {
            console.error('Fehler:', error);
            alert('Fehler beim Entfernen des Mitarbeiters');
        });
    }
}

function saveInvitations() {
    if (newCollaborators.size === 0) {
        alert('Keine neuen Mitarbeiter ausgew√§hlt');
        return;
    }
    
    const collaboratorIds = Array.from(newCollaborators);
    
    fetch(`/organization/boards/{{ board.pk }}/invite-collaborators/`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': '{{ csrf_token }}'
        },
        body: JSON.stringify({collaborator_ids: collaboratorIds})
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            alert('Einladungen erfolgreich gesendet!');
            location.reload(); // Seite neu laden um neue Mitarbeiter anzuzeigen
        } else {
            alert('Fehler beim Senden der Einladungen');
        }
    })
    .catch(error => {
        console.error('Fehler:', error);
        alert('Fehler beim Senden der Einladungen');
    });
}
</script>

<!-- Agora SDK -->
<script src="https://download.agora.io/sdk/release/AgoraRTC_N-4.18.0.js"></script>

<!-- Quill Rich Text Editor -->
<link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
<script src="https://cdn.quilljs.com/1.3.6/quill.min.js"></script>

<!-- JSZip for creating ZIP downloads -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

<script>
// ========================================
// Board Audio Manager
// ========================================
class BoardAudioManager {
    constructor() {
        this.isAudioActive = false;
        this.isMuted = false;
        this.agoraClient = null;
        this.localAudioTrack = null;
        this.audioConfig = null;
        this.participantCount = 0;
        this.participants = {};  // Store participant info
        this.activeSpeakers = new Set();  // Track who is speaking
        this.volumeIndicatorInterval = null;
        this.knownParticipants = new Set(); // Track known participants to detect new joins
        this.periodicUpdateInterval = null; // For periodic participant list updates

        this.initEventListeners();
        this.checkAudioStatus();
    }

    initEventListeners() {
        const audioBtn = document.getElementById('audio-toggle-btn');
        if (audioBtn) {
            audioBtn.addEventListener('click', () => {
                if (this.isAudioActive) {
                    this.leaveAudio();
                } else {
                    this.joinAudio();
                }
            });
        }

        const muteBtn = document.getElementById('mute-toggle-btn');
        if (muteBtn) {
            muteBtn.addEventListener('click', () => {
                this.toggleMute();
            });
        }

        // Status alle 5 Sekunden pr√ºfen
        setInterval(() => {
            if (!this.isAudioActive) {
                this.checkAudioStatus();
            }
        }, 5000);
    }

    async checkAudioStatus() {
        try {
            const response = await fetch(`/organization/boards/{{ board.pk }}/audio/status/`);
            const data = await response.json();

            this.updateUI(data);
        } catch (error) {
            console.error('Error checking audio status:', error);
        }
    }

    updateUI(audioStatus) {
        const audioBtn = document.getElementById('audio-toggle-btn');
        const audioText = document.getElementById('audio-text');
        const audioParticipants = document.getElementById('audio-participants');
        const participantsList = document.getElementById('audio-participants-list');

        if (!audioBtn) return;

        // Update participants information
        if (audioStatus.participants) {
            this.updateParticipantsList(audioStatus.participants);
        }

        if (audioStatus.has_active_session && audioStatus.participant_count > 0) {
            audioParticipants.style.display = 'inline';
            audioParticipants.textContent = audioStatus.participant_count;

            // Show participants list when audio is active
            if (participantsList) {
                participantsList.style.display = this.isAudioActive ? 'inline-block' : 'none';
            }
        } else {
            audioParticipants.style.display = 'none';
            if (participantsList) {
                participantsList.style.display = 'none';
            }
        }

        const muteBtn = document.getElementById('mute-toggle-btn');

        if (audioStatus.user_is_participant) {
            audioBtn.className = 'btn btn-sm btn-success me-1';
            audioBtn.style.width = '120px';
            audioBtn.style.height = '38px';
            audioBtn.style.display = 'flex';
            audioBtn.style.alignItems = 'center';
            audioBtn.style.justifyContent = 'center';
            audioBtn.innerHTML = `üé§ <span id="audio-text" class="d-none d-sm-inline">Verlassen</span><span id="audio-participants" class="badge bg-secondary ms-1" style="display: ${audioStatus.participant_count > 0 ? 'inline' : 'none'}; font-size: 0.65rem;">${audioStatus.participant_count || 0}</span>`;

            // Show mute button when user is in audio
            if (muteBtn) {
                muteBtn.style.display = 'flex';
                muteBtn.style.width = '120px';
                muteBtn.style.height = '38px';
                muteBtn.style.alignItems = 'center';
                muteBtn.style.justifyContent = 'center';
                muteBtn.className = this.isMuted ? 'btn btn-sm btn-warning me-1' : 'btn btn-sm btn-outline-warning me-1';
                muteBtn.innerHTML = `${this.isMuted ? 'üîá' : 'üé§'} <span id="mute-text" class="d-none d-sm-inline">${this.isMuted ? 'Aktivieren' : 'Stumm'}</span>`;
            }
        } else {
            audioBtn.className = 'btn btn-sm btn-outline-success me-1';
            audioBtn.style.width = '120px';
            audioBtn.style.height = '38px';
            audioBtn.style.display = 'flex';
            audioBtn.style.alignItems = 'center';
            audioBtn.style.justifyContent = 'center';
            audioBtn.innerHTML = `üé§ <span id="audio-text" class="d-none d-sm-inline">Audio</span><span id="audio-participants" class="badge bg-secondary ms-1" style="display: ${audioStatus.participant_count > 0 ? 'inline' : 'none'}; font-size: 0.65rem;">${audioStatus.participant_count || 0}</span>`;

            // Hide mute button when user is not in audio
            if (muteBtn) {
                muteBtn.style.display = 'none';
            }
        }
    }

    async joinAudio() {
        try {
            // Backend: Audio-Session beitreten
            const joinResponse = await fetch(`/organization/boards/{{ board.pk }}/audio/join/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': '{{ csrf_token }}'
                }
            });

            if (!joinResponse.ok) {
                const errorData = await joinResponse.json();
                console.error('Join audio response error:', errorData);
                throw new Error(errorData.error || 'Failed to join audio session');
            }

            // Agora Token holen
            const tokenResponse = await fetch(`/organization/boards/{{ board.pk }}/audio/token/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': '{{ csrf_token }}'
                }
            });

            if (!tokenResponse.ok) {
                const errorData = await tokenResponse.json();
                console.error('Token response error:', errorData);
                throw new Error(errorData.error || 'Failed to get audio token');
            }

            this.audioConfig = await tokenResponse.json();
            console.log('Audio config received:', this.audioConfig);

            // Agora Client initialisieren
            this.agoraClient = AgoraRTC.createClient({ mode: "rtc", codec: "vp8" });

            // Event Listener f√ºr Agora
            this.agoraClient.on("user-published", async (user, mediaType) => {
                console.log('User published:', user.uid, 'mediaType:', mediaType);
                await this.agoraClient.subscribe(user, mediaType);
                if (mediaType === 'audio') {
                    user.audioTrack.play();

                    // Always refresh participant list when someone joins
                    await this.checkAudioStatus();

                    // Check if this is a new participant
                    if (!this.knownParticipants.has(user.uid)) {
                        console.log('New participant detected:', user.uid);
                        this.knownParticipants.add(user.uid);

                        // Try multiple approaches to get the username
                        this.tryToGetUsernameAndNotify(user.uid);
                    }
                }
            });

            this.agoraClient.on("user-unpublished", async (user) => {
                console.log('User left audio:', user.uid);
                // Remove user from participants and known participants
                delete this.participants[user.uid];
                this.knownParticipants.delete(user.uid);

                // Refresh participant list from backend
                await this.checkAudioStatus();
            });

            // Enable volume indicator for speaking detection
            this.agoraClient.enableAudioVolumeIndicator();

            // Listen for volume indicator events
            this.agoraClient.on("volume-indicator", (volumes) => {
                this.handleVolumeIndicator(volumes);
            });

            // Channel beitreten
            await this.agoraClient.join(
                this.audioConfig.app_id,
                this.audioConfig.channel_name,
                this.audioConfig.token,
                this.audioConfig.uid
            );

            // Mikrofon aktivieren
            this.localAudioTrack = await AgoraRTC.createMicrophoneAudioTrack();
            await this.agoraClient.publish([this.localAudioTrack]);

            this.isAudioActive = true;
            this.checkAudioStatus();

            // Start periodic status updates to keep participant list in sync
            this.startPeriodicUpdates();

            console.log('Successfully joined board audio');

        } catch (error) {
            console.error('Error joining audio:', error);
            alert('Fehler beim Beitreten zum Audio: ' + error.message);
        }
    }

    handleVolumeIndicator(volumes) {
        // volumes is an array of {uid, level} objects
        // level ranges from 0 to 100
        const SPEAKING_THRESHOLD = 10; // Adjust as needed

        // Clear previous speakers
        this.activeSpeakers.clear();

        volumes.forEach(volume => {
            if (volume.level > SPEAKING_THRESHOLD) {
                this.activeSpeakers.add(volume.uid);
            }
        });

        this.updateSpeakingIndicators();
    }

    updateParticipantsList(participantsData) {
        const dropdown = document.getElementById('participants-dropdown');
        const activeSpeakerName = document.getElementById('active-speaker-name');

        if (!dropdown) return;

        // Store participants data if provided
        if (participantsData) {
            console.log('Updating participants list with data:', participantsData);
            // Clear old participants first
            this.participants = {};
            participantsData.forEach(p => {
                console.log('Processing participant:', p);
                // Don't add current user to participants list (avoid duplicate)
                if (p.username !== '{{ request.user.username }}') {
                    this.participants[p.user_id] = p;
                    console.log('Added participant to list:', p.username);
                }

                // Add to known participants to avoid duplicate notifications
                if (p.agora_uid) {
                    this.knownParticipants.add(p.agora_uid);
                }
            });
            console.log('Final participants object:', this.participants);
        }

        // Clear dropdown
        dropdown.innerHTML = '';

        // Add current user (local)
        const currentUserItem = document.createElement('div');
        currentUserItem.className = 'participant-item';
        currentUserItem.dataset.uid = this.audioConfig ? this.audioConfig.uid : 'local';
        currentUserItem.innerHTML = `
            <span class="participant-name">{{ request.user.username }} (Du)</span>
            <span class="participant-status">${this.isMuted ? 'üîá' : 'üé§'}</span>
        `;
        dropdown.appendChild(currentUserItem);

        // Add other participants (already filtered to exclude current user)
        Object.values(this.participants).forEach(participant => {
            const item = document.createElement('div');
            item.className = 'participant-item';
            // Use agora_uid for consistent mapping
            item.dataset.uid = participant.agora_uid || participant.user_id;
            item.innerHTML = `
                <span class="participant-name">${participant.username}</span>
                <span class="participant-status">${participant.is_muted ? 'üîá' : 'üé§'}</span>
            `;
            dropdown.appendChild(item);
        });

        // Update active speaker display
        if (this.activeSpeakers.size > 0) {
            const speakerNames = Array.from(this.activeSpeakers)
                .map(uid => {
                    if (uid == (this.audioConfig ? this.audioConfig.uid : 'local')) {
                        return '{{ request.user.username }}';
                    }
                    // First try to find by agora_uid, then by user_id
                    let participant = Object.values(this.participants).find(p => p.agora_uid == uid);
                    if (!participant) {
                        participant = Object.values(this.participants).find(p => p.user_id == uid);
                    }
                    return participant ? participant.username : 'Unbekannt';
                })
                .filter(name => name);

            if (speakerNames.length > 0) {
                activeSpeakerName.innerHTML = `üó£Ô∏è <span class="d-none d-sm-inline">${speakerNames[0]}</span>`;
            } else {
                activeSpeakerName.innerHTML = 'üë• <span class="d-none d-sm-inline">Teiln.</span>';
            }
        } else {
            activeSpeakerName.innerHTML = 'üë• <span class="d-none d-sm-inline">Teiln.</span>';
        }

        // Show participants list if in audio
        const participantsList = document.getElementById('audio-participants-list');
        if (participantsList && this.isAudioActive) {
            participantsList.style.display = 'inline-block';
        }
    }

    showJoinNotification(username) {
        const notification = document.getElementById('audio-join-notification');
        const notificationText = document.getElementById('join-notification-text');

        if (notification && notificationText) {
            notificationText.textContent = `${username} ist Audio beigetreten`;
            notification.style.display = 'block';

            // Hide after 6 seconds (longer display)
            setTimeout(() => {
                notification.style.display = 'none';
            }, 6000);
        }
    }

    async tryToGetUsernameAndNotify(agoraUid) {
        console.log(`Trying to get username for Agora UID: ${agoraUid}`);

        // First try: Extract user ID from Agora UID pattern
        let userId = null;
        const agoraUidStr = agoraUid.toString();
        console.log(`Raw Agora UID: ${agoraUidStr}, length: ${agoraUidStr.length}`);

        // Try two patterns:
        // 1. Direct user ID (just the user ID number)
        // 2. Prefixed format (1XXXXXX where XXXXXX is user_id)

        if (agoraUidStr.startsWith('1') && agoraUidStr.length >= 2) {
            // Pattern: 1XXXXXX - extract the user ID part (remove leading '1')
            const userIdStr = agoraUidStr.substring(1);
            userId = parseInt(userIdStr);
            if (!isNaN(userId) && userId > 0) {
                console.log(`Extracted user ID from prefixed Agora UID: ${userId} (from ${userIdStr})`);
            } else {
                console.log(`Invalid user ID extracted from prefixed format: ${userIdStr}`);
                userId = null;
            }
        } else {
            // Pattern: Direct user ID
            userId = parseInt(agoraUidStr);
            if (!isNaN(userId) && userId > 0) {
                console.log(`Using direct Agora UID as user ID: ${userId}`);
            } else {
                console.log(`Invalid direct Agora UID: ${agoraUidStr}`);
                userId = null;
            }
        }

        // If we have a user ID, try to get username directly
        if (userId) {
            try {
                const response = await fetch(`/organization/api/user/${userId}/username/`);
                if (response.ok) {
                    const data = await response.json();
                    if (data.username) {
                        console.log(`Found username via direct lookup: ${data.username}`);
                        this.showJoinNotification(data.username);
                        return;
                    }
                }
            } catch (error) {
                console.log('Direct username lookup failed, trying participant list approach');
            }
        }

        // Fallback: Try participant list approach with multiple attempts
        let foundUsername = null;
        let attempts = 0;
        const maxAttempts = 3;

        while (!foundUsername && attempts < maxAttempts) {
            attempts++;
            console.log(`Participant list attempt ${attempts} for UID ${agoraUid}`);

            try {
                const response = await fetch(`/organization/boards/{{ board.pk }}/audio/status/`);
                const data = await response.json();
                console.log('Participants data:', data.participants);

                // Look for participant by agora_uid
                const newParticipant = data.participants.find(p => p.agora_uid == agoraUid);

                if (newParticipant) {
                    foundUsername = newParticipant.username;
                    console.log(`Found username in participant list: ${foundUsername}`);
                    break;
                } else {
                    console.log(`Participant not found in attempt ${attempts}, waiting...`);
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
            } catch (error) {
                console.error(`Error in attempt ${attempts}:`, error);
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
        }

        // Show notification with found username or fallback
        if (foundUsername) {
            this.showJoinNotification(foundUsername);
        } else {
            console.log('Could not find username after all attempts, using fallback');
            this.showJoinNotification('Ein neuer Teilnehmer');
        }
    }

    startPeriodicUpdates() {
        // Update participant list every 3 seconds to keep it in sync (faster for mute status)
        this.periodicUpdateInterval = setInterval(async () => {
            if (this.isAudioActive) {
                console.log('Periodic update: refreshing participant list');
                await this.checkAudioStatus();
            }
        }, 3000);
    }

    stopPeriodicUpdates() {
        if (this.periodicUpdateInterval) {
            clearInterval(this.periodicUpdateInterval);
            this.periodicUpdateInterval = null;
        }
    }

    updateSpeakingIndicators() {
        // Update visual indicators for speaking participants
        const participantItems = document.querySelectorAll('.participant-item');

        participantItems.forEach(item => {
            const uid = item.dataset.uid;
            const numericUid = parseInt(uid);
            const isSpeaking = this.activeSpeakers.has(numericUid) ||
                             (uid === 'local' && this.activeSpeakers.has(this.audioConfig?.uid)) ||
                             this.activeSpeakers.has(uid);

            if (isSpeaking) {
                item.classList.add('speaking');
                // Add speaking indicator if not present
                if (!item.querySelector('.speaking-indicator')) {
                    const indicator = document.createElement('span');
                    indicator.className = 'speaking-indicator';
                    item.appendChild(indicator);
                }
            } else {
                item.classList.remove('speaking');
                // Remove speaking indicator
                const indicator = item.querySelector('.speaking-indicator');
                if (indicator) {
                    indicator.remove();
                }
            }
        });

        // Update top-right speaking indicator
        const topIndicator = document.getElementById('speaking-indicator-top');
        const topSpeakerName = document.getElementById('speaking-name-top');

        if (this.activeSpeakers.size > 0 && this.isAudioActive) {
            const speakerName = Array.from(this.activeSpeakers)
                .map(uid => {
                    if (uid == (this.audioConfig ? this.audioConfig.uid : 'local')) {
                        return '{{ request.user.username }}';
                    }
                    const participant = Object.values(this.participants).find(p => p.user_id == uid);
                    return participant ? participant.username : null;
                })
                .filter(name => name)[0]; // Get first speaking person

            if (speakerName && topIndicator && topSpeakerName) {
                topIndicator.style.display = 'block';
                topSpeakerName.textContent = speakerName;
            }
        } else {
            if (topIndicator) {
                topIndicator.style.display = 'none';
            }
        }

        // Update main button text with active speaker
        this.updateParticipantsList();
    }

    async leaveAudio() {
        try {
            // Stop periodic updates
            this.stopPeriodicUpdates();

            // Agora Client cleanup
            if (this.localAudioTrack) {
                this.localAudioTrack.stop();
                this.localAudioTrack.close();
                this.localAudioTrack = null;
            }

            if (this.agoraClient) {
                await this.agoraClient.leave();
                this.agoraClient = null;
            }

            // Backend: Audio-Session verlassen
            const response = await fetch(`/organization/boards/{{ board.pk }}/audio/leave/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': '{{ csrf_token }}'
                }
            });

            if (!response.ok) {
                throw new Error('Failed to leave audio session');
            }

            this.isAudioActive = false;

            // Clear participants and speakers
            this.participants = {};
            this.activeSpeakers.clear();

            // Hide participants list and speaking indicator
            const participantsList = document.getElementById('audio-participants-list');
            if (participantsList) {
                participantsList.style.display = 'none';
            }

            const topIndicator = document.getElementById('speaking-indicator-top');
            if (topIndicator) {
                topIndicator.style.display = 'none';
            }

            this.checkAudioStatus();

            console.log('Successfully left board audio');

        } catch (error) {
            console.error('Error leaving audio:', error);
            alert('Fehler beim Verlassen des Audios: ' + error.message);
        }
    }

    async toggleMute() {
        if (!this.localAudioTrack) return;

        try {
            if (this.isMuted) {
                await this.localAudioTrack.setMuted(false);
                this.isMuted = false;
            } else {
                await this.localAudioTrack.setMuted(true);
                this.isMuted = true;
            }

            // Update backend with mute status
            await this.updateMuteStatus(this.isMuted);

            // Immediately update UI and trigger refresh for other users
            this.checkAudioStatus();

            // Force a quick refresh for other participants to see the change
            setTimeout(() => {
                this.checkAudioStatus();
            }, 1000);
        } catch (error) {
            console.error('Error toggling mute:', error);
        }
    }

    async updateMuteStatus(isMuted) {
        try {
            const response = await fetch(`/organization/boards/{{ board.pk }}/audio/mute/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify({
                    is_muted: isMuted
                })
            });

            if (!response.ok) {
                console.error('Failed to update mute status');
            }
        } catch (error) {
            console.error('Error updating mute status:', error);
        }
    }

    cleanup() {
        if (this.isAudioActive) {
            this.leaveAudio();
        }
    }
}

// Initialisiere Board Audio Manager
let boardAudioManager;

function initializeBoardAudio() {
    boardAudioManager = new BoardAudioManager();
}

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeBoardAudio);
} else {
    initializeBoardAudio();
}

// Cleanup when page is unloaded
window.addEventListener('beforeunload', function() {
    if (boardAudioManager) {
        boardAudioManager.cleanup();
    }
});

// Push-to-Talk mit Leertaste (gedr√ºckt halten zum Sprechen)
let wasSpacePressed = false;

document.addEventListener('keydown', function(e) {
    if (e.code === 'Space' && boardAudioManager && boardAudioManager.isAudioActive && !wasSpacePressed) {
        e.preventDefault();
        wasSpacePressed = true;
        // Temporarily unmute when space is pressed
        if (boardAudioManager.isMuted) {
            boardAudioManager.localAudioTrack.setMuted(false);
        }
    }
});

document.addEventListener('keyup', function(e) {
    if (e.code === 'Space' && boardAudioManager && boardAudioManager.isAudioActive && wasSpacePressed) {
        e.preventDefault();
        wasSpacePressed = false;
        // Mute again when space is released (if was muted before)
        if (boardAudioManager.isMuted) {
            boardAudioManager.localAudioTrack.setMuted(true);
        }
    }
});
</script>

<script>
// ========================================
// Board Notes Manager (Rich Text Editor)
// ========================================
class BoardNotesManager {
    constructor() {
        this.notesTextarea = document.getElementById('board-notes');
        this.saveButton = document.getElementById('save-notes-btn');
        this.statusText = document.getElementById('notes-status');
        this.saveTimeout = null;
        this.lastInputTime = null;

        this.initQuillEditor();
        this.initEventListeners();
        this.checkForUpdates();
    }

    initQuillEditor() {
        // Initialize Quill rich text editor
        this.quill = new Quill('#board-notes-editor', {
            theme: 'snow',
            modules: {
                toolbar: '#notes-toolbar'
            },
            placeholder: 'Hier k√∂nnen alle Teilnehmer gemeinsam Notizen zum Board hinzuf√ºgen...'
        });

        // Set initial content from textarea
        if (this.notesTextarea.value) {
            this.quill.root.innerHTML = this.notesTextarea.value;
        }

        this.lastSavedContent = this.quill.root.innerHTML;
    }

    initEventListeners() {
        // Auto-save on content changes with debouncing
        this.quill.on('text-change', () => {
            this.lastInputTime = Date.now();
            this.showStatus('√Ñnderungen erkannt...', 'text-warning');
            this.showAuthorInfo('{{ user.username }}');

            // Clear existing timeout
            if (this.saveTimeout) {
                clearTimeout(this.saveTimeout);
            }

            // Set new timeout for auto-save (2 seconds after last change)
            this.saveTimeout = setTimeout(() => {
                this.saveNotes(false);
            }, 2000);
        });

        // Manual save button
        this.saveButton.addEventListener('click', () => {
            this.saveNotes(true);
        });
    }

    async saveNotes(isManual = false) {
        const currentContent = this.quill.root.innerHTML;

        // Skip if content hasn't changed
        if (currentContent === this.lastSavedContent) {
            this.showStatus('Keine √Ñnderungen', 'text-muted');
            return;
        }

        try {
            this.showStatus('Speichern...', 'text-info');

            // Update hidden textarea for form compatibility
            this.notesTextarea.value = currentContent;

            const response = await fetch(`/organization/boards/{{ board.pk }}/update-notes/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
                },
                body: JSON.stringify({
                    notes: currentContent
                })
            });

            const data = await response.json();

            if (data.success) {
                this.lastSavedContent = currentContent;
                this.showStatus(isManual ? 'Manuell gespeichert ‚úì' : 'Automatisch gespeichert ‚úì', 'text-success');
                this.hideAuthorInfo();
            } else {
                this.showStatus('Fehler beim Speichern', 'text-danger');
            }
        } catch (error) {
            console.error('Error saving notes:', error);
            this.showStatus('Fehler beim Speichern', 'text-danger');
        }
    }

    showStatus(message, className) {
        this.statusText.textContent = message;
        this.statusText.className = `text-muted ${className}`;
    }

    showAuthorInfo(username) {
        const authorElement = document.getElementById('notes-author');
        const authorNameElement = document.getElementById('notes-author-name');

        authorNameElement.textContent = username;
        authorElement.style.display = 'block';

        // Hide author info after 3 seconds of no activity
        clearTimeout(this.authorTimeout);
        this.authorTimeout = setTimeout(() => {
            this.hideAuthorInfo();
        }, 3000);
    }

    hideAuthorInfo() {
        const authorElement = document.getElementById('notes-author');
        authorElement.style.display = 'none';
    }

    async checkForUpdates() {
        try {
            const response = await fetch(`/organization/boards/{{ board.pk }}/get-notes/`);
            const data = await response.json();

            const currentContent = this.quill.root.innerHTML;

            if (data.success && data.notes !== currentContent) {
                // Update only if user hasn't been actively typing
                const now = Date.now();
                if (!this.lastInputTime || now - this.lastInputTime > 5000) {
                    this.quill.root.innerHTML = data.notes || '';
                    this.notesTextarea.value = data.notes || '';
                    this.lastSavedContent = data.notes || '';
                    this.showStatus('Notizen aktualisiert', 'text-info');
                }
            }
        } catch (error) {
            console.error('Error checking for updates:', error);
        }

        // Check again in 10 seconds
        setTimeout(() => this.checkForUpdates(), 10000);
    }
}

// Initialize Notes Manager
let boardNotesManager;

function initializeBoardNotes() {
    boardNotesManager = new BoardNotesManager();
}

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeBoardNotes);
} else {
    initializeBoardNotes();
}
</script>

<style>
.tool-btn.active {
    background-color: #0d6efd;
    color: white;
}

/* Speaking Indicator Styles */
.participant-item {
    padding: 8px 12px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    transition: all 0.3s ease;
}

.participant-item.speaking {
    background: linear-gradient(90deg, rgba(40, 167, 69, 0.1) 0%, rgba(40, 167, 69, 0.2) 100%);
    border-left: 3px solid #28a745;
}

.speaking-indicator {
    display: inline-block;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background-color: #28a745;
    margin-left: 8px;
    animation: pulse 1.5s infinite;
}

@keyframes pulse {
    0% {
        box-shadow: 0 0 0 0 rgba(40, 167, 69, 0.7);
    }
    70% {
        box-shadow: 0 0 0 10px rgba(40, 167, 69, 0);
    }
    100% {
        box-shadow: 0 0 0 0 rgba(40, 167, 69, 0);
    }
}

.participant-name {
    font-weight: 500;
    flex: 1;
}

.participant-status {
    font-size: 0.8rem;
    color: #6c757d;
}

.tool-btn {
    min-width: 110px;
    min-height: 40px;
    text-align: center;
    display: flex;
    align-items: center;
    justify-content: center;
}

/* Rich Text Editor Styling */
#notes-toolbar {
    border: 1px solid #ccc;
    border-bottom: none;
    background-color: #f8f9fa;
    border-radius: 0.375rem 0.375rem 0 0;
}

#board-notes-editor {
    border: 1px solid #ccc;
    border-top: none;
    border-radius: 0 0 0.375rem 0.375rem;
}

.ql-editor {
    min-height: 120px;
}

.ql-toolbar.ql-snow {
    border: none;
    padding: 8px;
}

.ql-container.ql-snow {
    border: none;
}

#canvas-container {
    max-width: 100%;
    overflow: auto;
}

.form-control-color {
    width: 100%;
    height: 40px;
}

/* Mobile responsive styles */
@media (max-width: 991.98px) {
    /* Transform vertical button group to horizontal on mobile */
    .btn-group-horizontal-mobile {
        display: flex !important;
        flex-direction: row !important;
        flex-wrap: wrap !important;
        gap: 4px !important;
    }
    
    .btn-group-horizontal-mobile .tool-btn {
        flex: 1 1 calc(20% - 4px) !important;
        min-width: 60px !important;
        padding: 8px 4px !important;
        font-size: 12px !important;
        border-radius: 6px !important;
        white-space: nowrap !important;
        overflow: hidden !important;
        text-overflow: ellipsis !important;
    }
    
    /* Hide text on very small screens, show only icons */
    .btn-group-horizontal-mobile .tool-btn i {
        display: block !important;
        margin-right: 0 !important;
        font-size: 16px !important;
    }
    
    /* Canvas container adjustments for mobile */
    #canvas-container {
        overflow-x: auto !important;
        overflow-y: auto !important;
        max-width: 100vw !important;
        padding: 10px !important;
    }
    
    #drawing-canvas {
        max-width: 100% !important;
        height: auto !important;
        touch-action: none !important; /* Prevent page scrolling while drawing */
    }
    
    /* Mobile card adjustments */
    .card-body {
        padding: 0.75rem !important;
    }
    
    /* Smaller controls on mobile */
    .form-control, .form-select {
        font-size: 14px !important;
        padding: 6px 8px !important;
    }
    
    .btn {
        font-size: 14px !important;
        padding: 6px 12px !important;
    }
}

@media (max-width: 575.98px) {
    /* Even more compact on very small screens */
    .btn-group-horizontal-mobile .tool-btn {
        flex: 1 1 calc(25% - 3px) !important;
        padding: 6px 2px !important;
        font-size: 0 !important; /* Hide text completely */
    }
    
    .btn-group-horizontal-mobile .tool-btn i {
        font-size: 14px !important;
    }
    
    /* Stack canvas below tools on very small screens */
    .row {
        margin: 0 !important;
    }
    
    .col-12 {
        padding: 0.25rem !important;
    }
}
</style>
{% endblock %}